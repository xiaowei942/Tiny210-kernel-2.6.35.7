drivers/mmc/card/queue.c:135:	if (host->max_hw_segs == 1) {
drivers/mmc/card/queue.c:140:		if (bouncesz > host->max_req_size)
drivers/mmc/card/queue.c:141:			bouncesz = host->max_req_size;
drivers/mmc/card/queue.c:142:		if (bouncesz > host->max_seg_size)
drivers/mmc/card/queue.c:143:			bouncesz = host->max_seg_size;
drivers/mmc/card/queue.c:144:		if (bouncesz > (host->max_blk_count * 512))
drivers/mmc/card/queue.c:145:			bouncesz = host->max_blk_count * 512;
drivers/mmc/card/queue.c:184:			min(host->max_blk_count, host->max_req_size / 512));
drivers/mmc/card/queue.c:185:		blk_queue_max_segments(mq->queue, host->max_hw_segs);
drivers/mmc/card/queue.c:186:		blk_queue_max_segment_size(mq->queue, host->max_seg_size);
drivers/mmc/card/queue.c:189:			host->max_phys_segs, GFP_KERNEL);
drivers/mmc/card/queue.c:194:		sg_init_table(mq->sg, host->max_phys_segs);
drivers/mmc/card/mmc_test.c:542:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:546:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:547:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:548:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:568:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:572:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:573:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:574:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:696:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:700:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:701:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:702:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:723:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:727:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:728:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:729:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:778:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:796:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:848:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:852:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:853:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:854:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:875:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:879:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:880:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:881:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/block.c:189:		(card->host->ios.clock / 1000);
drivers/mmc/card/block.c:307:		if (brq.data.blocks > card->host->max_blk_count)
drivers/mmc/card/block.c:308:			brq.data.blocks = card->host->max_blk_count;
Binary file drivers/mmc/built-in.o matches
Binary file drivers/mmc/core/.core.c.swp matches
drivers/mmc/core/mmc_ops.c:64:	struct mmc_card *card = host->card;
drivers/mmc/core/mmc_ops.c:88:	if (!(host->caps & MMC_CAP_WAIT_WHILE_BUSY))
drivers/mmc/core/mmc_ops.c:131:	host->use_spi_crc = 0;
drivers/mmc/core/mmc_ops.c:334:		if (!host->card)
drivers/mmc/core/mmc_ops.c:336:		return mmc_send_cxd_native(host, host->card->rca << 16,
drivers/mmc/core/mmc_ops.c:386:		host->use_spi_crc = use_crc;
drivers/mmc/core/mmc_ops.c:417:		if (card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)
Binary file drivers/mmc/core/host.o matches
drivers/mmc/core/sdio_io.c:162:	if (blksz > func->card->host->max_blk_size)
drivers/mmc/core/sdio_io.c:166:		blksz = min(func->max_blksize, func->card->host->max_blk_size);
drivers/mmc/core/sdio_io.c:190:	unsigned mval =	min(func->card->host->max_seg_size,
drivers/mmc/core/sdio_io.c:191:			    func->card->host->max_blk_size);
drivers/mmc/core/sdio_io.c:312:		max_blocks = min(func->card->host->max_blk_count,
drivers/mmc/core/sdio_io.c:313:			func->card->host->max_seg_size / func->cur_blksize);
drivers/mmc/core/sdio_io.c:728:	return func->card->host->pm_caps;
drivers/mmc/core/sdio_io.c:753:	if (flags & ~host->pm_caps)
drivers/mmc/core/sdio_io.c:757:	host->pm_flags |= flags;
drivers/mmc/core/sdio_bus.c:212:	if (!func->card->host->embedded_sdio_data.funcs)
drivers/mmc/core/sdio.c:150:	if (!(card->host->caps & MMC_CAP_4_BIT_DATA))
drivers/mmc/core/sdio.c:211:	if (!(card->host->caps & MMC_CAP_4_BIT_DATA))
drivers/mmc/core/sdio.c:244:	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
drivers/mmc/core/sdio.c:280:	WARN_ON(!host->claimed);
drivers/mmc/core/sdio.c:289:		err = mmc_send_io_op_cond(host, host->ocr, &ocr);
drivers/mmc/core/sdio.c:318:	if (host->ops->init_card)
drivers/mmc/core/sdio.c:321:		host->ops->init_card(host, card);
drivers/mmc/core/sdio.c:349:	if (host->embedded_sdio_data.cccr)
drivers/mmc/core/sdio.c:352:		memcpy(&card->cccr, host->embedded_sdio_data.cccr, sizeof(struct sdio_cccr));
drivers/mmc/core/sdio.c:369:	if (host->embedded_sdio_data.cis)
drivers/mmc/core/sdio.c:372:		memcpy(&card->cis, host->embedded_sdio_data.cis, sizeof(struct sdio_cis));
drivers/mmc/core/sdio.c:403:		host->card = card;
drivers/mmc/core/sdio.c:449:		host->card = NULL;
drivers/mmc/core/sdio.c:464:	BUG_ON(!host->card);
drivers/mmc/core/sdio.c:466:	for (i = 0;i < host->card->sdio_funcs;i++) {
drivers/mmc/core/sdio.c:467:		if (host->card->sdio_func[i]) {
drivers/mmc/core/sdio.c:468:			sdio_remove_func(host->card->sdio_func[i]);
drivers/mmc/core/sdio.c:469:			host->card->sdio_func[i] = NULL;
drivers/mmc/core/sdio.c:473:	mmc_remove_card(host->card);
drivers/mmc/core/sdio.c:474:	host->card = NULL;
drivers/mmc/core/sdio.c:485:	BUG_ON(!host->card);
drivers/mmc/core/sdio.c:492:	err = mmc_select_card(host->card);
drivers/mmc/core/sdio.c:514:	for (i = 0; i < host->card->sdio_funcs; i++) {
drivers/mmc/core/sdio.c:515:		struct sdio_func *func = host->card->sdio_func[i];
drivers/mmc/core/sdio.c:528:		struct sdio_func *func = host->card->sdio_func[i];
drivers/mmc/core/sdio.c:535:	if (!err && host->pm_flags & MMC_PM_KEEP_POWER) {
drivers/mmc/core/sdio.c:537:		sdio_disable_wide(host->card);
drivers/mmc/core/sdio.c:549:	BUG_ON(!host->card);
drivers/mmc/core/sdio.c:553:	err = mmc_sdio_init_card(host, host->ocr, host->card,
drivers/mmc/core/sdio.c:554:				 (host->pm_flags & MMC_PM_KEEP_POWER));
drivers/mmc/core/sdio.c:557:		err = sdio_enable_wide(host->card);
drivers/mmc/core/sdio.c:558:	if (!err && host->sdio_irqs)
drivers/mmc/core/sdio.c:572:	for (i = 0; !err && i < host->card->sdio_funcs; i++) {
drivers/mmc/core/sdio.c:573:		struct sdio_func *func = host->card->sdio_func[i];
drivers/mmc/core/sdio.c:601:	WARN_ON(!host->claimed);
drivers/mmc/core/sdio.c:616:	host->ocr = mmc_select_voltage(host, ocr);
drivers/mmc/core/sdio.c:621:	if (!host->ocr) {
drivers/mmc/core/sdio.c:629:	err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
drivers/mmc/core/sdio.c:634:	card = host->card;
drivers/mmc/core/sdio.c:644:	if (host->embedded_sdio_data.funcs)
drivers/mmc/core/sdio.c:645:		card->sdio_funcs = funcs = host->embedded_sdio_data.num_funcs;
drivers/mmc/core/sdio.c:660:		if (host->embedded_sdio_data.funcs) {
drivers/mmc/core/sdio.c:663:			tmp = sdio_alloc_func(host->card);
drivers/mmc/core/sdio.c:668:			tmp->class = host->embedded_sdio_data.funcs[i].f_class;
drivers/mmc/core/sdio.c:669:			tmp->max_blksize = host->embedded_sdio_data.funcs[i].f_maxblksize;
drivers/mmc/core/sdio.c:674:			err = sdio_init_func(host->card, i + 1);
drivers/mmc/core/sdio.c:687:	err = mmc_add_card(host->card);
drivers/mmc/core/sdio.c:695:		err = sdio_add_func(host->card->sdio_func[i]);
drivers/mmc/core/sdio.c:711:	if (host->card)
drivers/mmc/core/sdio.c:734:	mmc_set_clock(host, host->f_min);
drivers/mmc/core/sdio.c:740:	host->ocr = mmc_select_voltage(host, ocr);
drivers/mmc/core/sdio.c:741:	if (!host->ocr) {
drivers/mmc/core/sdio.c:746:	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
drivers/mmc/core/sdio_irq.c:84:	period = (host->caps & MMC_CAP_SDIO_IRQ) ?
drivers/mmc/core/sdio_irq.c:104:		ret = __mmc_claim_host(host, &host->sdio_irq_thread_abort);
drivers/mmc/core/sdio_irq.c:107:		ret = process_sdio_pending_irqs(host->card);
drivers/mmc/core/sdio_irq.c:126:		if (!(host->caps & MMC_CAP_SDIO_IRQ)) {
drivers/mmc/core/sdio_irq.c:137:		if (host->caps & MMC_CAP_SDIO_IRQ)
drivers/mmc/core/sdio_irq.c:138:			host->ops->enable_sdio_irq(host, 1);
drivers/mmc/core/sdio_irq.c:144:	if (host->caps & MMC_CAP_SDIO_IRQ)
drivers/mmc/core/sdio_irq.c:145:		host->ops->enable_sdio_irq(host, 0);
drivers/mmc/core/sdio_irq.c:157:	WARN_ON(!host->claimed);
drivers/mmc/core/sdio_irq.c:159:	if (!host->sdio_irqs++) {
drivers/mmc/core/sdio_irq.c:160:		atomic_set(&host->sdio_irq_thread_abort, 0);
drivers/mmc/core/sdio_irq.c:161:		host->sdio_irq_thread =
drivers/mmc/core/sdio_irq.c:164:		if (IS_ERR(host->sdio_irq_thread)) {
drivers/mmc/core/sdio_irq.c:165:			int err = PTR_ERR(host->sdio_irq_thread);
drivers/mmc/core/sdio_irq.c:166:			host->sdio_irqs--;
drivers/mmc/core/sdio_irq.c:178:	WARN_ON(!host->claimed);
drivers/mmc/core/sdio_irq.c:179:	BUG_ON(host->sdio_irqs < 1);
drivers/mmc/core/sdio_irq.c:181:	if (!--host->sdio_irqs) {
drivers/mmc/core/sdio_irq.c:182:		atomic_set(&host->sdio_irq_thread_abort, 1);
drivers/mmc/core/sdio_irq.c:183:		kthread_stop(host->sdio_irq_thread);
Binary file drivers/mmc/core/built-in.o matches
Binary file drivers/mmc/core/mmc_core.o matches
drivers/mmc/core/debugfs.c:45:	struct mmc_ios	*ios = &host->ios;
drivers/mmc/core/debugfs.c:150:	host->debugfs_root = root;
drivers/mmc/core/debugfs.c:159:	host->debugfs_root = NULL;
drivers/mmc/core/debugfs.c:161:	dev_err(&host->class_dev, "failed to initialize debugfs\n");
drivers/mmc/core/debugfs.c:166:	debugfs_remove_recursive(host->debugfs_root);
drivers/mmc/core/debugfs.c:255:	if (!host->debugfs_root)
drivers/mmc/core/debugfs.c:258:	root = debugfs_create_dir(mmc_card_id(card), host->debugfs_root);
drivers/mmc/core/sd.c:252:	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
drivers/mmc/core/sd.c:344:	WARN_ON(!host->claimed);
drivers/mmc/core/sd.c:397:		host->card = card;
drivers/mmc/core/sd.c:509:	if ((host->caps & MMC_CAP_4_BIT_DATA) &&
drivers/mmc/core/sd.c:522:		if (!host->ops->get_ro || host->ops->get_ro(host) < 0) {
drivers/mmc/core/sd.c:528:			if (host->ops->get_ro(host) > 0)
drivers/mmc/core/sd.c:538:		host->card = NULL;
drivers/mmc/core/sd.c:551:	BUG_ON(!host->card);
drivers/mmc/core/sd.c:553:	mmc_remove_card(host->card);
drivers/mmc/core/sd.c:554:	host->card = NULL;
drivers/mmc/core/sd.c:568:	BUG_ON(!host->card);
drivers/mmc/core/sd.c:577:		err = mmc_send_status(host->card, NULL);
drivers/mmc/core/sd.c:590:	err = mmc_send_status(host->card, NULL);
drivers/mmc/core/sd.c:609:	BUG_ON(!host->card);
drivers/mmc/core/sd.c:614:	host->card->state &= ~MMC_STATE_HIGHSPEED;
drivers/mmc/core/sd.c:634:	BUG_ON(!host->card);
drivers/mmc/core/sd.c:640:		err = mmc_sd_init_card(host, host->ocr, host->card);
drivers/mmc/core/sd.c:652:	err = mmc_sd_init_card(host, host->ocr, host->card);
drivers/mmc/core/sd.c:661:	host->card->state &= ~MMC_STATE_HIGHSPEED;
drivers/mmc/core/sd.c:663:	mmc_sd_init_card(host, host->ocr, host->card);
drivers/mmc/core/sd.c:687:	if (host->caps & MMC_CAP_NONREMOVABLE || !mmc_assume_removable)
drivers/mmc/core/sd.c:705:	WARN_ON(!host->claimed);
drivers/mmc/core/sd.c:738:	host->ocr = mmc_select_voltage(host, ocr);
drivers/mmc/core/sd.c:743:	if (!host->ocr) {
drivers/mmc/core/sd.c:754:		err = mmc_sd_init_card(host, host->ocr, NULL);
drivers/mmc/core/sd.c:768:	err = mmc_sd_init_card(host, host->ocr, NULL);
drivers/mmc/core/sd.c:775:	err = mmc_add_card(host->card);
drivers/mmc/core/sd.c:782:	mmc_remove_card(host->card);
drivers/mmc/core/sd.c:783:	host->card = NULL;
drivers/mmc/core/host.c:73:	err = idr_get_new(&mmc_host_idr, host, &host->index);
drivers/mmc/core/host.c:78:	dev_set_name(&host->class_dev, "mmc%d", host->index);
drivers/mmc/core/host.c:80:	host->parent = dev;
drivers/mmc/core/host.c:81:	host->class_dev.parent = dev;
drivers/mmc/core/host.c:82:	host->class_dev.class = &mmc_host_class;
drivers/mmc/core/host.c:83:	device_initialize(&host->class_dev);
drivers/mmc/core/host.c:85:	spin_lock_init(&host->lock);
drivers/mmc/core/host.c:86:	init_waitqueue_head(&host->wq);
drivers/mmc/core/host.c:88:	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
drivers/mmc/core/host.c:89:	INIT_DELAYED_WORK_DEFERRABLE(&host->disable, mmc_host_deeper_disable);
drivers/mmc/core/host.c:91:	host->pm_notify.notifier_call = mmc_pm_notify;
drivers/mmc/core/host.c:98:	host->max_hw_segs = 1;
drivers/mmc/core/host.c:99:	host->max_phys_segs = 1;
drivers/mmc/core/host.c:100:	host->max_seg_size = PAGE_CACHE_SIZE;
drivers/mmc/core/host.c:102:	host->max_req_size = PAGE_CACHE_SIZE;
drivers/mmc/core/host.c:103:	host->max_blk_size = 512;
drivers/mmc/core/host.c:104:	host->max_blk_count = PAGE_CACHE_SIZE / 512;
drivers/mmc/core/host.c:128:	WARN_ON((host->caps & MMC_CAP_SDIO_IRQ) &&
drivers/mmc/core/host.c:129:		!host->ops->enable_sdio_irq);
drivers/mmc/core/host.c:131:	led_trigger_register_simple(dev_name(&host->class_dev), &host->led);
drivers/mmc/core/host.c:133:	err = device_add(&host->class_dev);
drivers/mmc/core/host.c:142:	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
drivers/mmc/core/host.c:143:		register_pm_notifier(&host->pm_notify);
drivers/mmc/core/host.c:160:	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
drivers/mmc/core/host.c:161:		unregister_pm_notifier(&host->pm_notify);
drivers/mmc/core/host.c:169:	device_del(&host->class_dev);
drivers/mmc/core/host.c:171:	led_trigger_unregister_simple(host->led);
drivers/mmc/core/host.c:185:	idr_remove(&mmc_host_idr, host->index);
drivers/mmc/core/host.c:188:	put_device(&host->class_dev);
drivers/mmc/core/mmc.c:323:	WARN_ON(!host->claimed);
drivers/mmc/core/mmc.c:377:		host->card = card;
drivers/mmc/core/mmc.c:429:		(host->caps & MMC_CAP_MMC_HIGHSPEED)) {
drivers/mmc/core/mmc.c:463:	    (host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA))) {
drivers/mmc/core/mmc.c:466:		if (host->caps & MMC_CAP_8_BIT_DATA) {
drivers/mmc/core/mmc.c:495:		host->card = NULL;
drivers/mmc/core/mmc.c:508:	BUG_ON(!host->card);
drivers/mmc/core/mmc.c:510:	mmc_remove_card(host->card);
drivers/mmc/core/mmc.c:511:	host->card = NULL;
drivers/mmc/core/mmc.c:522:	BUG_ON(!host->card);
drivers/mmc/core/mmc.c:529:	err = mmc_send_status(host->card, NULL);
drivers/mmc/core/mmc.c:548:	BUG_ON(!host->card);
drivers/mmc/core/mmc.c:553:	host->card->state &= ~MMC_STATE_HIGHSPEED;
drivers/mmc/core/mmc.c:570:	BUG_ON(!host->card);
drivers/mmc/core/mmc.c:573:	err = mmc_init_card(host, host->ocr, host->card);
drivers/mmc/core/mmc.c:581:	host->card->state &= ~MMC_STATE_HIGHSPEED;
drivers/mmc/core/mmc.c:583:	mmc_init_card(host, host->ocr, host->card);
drivers/mmc/core/mmc.c:589:	struct mmc_card *card = host->card;
drivers/mmc/core/mmc.c:604:	struct mmc_card *card = host->card;
drivers/mmc/core/mmc.c:641:	if (host->caps & MMC_CAP_NONREMOVABLE || !mmc_assume_removable)
drivers/mmc/core/mmc.c:656:	WARN_ON(!host->claimed);
drivers/mmc/core/mmc.c:680:	host->ocr = mmc_select_voltage(host, ocr);
drivers/mmc/core/mmc.c:685:	if (!host->ocr) {
drivers/mmc/core/mmc.c:693:	err = mmc_init_card(host, host->ocr, NULL);
drivers/mmc/core/mmc.c:699:	err = mmc_add_card(host->card);
drivers/mmc/core/mmc.c:706:	mmc_remove_card(host->card);
drivers/mmc/core/mmc.c:707:	host->card = NULL;
drivers/mmc/core/core.c:120:		host->ops->request(host, mrq);
drivers/mmc/core/core.c:122:		led_trigger_event(host->led, LED_OFF);
drivers/mmc/core/core.c:177:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:179:	led_trigger_event(host->led, LED_FULL);
drivers/mmc/core/core.c:184:		BUG_ON(mrq->data->blksz > host->max_blk_size);
drivers/mmc/core/core.c:185:		BUG_ON(mrq->data->blocks > host->max_blk_count);
drivers/mmc/core/core.c:187:			host->max_req_size);
drivers/mmc/core/core.c:205:	host->ops->request(host, mrq);
drivers/mmc/core/core.c:251:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:312:			(card->host->ios.clock / 1000);
drivers/mmc/core/core.c:386:	if (!(host->caps & MMC_CAP_DISABLE))
drivers/mmc/core/core.c:389:	if (host->en_dis_recurs)
drivers/mmc/core/core.c:392:	if (host->nesting_cnt++)
drivers/mmc/core/core.c:395:	cancel_delayed_work_sync(&host->disable);
drivers/mmc/core/core.c:397:	if (host->enabled)
drivers/mmc/core/core.c:400:	if (host->ops->enable) {
drivers/mmc/core/core.c:403:		host->en_dis_recurs = 1;
drivers/mmc/core/core.c:404:		err = host->ops->enable(host);
drivers/mmc/core/core.c:405:		host->en_dis_recurs = 0;
drivers/mmc/core/core.c:413:	host->enabled = 1;
drivers/mmc/core/core.c:420:	if (host->ops->disable) {
drivers/mmc/core/core.c:423:		host->en_dis_recurs = 1;
drivers/mmc/core/core.c:424:		err = host->ops->disable(host, lazy);
drivers/mmc/core/core.c:425:		host->en_dis_recurs = 0;
drivers/mmc/core/core.c:435:			mmc_schedule_delayed_work(&host->disable, delay);
drivers/mmc/core/core.c:438:	host->enabled = 0;
drivers/mmc/core/core.c:454:	if (!(host->caps & MMC_CAP_DISABLE))
drivers/mmc/core/core.c:457:	if (host->en_dis_recurs)
drivers/mmc/core/core.c:460:	if (--host->nesting_cnt)
drivers/mmc/core/core.c:463:	if (!host->enabled)
drivers/mmc/core/core.c:489:	add_wait_queue(&host->wq, &wait);
drivers/mmc/core/core.c:490:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:494:		if (stop || !host->claimed || host->claimer == current)
drivers/mmc/core/core.c:496:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:498:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:502:		host->claimed = 1;
drivers/mmc/core/core.c:503:		host->claimer = current;
drivers/mmc/core/core.c:504:		host->claim_cnt += 1;
drivers/mmc/core/core.c:506:		wake_up(&host->wq);
drivers/mmc/core/core.c:507:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:508:	remove_wait_queue(&host->wq, &wait);
drivers/mmc/core/core.c:527:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:528:	if (!host->claimed || host->claimer == current) {
drivers/mmc/core/core.c:529:		host->claimed = 1;
drivers/mmc/core/core.c:530:		host->claimer = current;
drivers/mmc/core/core.c:531:		host->claim_cnt += 1;
drivers/mmc/core/core.c:534:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:543:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:544:	if (--host->claim_cnt) {
drivers/mmc/core/core.c:546:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:548:		host->claimed = 0;
drivers/mmc/core/core.c:549:		host->claimer = NULL;
drivers/mmc/core/core.c:550:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:551:		wake_up(&host->wq);
drivers/mmc/core/core.c:580:	if (!(host->caps & MMC_CAP_DISABLE))
drivers/mmc/core/core.c:583:	if (host->en_dis_recurs)
drivers/mmc/core/core.c:586:	if (--host->nesting_cnt)
drivers/mmc/core/core.c:589:	if (!host->enabled)
drivers/mmc/core/core.c:592:	if (host->disable_delay) {
drivers/mmc/core/core.c:593:		mmc_schedule_delayed_work(&host->disable,
drivers/mmc/core/core.c:594:				msecs_to_jiffies(host->disable_delay));
drivers/mmc/core/core.c:610:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:625:	struct mmc_ios *ios = &host->ios;
drivers/mmc/core/core.c:633:	host->ops->set_ios(host, ios);
drivers/mmc/core/core.c:641:	host->ios.chip_select = mode;
drivers/mmc/core/core.c:651:	WARN_ON(hz < host->f_min);
drivers/mmc/core/core.c:653:	if (hz > host->f_max)
drivers/mmc/core/core.c:654:		hz = host->f_max;
drivers/mmc/core/core.c:656:	host->ios.clock = hz;
drivers/mmc/core/core.c:665:	host->ios.bus_mode = mode;
drivers/mmc/core/core.c:674:	host->ios.bus_width = width;
drivers/mmc/core/core.c:790: * mmc_regulator_set_ocr - set regulator to match host->ios voltage
drivers/mmc/core/core.c:791: * @vdd_bit: zero for power off, else a bit number (host->ios.vdd)
drivers/mmc/core/core.c:859:	ocr &= host->ocr_avail;
drivers/mmc/core/core.c:867:		host->ios.vdd = bit;
drivers/mmc/core/core.c:883:	host->ios.timing = timing;
drivers/mmc/core/core.c:903:	if (host->ocr)
drivers/mmc/core/core.c:904:		bit = ffs(host->ocr) - 1;
drivers/mmc/core/core.c:906:		bit = fls(host->ocr_avail) - 1;
drivers/mmc/core/core.c:908:	host->ios.vdd = bit;
drivers/mmc/core/core.c:910:		host->ios.chip_select = MMC_CS_HIGH;
drivers/mmc/core/core.c:911:		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
drivers/mmc/core/core.c:913:		host->ios.chip_select = MMC_CS_DONTCARE;
drivers/mmc/core/core.c:914:		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
drivers/mmc/core/core.c:916:	host->ios.power_mode = MMC_POWER_UP;
drivers/mmc/core/core.c:917:	host->ios.bus_width = MMC_BUS_WIDTH_1;
drivers/mmc/core/core.c:918:	host->ios.timing = MMC_TIMING_LEGACY;
drivers/mmc/core/core.c:927:	host->ios.clock = host->f_min;
drivers/mmc/core/core.c:929:	host->ios.power_mode = MMC_POWER_ON;
drivers/mmc/core/core.c:941:	host->ios.clock = 0;
drivers/mmc/core/core.c:942:	host->ios.vdd = 0;
drivers/mmc/core/core.c:944:		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
drivers/mmc/core/core.c:945:		host->ios.chip_select = MMC_CS_DONTCARE;
drivers/mmc/core/core.c:947:	host->ios.power_mode = MMC_POWER_OFF;
drivers/mmc/core/core.c:948:	host->ios.bus_width = MMC_BUS_WIDTH_1;
drivers/mmc/core/core.c:949:	host->ios.timing = MMC_TIMING_LEGACY;
drivers/mmc/core/core.c:959:	BUG_ON(host->bus_refs);
drivers/mmc/core/core.c:960:	BUG_ON(!host->bus_dead);
drivers/mmc/core/core.c:962:	host->bus_ops = NULL;
drivers/mmc/core/core.c:972:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:973:	host->bus_refs++;
drivers/mmc/core/core.c:974:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:985:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:986:	host->bus_refs--;
drivers/mmc/core/core.c:987:	if ((host->bus_refs == 0) && host->bus_ops)
drivers/mmc/core/core.c:989:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1000:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:1001:	host->bus_resume_flags &= ~MMC_BUSRESUME_NEEDS_RESUME;
drivers/mmc/core/core.c:1002:	host->rescan_disable = 0;
drivers/mmc/core/core.c:1003:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1006:	if (host->bus_ops && !host->bus_dead) {
drivers/mmc/core/core.c:1008:		BUG_ON(!host->bus_ops->resume);
drivers/mmc/core/core.c:1009:		host->bus_ops->resume(host);
drivers/mmc/core/core.c:1012:	if (host->bus_ops->detect && !host->bus_dead)
drivers/mmc/core/core.c:1013:		host->bus_ops->detect(host);
drivers/mmc/core/core.c:1033:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:1035:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:1037:	BUG_ON(host->bus_ops);
drivers/mmc/core/core.c:1038:	BUG_ON(host->bus_refs);
drivers/mmc/core/core.c:1040:	host->bus_ops = ops;
drivers/mmc/core/core.c:1041:	host->bus_refs = 1;
drivers/mmc/core/core.c:1042:	host->bus_dead = 0;
drivers/mmc/core/core.c:1044:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1057:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:1058:	WARN_ON(!host->bus_ops);
drivers/mmc/core/core.c:1060:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:1062:	host->bus_dead = 1;
drivers/mmc/core/core.c:1064:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1085:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:1086:	WARN_ON(host->removed);
drivers/mmc/core/core.c:1087:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1090:	mmc_schedule_delayed_work(&host->detect, delay);
drivers/mmc/core/core.c:1106:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:1108:	if (host->rescan_disable) {
drivers/mmc/core/core.c:1109:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1113:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1119:	if ((host->bus_ops != NULL) && host->bus_ops->detect && !host->bus_dead) {
drivers/mmc/core/core.c:1120:		if(host->ops->get_cd && host->ops->get_cd(host) == 0) {
drivers/mmc/core/core.c:1121:			if(host->bus_ops->remove)
drivers/mmc/core/core.c:1122:				host->bus_ops->remove(host);
drivers/mmc/core/core.c:1129:			host->bus_ops->detect(host);
drivers/mmc/core/core.c:1135:	if (host->bus_dead)
drivers/mmc/core/core.c:1144:	if (host->bus_ops != NULL) {
drivers/mmc/core/core.c:1157:	if (host->ops->get_cd && host->ops->get_cd(host) == 0)
drivers/mmc/core/core.c:1168:	mmc_send_if_cond(host, host->ocr_avail);
drivers/mmc/core/core.c:1221:	if (host->caps & MMC_CAP_NEEDS_POLL)
drivers/mmc/core/core.c:1222:		mmc_schedule_delayed_work(&host->detect, HZ);
drivers/mmc/core/core.c:1235:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:1236:	host->removed = 1;
drivers/mmc/core/core.c:1237:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1240:	if (host->caps & MMC_CAP_DISABLE)
drivers/mmc/core/core.c:1241:		cancel_delayed_work(&host->disable);
drivers/mmc/core/core.c:1242:	cancel_delayed_work(&host->detect);
drivers/mmc/core/core.c:1246:	host->pm_flags = 0;
drivers/mmc/core/core.c:1249:	if (host->bus_ops && !host->bus_dead) {
drivers/mmc/core/core.c:1250:		if (host->bus_ops->remove)
drivers/mmc/core/core.c:1251:			host->bus_ops->remove(host);
drivers/mmc/core/core.c:1261:	BUG_ON(host->card);
drivers/mmc/core/core.c:1270:	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
drivers/mmc/core/core.c:1275:	if (host->bus_ops->power_save)
drivers/mmc/core/core.c:1276:		host->bus_ops->power_save(host);
drivers/mmc/core/core.c:1288:	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
drivers/mmc/core/core.c:1294:	host->bus_ops->power_restore(host);
drivers/mmc/core/core.c:1306:	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
drivers/mmc/core/core.c:1307:		err = host->bus_ops->awake(host);
drivers/mmc/core/core.c:1321:	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
drivers/mmc/core/core.c:1322:		err = host->bus_ops->sleep(host);
drivers/mmc/core/core.c:1332:	struct mmc_card *card = host->card;
drivers/mmc/core/core.c:1342:	if(host->ops->adjust_cfg)
drivers/mmc/core/core.c:1343:		host->ops->adjust_cfg(host, rw);
drivers/mmc/core/core.c:1360:	if (host->caps & MMC_CAP_DISABLE)
drivers/mmc/core/core.c:1361:		cancel_delayed_work(&host->disable);
drivers/mmc/core/core.c:1362:	cancel_delayed_work(&host->detect);
drivers/mmc/core/core.c:1366:	if (host->bus_ops && !host->bus_dead) {
drivers/mmc/core/core.c:1367:		if (host->bus_ops->suspend)
drivers/mmc/core/core.c:1368:			err = host->bus_ops->suspend(host);
drivers/mmc/core/core.c:1372:	if (!err && !(host->pm_flags & MMC_PM_KEEP_POWER))
drivers/mmc/core/core.c:1390:		host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
drivers/mmc/core/core.c:1395:	if (host->bus_ops && !host->bus_dead) {
drivers/mmc/core/core.c:1396:		if (!(host->pm_flags & MMC_PM_KEEP_POWER)) {
drivers/mmc/core/core.c:1398:			mmc_select_voltage(host, host->ocr);
drivers/mmc/core/core.c:1400:		BUG_ON(!host->bus_ops->resume);
drivers/mmc/core/core.c:1401:		err = host->bus_ops->resume(host);
drivers/mmc/core/core.c:1431:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:1433:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1436:		host->rescan_disable = 1;
drivers/mmc/core/core.c:1437:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1438:		cancel_delayed_work_sync(&host->detect);
drivers/mmc/core/core.c:1440:		if (!host->bus_ops || host->bus_ops->suspend)
drivers/mmc/core/core.c:1445:		if (host->bus_ops->remove)
drivers/mmc/core/core.c:1446:			host->bus_ops->remove(host);
drivers/mmc/core/core.c:1450:		host->pm_flags = 0;
drivers/mmc/core/core.c:1456:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:1458:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1461:		host->rescan_disable = 0;
drivers/mmc/core/core.c:1462:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:1478:	host->embedded_sdio_data.cis = cis;
drivers/mmc/core/core.c:1479:	host->embedded_sdio_data.cccr = cccr;
drivers/mmc/core/core.c:1480:	host->embedded_sdio_data.funcs = funcs;
drivers/mmc/core/core.c:1481:	host->embedded_sdio_data.num_funcs = num_funcs;
drivers/mmc/host/mmc_spi.c:165:	return spi_setup(host->spi);
drivers/mmc/host/mmc_spi.c:173:	if (len > sizeof(*host->data)) {
drivers/mmc/host/mmc_spi.c:178:	host->status.len = len;
drivers/mmc/host/mmc_spi.c:180:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:181:		dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:182:				host->data_dma, sizeof(*host->data),
drivers/mmc/host/mmc_spi.c:185:	status = spi_sync(host->spi, &host->readback);
drivers/mmc/host/mmc_spi.c:187:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:188:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:189:				host->data_dma, sizeof(*host->data),
drivers/mmc/host/mmc_spi.c:198:	u8		*cp = host->data->status;
drivers/mmc/host/mmc_spi.c:230:	return mmc_spi_skip(host, timeout, sizeof(host->data->status), 0);
drivers/mmc/host/mmc_spi.c:263:	u8	*cp = host->data->status;
drivers/mmc/host/mmc_spi.c:264:	u8	*end = cp + host->t.len;
drivers/mmc/host/mmc_spi.c:287:		cp = host->data->status;
drivers/mmc/host/mmc_spi.c:322:			cp = host->data->status;
drivers/mmc/host/mmc_spi.c:374:			cp = host->data->status;
drivers/mmc/host/mmc_spi.c:397:				cp = host->data->status;
drivers/mmc/host/mmc_spi.c:415:		dev_dbg(&host->spi->dev, "bad response type %04x\n",
drivers/mmc/host/mmc_spi.c:423:		dev_dbg(&host->spi->dev, "%s: resp %04x %08x\n",
drivers/mmc/host/mmc_spi.c:447:	struct scratch		*data = host->data;
drivers/mmc/host/mmc_spi.c:524:	dev_dbg(&host->spi->dev, "  mmc_spi: CMD%d, resp %s\n",
drivers/mmc/host/mmc_spi.c:528:	spi_message_init(&host->m);
drivers/mmc/host/mmc_spi.c:530:	t = &host->t;
drivers/mmc/host/mmc_spi.c:533:	t->tx_dma = t->rx_dma = host->data_dma;
drivers/mmc/host/mmc_spi.c:536:	spi_message_add_tail(t, &host->m);
drivers/mmc/host/mmc_spi.c:538:	if (host->dma_dev) {
drivers/mmc/host/mmc_spi.c:539:		host->m.is_dma_mapped = 1;
drivers/mmc/host/mmc_spi.c:540:		dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:541:				host->data_dma, sizeof(*host->data),
drivers/mmc/host/mmc_spi.c:544:	status = spi_sync(host->spi, &host->m);
drivers/mmc/host/mmc_spi.c:546:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:547:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:548:				host->data_dma, sizeof(*host->data),
drivers/mmc/host/mmc_spi.c:551:		dev_dbg(&host->spi->dev, "  ... write returned %d\n", status);
drivers/mmc/host/mmc_spi.c:578:	struct scratch		*scratch = host->data;
drivers/mmc/host/mmc_spi.c:579:	dma_addr_t		dma = host->data_dma;
drivers/mmc/host/mmc_spi.c:581:	spi_message_init(&host->m);
drivers/mmc/host/mmc_spi.c:583:		host->m.is_dma_mapped = 1;
drivers/mmc/host/mmc_spi.c:589:		t = &host->token;
drivers/mmc/host/mmc_spi.c:599:		spi_message_add_tail(t, &host->m);
drivers/mmc/host/mmc_spi.c:605:	t = &host->t;
drivers/mmc/host/mmc_spi.c:607:	t->tx_buf = host->ones;
drivers/mmc/host/mmc_spi.c:608:	t->tx_dma = host->ones_dma;
drivers/mmc/host/mmc_spi.c:610:	spi_message_add_tail(t, &host->m);
drivers/mmc/host/mmc_spi.c:612:	t = &host->crc;
drivers/mmc/host/mmc_spi.c:621:		t->tx_buf = host->ones;
drivers/mmc/host/mmc_spi.c:622:		t->tx_dma = host->ones_dma;
drivers/mmc/host/mmc_spi.c:627:	spi_message_add_tail(t, &host->m);
drivers/mmc/host/mmc_spi.c:644:		t = &host->early_status;
drivers/mmc/host/mmc_spi.c:649:		t->tx_buf = host->ones;
drivers/mmc/host/mmc_spi.c:650:		t->tx_dma = host->ones_dma;
drivers/mmc/host/mmc_spi.c:655:		spi_message_add_tail(t, &host->m);
drivers/mmc/host/mmc_spi.c:675:	struct spi_device	*spi = host->spi;
drivers/mmc/host/mmc_spi.c:677:	struct scratch		*scratch = host->data;
drivers/mmc/host/mmc_spi.c:680:	if (host->mmc->use_spi_crc)
drivers/mmc/host/mmc_spi.c:683:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:684:		dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:685:				host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:688:	status = spi_sync(spi, &host->m);
drivers/mmc/host/mmc_spi.c:695:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:696:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:697:				host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:751:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:785:	struct spi_device	*spi = host->spi;
drivers/mmc/host/mmc_spi.c:787:	struct scratch		*scratch = host->data;
drivers/mmc/host/mmc_spi.c:816:	if (host->dma_dev) {
drivers/mmc/host/mmc_spi.c:817:		dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:818:				host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:820:		dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:825:	status = spi_sync(spi, &host->m);
drivers/mmc/host/mmc_spi.c:827:	if (host->dma_dev) {
drivers/mmc/host/mmc_spi.c:828:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:829:				host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:831:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:857:	if (host->mmc->use_spi_crc) {
drivers/mmc/host/mmc_spi.c:870:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:885:	struct spi_device	*spi = host->spi;
drivers/mmc/host/mmc_spi.c:886:	struct device		*dma_dev = host->dma_dev;
drivers/mmc/host/mmc_spi.c:900:	t = &host->t;
drivers/mmc/host/mmc_spi.c:949:			dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:994:		struct scratch	*scratch = host->data;
drivers/mmc/host/mmc_spi.c:1005:		INIT_LIST_HEAD(&host->m.transfers);
drivers/mmc/host/mmc_spi.c:1006:		list_add(&host->early_status.transfer_list,
drivers/mmc/host/mmc_spi.c:1007:				&host->m.transfers);
drivers/mmc/host/mmc_spi.c:1012:		host->early_status.tx_buf = host->early_status.rx_buf;
drivers/mmc/host/mmc_spi.c:1013:		host->early_status.tx_dma = host->early_status.rx_dma;
drivers/mmc/host/mmc_spi.c:1014:		host->early_status.len = statlen;
drivers/mmc/host/mmc_spi.c:1016:		if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:1017:			dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:1018:					host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:1021:		tmp = spi_sync(spi, &host->m);
drivers/mmc/host/mmc_spi.c:1023:		if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:1024:			dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:1025:					host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:1067:			dev_dbg(&host->spi->dev, "bogus command\n");
drivers/mmc/host/mmc_spi.c:1074:			dev_dbg(&host->spi->dev, "bogus STOP command\n");
drivers/mmc/host/mmc_spi.c:1081:			mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mmc_spi.c:1097:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mmc_spi.c:1130:	host->spi->mode |= SPI_CS_HIGH;
drivers/mmc/host/mmc_spi.c:1131:	if (spi_setup(host->spi) != 0) {
drivers/mmc/host/mmc_spi.c:1133:		dev_warn(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:1135:		host->spi->mode &= ~SPI_CS_HIGH;
drivers/mmc/host/mmc_spi.c:1139:		host->spi->mode &= ~SPI_CS_HIGH;
drivers/mmc/host/mmc_spi.c:1140:		if (spi_setup(host->spi) != 0) {
drivers/mmc/host/mmc_spi.c:1142:			dev_err(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:1162:	if (host->power_mode != ios->power_mode) {
drivers/mmc/host/mmc_spi.c:1165:		canpower = host->pdata && host->pdata->setpower;
drivers/mmc/host/mmc_spi.c:1167:		dev_dbg(&host->spi->dev, "mmc_spi: power %s (%d)%s\n",
drivers/mmc/host/mmc_spi.c:1179:				host->pdata->setpower(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:1182:					msleep(host->powerup_msecs);
drivers/mmc/host/mmc_spi.c:1203:			host->spi->mode &= ~(SPI_CPOL|SPI_CPHA);
drivers/mmc/host/mmc_spi.c:1204:			mres = spi_setup(host->spi);
drivers/mmc/host/mmc_spi.c:1206:				dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:1209:			if (spi_write(host->spi, &nullbyte, 1) < 0)
drivers/mmc/host/mmc_spi.c:1210:				dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:1224:				host->spi->mode |= (SPI_CPOL|SPI_CPHA);
drivers/mmc/host/mmc_spi.c:1225:				mres = spi_setup(host->spi);
drivers/mmc/host/mmc_spi.c:1227:					dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:1233:		host->power_mode = ios->power_mode;
drivers/mmc/host/mmc_spi.c:1236:	if (host->spi->max_speed_hz != ios->clock && ios->clock != 0) {
drivers/mmc/host/mmc_spi.c:1239:		host->spi->max_speed_hz = ios->clock;
drivers/mmc/host/mmc_spi.c:1240:		status = spi_setup(host->spi);
drivers/mmc/host/mmc_spi.c:1241:		dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:1243:			host->spi->max_speed_hz, status);
drivers/mmc/host/mmc_spi.c:1251:	if (host->pdata && host->pdata->get_ro)
drivers/mmc/host/mmc_spi.c:1252:		return !!host->pdata->get_ro(mmc->parent);
drivers/mmc/host/mmc_spi.c:1264:	if (host->pdata && host->pdata->get_cd)
drivers/mmc/host/mmc_spi.c:1265:		return !!host->pdata->get_cd(mmc->parent);
drivers/mmc/host/mmc_spi.c:1287:	u16 delay_msec = max(host->pdata->detect_delay, (u16)100);
drivers/mmc/host/mmc_spi.c:1404:	host->mmc = mmc;
drivers/mmc/host/mmc_spi.c:1405:	host->spi = spi;
drivers/mmc/host/mmc_spi.c:1407:	host->ones = ones;
drivers/mmc/host/mmc_spi.c:1412:	host->pdata = mmc_spi_get_pdata(spi);
drivers/mmc/host/mmc_spi.c:1413:	if (host->pdata)
drivers/mmc/host/mmc_spi.c:1414:		mmc->ocr_avail = host->pdata->ocr_mask;
drivers/mmc/host/mmc_spi.c:1419:	if (host->pdata && host->pdata->setpower) {
drivers/mmc/host/mmc_spi.c:1420:		host->powerup_msecs = host->pdata->powerup_msecs;
drivers/mmc/host/mmc_spi.c:1421:		if (!host->powerup_msecs || host->powerup_msecs > 250)
drivers/mmc/host/mmc_spi.c:1422:			host->powerup_msecs = 250;
drivers/mmc/host/mmc_spi.c:1428:	host->data = kmalloc(sizeof(*host->data), GFP_KERNEL);
drivers/mmc/host/mmc_spi.c:1429:	if (!host->data)
drivers/mmc/host/mmc_spi.c:1435:		host->dma_dev = dev;
drivers/mmc/host/mmc_spi.c:1436:		host->ones_dma = dma_map_single(dev, ones,
drivers/mmc/host/mmc_spi.c:1438:		host->data_dma = dma_map_single(dev, host->data,
drivers/mmc/host/mmc_spi.c:1439:				sizeof(*host->data), DMA_BIDIRECTIONAL);
drivers/mmc/host/mmc_spi.c:1443:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:1444:				host->data_dma, sizeof(*host->data),
drivers/mmc/host/mmc_spi.c:1449:	spi_message_init(&host->readback);
drivers/mmc/host/mmc_spi.c:1450:	host->readback.is_dma_mapped = (host->dma_dev != NULL);
drivers/mmc/host/mmc_spi.c:1452:	spi_message_add_tail(&host->status, &host->readback);
drivers/mmc/host/mmc_spi.c:1453:	host->status.tx_buf = host->ones;
drivers/mmc/host/mmc_spi.c:1454:	host->status.tx_dma = host->ones_dma;
drivers/mmc/host/mmc_spi.c:1455:	host->status.rx_buf = &host->data->status;
drivers/mmc/host/mmc_spi.c:1456:	host->status.rx_dma = host->data_dma + offsetof(struct scratch, status);
drivers/mmc/host/mmc_spi.c:1457:	host->status.cs_change = 1;
drivers/mmc/host/mmc_spi.c:1460:	if (host->pdata && host->pdata->init) {
drivers/mmc/host/mmc_spi.c:1461:		status = host->pdata->init(&spi->dev, mmc_spi_detect_irq, mmc);
drivers/mmc/host/mmc_spi.c:1467:	if (host->pdata)
drivers/mmc/host/mmc_spi.c:1468:		mmc->caps |= host->pdata->caps;
drivers/mmc/host/mmc_spi.c:1476:			host->dma_dev ? "" : ", no DMA",
drivers/mmc/host/mmc_spi.c:1477:			(host->pdata && host->pdata->get_ro)
drivers/mmc/host/mmc_spi.c:1479:			(host->pdata && host->pdata->setpower)
drivers/mmc/host/mmc_spi.c:1488:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:1489:		dma_unmap_single(host->dma_dev, host->data_dma,
drivers/mmc/host/mmc_spi.c:1490:				sizeof(*host->data), DMA_BIDIRECTIONAL);
drivers/mmc/host/mmc_spi.c:1491:	kfree(host->data);
drivers/mmc/host/mmc_spi.c:1513:		if (host->pdata && host->pdata->exit)
drivers/mmc/host/mmc_spi.c:1514:			host->pdata->exit(&spi->dev, mmc);
drivers/mmc/host/mmc_spi.c:1518:		if (host->dma_dev) {
drivers/mmc/host/mmc_spi.c:1519:			dma_unmap_single(host->dma_dev, host->ones_dma,
drivers/mmc/host/mmc_spi.c:1521:			dma_unmap_single(host->dma_dev, host->data_dma,
drivers/mmc/host/mmc_spi.c:1522:				sizeof(*host->data), DMA_BIDIRECTIONAL);
drivers/mmc/host/mmc_spi.c:1525:		kfree(host->data);
drivers/mmc/host/mmc_spi.c:1526:		kfree(host->ones);
drivers/mmc/host/sdhci-pci.c:201:	scratch = readb(host->ioaddr + 0xC0);
drivers/mmc/host/sdhci-pci.c:208:	writeb(scratch, host->ioaddr + 0xC0);
drivers/mmc/host/sdhci-pci.c:216:		version = readl(slot->host->ioaddr + SDHCI_HOST_VERSION);
drivers/mmc/host/sdhci-pci.c:226:			slot->host->quirks |= SDHCI_QUIRK_BROKEN_ADMA;
drivers/mmc/host/sdhci-pci.c:320:	u8 board_rev = readb(slot->host->ioaddr + SYSKT_BOARD_REV);
drivers/mmc/host/sdhci-pci.c:321:	u8  chip_rev = readb(slot->host->ioaddr + SYSKT_CHIP_REV);
drivers/mmc/host/sdhci-pci.c:327:		slot->host->quirks |= SDHCI_QUIRK_FORCE_DMA;
drivers/mmc/host/sdhci-pci.c:329:	writeb(SYSKT_POWER_330, slot->host->ioaddr + SYSKT_POWER_DATA);
drivers/mmc/host/sdhci-pci.c:330:	writeb(SYSKT_POWER_START, slot->host->ioaddr + SYSKT_POWER_CMD);
drivers/mmc/host/sdhci-pci.c:334:		ps = readw(slot->host->ioaddr + SYSKT_POWER_STATUS);
drivers/mmc/host/sdhci-pci.c:342:		writeb(0, slot->host->ioaddr + SYSKT_POWER_CMD);
drivers/mmc/host/sdhci-pci.c:474:		(host->flags & SDHCI_USE_SDMA)) {
drivers/mmc/host/sdhci-pci.c:524:		pm_flags |= slot->host->mmc->pm_flags;
drivers/mmc/host/sdhci-pci.c:640:	host->hw_name = "PCI";
drivers/mmc/host/sdhci-pci.c:641:	host->ops = &sdhci_pci_ops;
drivers/mmc/host/sdhci-pci.c:642:	host->quirks = chip->quirks;
drivers/mmc/host/sdhci-pci.c:644:	host->irq = pdev->irq;
drivers/mmc/host/sdhci-pci.c:646:	ret = pci_request_region(pdev, bar, mmc_hostname(host->mmc));
drivers/mmc/host/sdhci-pci.c:653:	host->ioaddr = pci_ioremap_bar(pdev, bar);
drivers/mmc/host/sdhci-pci.c:654:	if (!host->ioaddr) {
drivers/mmc/host/sdhci-pci.c:665:	host->mmc->pm_caps = MMC_PM_KEEP_POWER | MMC_PM_WAKE_SDIO_IRQ;
drivers/mmc/host/sdhci-pci.c:678:	iounmap(host->ioaddr);
drivers/mmc/host/sdhci-pci.c:695:	scratch = readl(slot->host->ioaddr + SDHCI_INT_STATUS);
drivers/mmc/host/omap_hsmmc.c:131:#define mmc_slot(host)		(host->pdata->slots[host->slot_id])
drivers/mmc/host/omap_hsmmc.c:251:		ret = mmc_regulator_set_ocr(host->vcc, vdd);
drivers/mmc/host/omap_hsmmc.c:253:		ret = mmc_regulator_set_ocr(host->vcc, 0);
drivers/mmc/host/omap_hsmmc.c:272:	if (!host->vcc)
drivers/mmc/host/omap_hsmmc.c:292:		ret = mmc_regulator_set_ocr(host->vcc, vdd);
drivers/mmc/host/omap_hsmmc.c:294:		if (ret == 0 && host->vcc_aux) {
drivers/mmc/host/omap_hsmmc.c:295:			ret = regulator_enable(host->vcc_aux);
drivers/mmc/host/omap_hsmmc.c:297:				ret = mmc_regulator_set_ocr(host->vcc, 0);
drivers/mmc/host/omap_hsmmc.c:300:		if (host->vcc_aux)
drivers/mmc/host/omap_hsmmc.c:301:			ret = regulator_disable(host->vcc_aux);
drivers/mmc/host/omap_hsmmc.c:303:			ret = mmc_regulator_set_ocr(host->vcc, 0);
drivers/mmc/host/omap_hsmmc.c:319:	return regulator_set_mode(host->vcc, mode);
drivers/mmc/host/omap_hsmmc.c:333:	if (!host->vcc)
drivers/mmc/host/omap_hsmmc.c:338:	if (!host->vcc_aux)
drivers/mmc/host/omap_hsmmc.c:339:		return regulator_set_mode(host->vcc, mode);
drivers/mmc/host/omap_hsmmc.c:344:			err = mmc_regulator_set_ocr(host->vcc, 0);
drivers/mmc/host/omap_hsmmc.c:346:			err = mmc_regulator_set_ocr(host->vcc, vdd);
drivers/mmc/host/omap_hsmmc.c:348:		err = regulator_set_mode(host->vcc, mode);
drivers/mmc/host/omap_hsmmc.c:353:		return regulator_set_mode(host->vcc_aux, mode);
drivers/mmc/host/omap_hsmmc.c:356:		return regulator_disable(host->vcc_aux);
drivers/mmc/host/omap_hsmmc.c:358:		return regulator_enable(host->vcc_aux);
drivers/mmc/host/omap_hsmmc.c:366:	switch (host->id) {
drivers/mmc/host/omap_hsmmc.c:379:		pr_err("MMC%d configuration not supported!\n", host->id);
drivers/mmc/host/omap_hsmmc.c:383:	reg = regulator_get(host->dev, "vmmc");
drivers/mmc/host/omap_hsmmc.c:385:		dev_dbg(host->dev, "vmmc regulator missing\n");
drivers/mmc/host/omap_hsmmc.c:391:		if (host->id == OMAP_MMC1_DEVID) {
drivers/mmc/host/omap_hsmmc.c:396:		host->vcc = reg;
drivers/mmc/host/omap_hsmmc.c:400:		reg = regulator_get(host->dev, "vmmc_aux");
drivers/mmc/host/omap_hsmmc.c:401:		host->vcc_aux = IS_ERR(reg) ? NULL : reg;
drivers/mmc/host/omap_hsmmc.c:411:		if (regulator_is_enabled(host->vcc) > 0) {
drivers/mmc/host/omap_hsmmc.c:412:			regulator_enable(host->vcc);
drivers/mmc/host/omap_hsmmc.c:413:			regulator_disable(host->vcc);
drivers/mmc/host/omap_hsmmc.c:415:		if (host->vcc_aux) {
drivers/mmc/host/omap_hsmmc.c:433:	regulator_put(host->vcc);
drivers/mmc/host/omap_hsmmc.c:434:	regulator_put(host->vcc_aux);
drivers/mmc/host/omap_hsmmc.c:520:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:521:		OMAP_HSMMC_READ(host->base, SYSCTL) & ~CEN);
drivers/mmc/host/omap_hsmmc.c:522:	if ((OMAP_HSMMC_READ(host->base, SYSCTL) & CEN) != 0x0)
drivers/mmc/host/omap_hsmmc.c:523:		dev_dbg(mmc_dev(host->mmc), "MMC Clock is not stoped\n");
drivers/mmc/host/omap_hsmmc.c:530:	if (host->use_dma)
drivers/mmc/host/omap_hsmmc.c:535:	OMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);
drivers/mmc/host/omap_hsmmc.c:536:	OMAP_HSMMC_WRITE(host->base, ISE, irq_mask);
drivers/mmc/host/omap_hsmmc.c:537:	OMAP_HSMMC_WRITE(host->base, IE, irq_mask);
drivers/mmc/host/omap_hsmmc.c:542:	OMAP_HSMMC_WRITE(host->base, ISE, 0);
drivers/mmc/host/omap_hsmmc.c:543:	OMAP_HSMMC_WRITE(host->base, IE, 0);
drivers/mmc/host/omap_hsmmc.c:544:	OMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);
drivers/mmc/host/omap_hsmmc.c:555:	struct mmc_ios *ios = &host->mmc->ios;
drivers/mmc/host/omap_hsmmc.c:556:	struct omap_mmc_platform_data *pdata = host->pdata;
drivers/mmc/host/omap_hsmmc.c:563:		context_loss = pdata->get_context_loss_count(host->dev);
drivers/mmc/host/omap_hsmmc.c:568:	dev_dbg(mmc_dev(host->mmc), "context was %slost\n",
drivers/mmc/host/omap_hsmmc.c:569:		context_loss == host->context_loss ? "not " : "");
drivers/mmc/host/omap_hsmmc.c:570:	if (host->context_loss == context_loss)
drivers/mmc/host/omap_hsmmc.c:575:	while ((OMAP_HSMMC_READ(host->base, SYSSTATUS) & RESETDONE) != RESETDONE
drivers/mmc/host/omap_hsmmc.c:580:	OMAP_HSMMC_WRITE(host->base, SYSCONFIG, SOFTRESET);
drivers/mmc/host/omap_hsmmc.c:582:	while ((OMAP_HSMMC_READ(host->base, SYSSTATUS) & RESETDONE) != RESETDONE
drivers/mmc/host/omap_hsmmc.c:586:	OMAP_HSMMC_WRITE(host->base, SYSCONFIG,
drivers/mmc/host/omap_hsmmc.c:587:			OMAP_HSMMC_READ(host->base, SYSCONFIG) | AUTOIDLE);
drivers/mmc/host/omap_hsmmc.c:589:	if (host->id == OMAP_MMC1_DEVID) {
drivers/mmc/host/omap_hsmmc.c:590:		if (host->power_mode != MMC_POWER_OFF &&
drivers/mmc/host/omap_hsmmc.c:601:	OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:602:			OMAP_HSMMC_READ(host->base, HCTL) | hctl);
drivers/mmc/host/omap_hsmmc.c:604:	OMAP_HSMMC_WRITE(host->base, CAPA,
drivers/mmc/host/omap_hsmmc.c:605:			OMAP_HSMMC_READ(host->base, CAPA) | capa);
drivers/mmc/host/omap_hsmmc.c:607:	OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:608:			OMAP_HSMMC_READ(host->base, HCTL) | SDBP);
drivers/mmc/host/omap_hsmmc.c:611:	while ((OMAP_HSMMC_READ(host->base, HCTL) & SDBP) != SDBP
drivers/mmc/host/omap_hsmmc.c:618:	if (host->power_mode == MMC_POWER_OFF)
drivers/mmc/host/omap_hsmmc.c:621:	con = OMAP_HSMMC_READ(host->base, CON);
drivers/mmc/host/omap_hsmmc.c:624:		OMAP_HSMMC_WRITE(host->base, CON, con | DW8);
drivers/mmc/host/omap_hsmmc.c:627:		OMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);
drivers/mmc/host/omap_hsmmc.c:628:		OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:629:			OMAP_HSMMC_READ(host->base, HCTL) | FOUR_BIT);
drivers/mmc/host/omap_hsmmc.c:632:		OMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);
drivers/mmc/host/omap_hsmmc.c:633:		OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:634:			OMAP_HSMMC_READ(host->base, HCTL) & ~FOUR_BIT);
drivers/mmc/host/omap_hsmmc.c:650:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:651:		OMAP_HSMMC_READ(host->base, SYSCTL) & ~CEN);
drivers/mmc/host/omap_hsmmc.c:652:	OMAP_HSMMC_WRITE(host->base, SYSCTL, (dsor << 6) | (DTO << 16));
drivers/mmc/host/omap_hsmmc.c:653:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:654:		OMAP_HSMMC_READ(host->base, SYSCTL) | ICE);
drivers/mmc/host/omap_hsmmc.c:657:	while ((OMAP_HSMMC_READ(host->base, SYSCTL) & ICS) != ICS
drivers/mmc/host/omap_hsmmc.c:661:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:662:		OMAP_HSMMC_READ(host->base, SYSCTL) | CEN);
drivers/mmc/host/omap_hsmmc.c:664:	con = OMAP_HSMMC_READ(host->base, CON);
drivers/mmc/host/omap_hsmmc.c:666:		OMAP_HSMMC_WRITE(host->base, CON, con | OD);
drivers/mmc/host/omap_hsmmc.c:668:		OMAP_HSMMC_WRITE(host->base, CON, con & ~OD);
drivers/mmc/host/omap_hsmmc.c:670:	host->context_loss = context_loss;
drivers/mmc/host/omap_hsmmc.c:672:	dev_dbg(mmc_dev(host->mmc), "context is restored\n");
drivers/mmc/host/omap_hsmmc.c:681:	struct omap_mmc_platform_data *pdata = host->pdata;
drivers/mmc/host/omap_hsmmc.c:685:		context_loss = pdata->get_context_loss_count(host->dev);
drivers/mmc/host/omap_hsmmc.c:688:		host->context_loss = context_loss;
drivers/mmc/host/omap_hsmmc.c:714:	if (host->protect_card)
drivers/mmc/host/omap_hsmmc.c:717:	disable_irq(host->irq);
drivers/mmc/host/omap_hsmmc.c:719:	OMAP_HSMMC_WRITE(host->base, IE, INT_EN_MASK);
drivers/mmc/host/omap_hsmmc.c:720:	OMAP_HSMMC_WRITE(host->base, CON,
drivers/mmc/host/omap_hsmmc.c:721:		OMAP_HSMMC_READ(host->base, CON) | INIT_STREAM);
drivers/mmc/host/omap_hsmmc.c:722:	OMAP_HSMMC_WRITE(host->base, CMD, INIT_STREAM_CMD);
drivers/mmc/host/omap_hsmmc.c:726:		reg = OMAP_HSMMC_READ(host->base, STAT) & CC;
drivers/mmc/host/omap_hsmmc.c:728:	OMAP_HSMMC_WRITE(host->base, CON,
drivers/mmc/host/omap_hsmmc.c:729:		OMAP_HSMMC_READ(host->base, CON) & ~INIT_STREAM);
drivers/mmc/host/omap_hsmmc.c:731:	OMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);
drivers/mmc/host/omap_hsmmc.c:732:	OMAP_HSMMC_READ(host->base, STAT);
drivers/mmc/host/omap_hsmmc.c:734:	enable_irq(host->irq);
drivers/mmc/host/omap_hsmmc.c:743:		r = mmc_slot(host).get_cover_state(host->dev, host->slot_id);
drivers/mmc/host/omap_hsmmc.c:781:	dev_dbg(mmc_dev(host->mmc), "%s: CMD%d, argument 0x%08x\n",
drivers/mmc/host/omap_hsmmc.c:782:		mmc_hostname(host->mmc), cmd->opcode, cmd->arg);
drivers/mmc/host/omap_hsmmc.c:783:	host->cmd = cmd;
drivers/mmc/host/omap_hsmmc.c:787:	host->response_busy = 0;
drivers/mmc/host/omap_hsmmc.c:793:			host->response_busy = 1;
drivers/mmc/host/omap_hsmmc.c:803:	if (cmd == host->mrq->stop)
drivers/mmc/host/omap_hsmmc.c:816:	if (host->use_dma)
drivers/mmc/host/omap_hsmmc.c:819:	host->req_in_progress = 1;
drivers/mmc/host/omap_hsmmc.c:821:	OMAP_HSMMC_WRITE(host->base, ARG, cmd->arg);
drivers/mmc/host/omap_hsmmc.c:822:	OMAP_HSMMC_WRITE(host->base, CMD, cmdreg);
drivers/mmc/host/omap_hsmmc.c:838:	spin_lock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:839:	host->req_in_progress = 0;
drivers/mmc/host/omap_hsmmc.c:840:	dma_ch = host->dma_ch;
drivers/mmc/host/omap_hsmmc.c:841:	spin_unlock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:845:	if (mrq->data && host->use_dma && dma_ch != -1)
drivers/mmc/host/omap_hsmmc.c:847:	host->mrq = NULL;
drivers/mmc/host/omap_hsmmc.c:848:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/omap_hsmmc.c:858:		struct mmc_request *mrq = host->mrq;
drivers/mmc/host/omap_hsmmc.c:861:		if (host->cmd && host->cmd->opcode == 6 &&
drivers/mmc/host/omap_hsmmc.c:862:		    host->response_busy) {
drivers/mmc/host/omap_hsmmc.c:863:			host->response_busy = 0;
drivers/mmc/host/omap_hsmmc.c:871:	host->data = NULL;
drivers/mmc/host/omap_hsmmc.c:891:	host->cmd = NULL;
drivers/mmc/host/omap_hsmmc.c:896:			cmd->resp[3] = OMAP_HSMMC_READ(host->base, RSP10);
drivers/mmc/host/omap_hsmmc.c:897:			cmd->resp[2] = OMAP_HSMMC_READ(host->base, RSP32);
drivers/mmc/host/omap_hsmmc.c:898:			cmd->resp[1] = OMAP_HSMMC_READ(host->base, RSP54);
drivers/mmc/host/omap_hsmmc.c:899:			cmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP76);
drivers/mmc/host/omap_hsmmc.c:902:			cmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP10);
drivers/mmc/host/omap_hsmmc.c:905:	if ((host->data == NULL && !host->response_busy) || cmd->error)
drivers/mmc/host/omap_hsmmc.c:916:	host->data->error = errno;
drivers/mmc/host/omap_hsmmc.c:918:	spin_lock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:919:	dma_ch = host->dma_ch;
drivers/mmc/host/omap_hsmmc.c:920:	host->dma_ch = -1;
drivers/mmc/host/omap_hsmmc.c:921:	spin_unlock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:923:	if (host->use_dma && dma_ch != -1) {
drivers/mmc/host/omap_hsmmc.c:924:		dma_unmap_sg(mmc_dev(host->mmc), host->data->sg, host->dma_len,
drivers/mmc/host/omap_hsmmc.c:925:			omap_hsmmc_get_dma_dir(host, host->data));
drivers/mmc/host/omap_hsmmc.c:928:	host->data = NULL;
drivers/mmc/host/omap_hsmmc.c:957:	dev_dbg(mmc_dev(host->mmc), "%s\n", res);
drivers/mmc/host/omap_hsmmc.c:975:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:976:			 OMAP_HSMMC_READ(host->base, SYSCTL) | bit);
drivers/mmc/host/omap_hsmmc.c:978:	while ((OMAP_HSMMC_READ(host->base, SYSCTL) & bit) &&
drivers/mmc/host/omap_hsmmc.c:982:	if (OMAP_HSMMC_READ(host->base, SYSCTL) & bit)
drivers/mmc/host/omap_hsmmc.c:983:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:993:	if (!host->req_in_progress) {
drivers/mmc/host/omap_hsmmc.c:995:			OMAP_HSMMC_WRITE(host->base, STAT, status);
drivers/mmc/host/omap_hsmmc.c:997:			status = OMAP_HSMMC_READ(host->base, STAT);
drivers/mmc/host/omap_hsmmc.c:1002:	data = host->data;
drivers/mmc/host/omap_hsmmc.c:1003:	dev_dbg(mmc_dev(host->mmc), "IRQ Status is %x\n", status);
drivers/mmc/host/omap_hsmmc.c:1011:			if (host->cmd) {
drivers/mmc/host/omap_hsmmc.c:1015:					host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/omap_hsmmc.c:1017:					host->cmd->error = -EILSEQ;
drivers/mmc/host/omap_hsmmc.c:1021:			if (host->data || host->response_busy) {
drivers/mmc/host/omap_hsmmc.c:1022:				if (host->data)
drivers/mmc/host/omap_hsmmc.c:1025:				host->response_busy = 0;
drivers/mmc/host/omap_hsmmc.c:1031:			if (host->data || host->response_busy) {
drivers/mmc/host/omap_hsmmc.c:1035:				if (host->data)
drivers/mmc/host/omap_hsmmc.c:1038:					host->mrq->cmd->error = err;
drivers/mmc/host/omap_hsmmc.c:1039:				host->response_busy = 0;
drivers/mmc/host/omap_hsmmc.c:1045:			dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:1046:				"Ignoring card err CMD%d\n", host->cmd->opcode);
drivers/mmc/host/omap_hsmmc.c:1047:			if (host->cmd)
drivers/mmc/host/omap_hsmmc.c:1049:			if (host->data)
drivers/mmc/host/omap_hsmmc.c:1054:	OMAP_HSMMC_WRITE(host->base, STAT, status);
drivers/mmc/host/omap_hsmmc.c:1056:	if (end_cmd || ((status & CC) && host->cmd))
drivers/mmc/host/omap_hsmmc.c:1057:		omap_hsmmc_cmd_done(host, host->cmd);
drivers/mmc/host/omap_hsmmc.c:1058:	if ((end_trans || (status & TC)) && host->mrq)
drivers/mmc/host/omap_hsmmc.c:1070:	status = OMAP_HSMMC_READ(host->base, STAT);
drivers/mmc/host/omap_hsmmc.c:1074:		status = OMAP_HSMMC_READ(host->base, STAT);
drivers/mmc/host/omap_hsmmc.c:1084:	OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:1085:			 OMAP_HSMMC_READ(host->base, HCTL) | SDBP);
drivers/mmc/host/omap_hsmmc.c:1087:		if (OMAP_HSMMC_READ(host->base, HCTL) & SDBP)
drivers/mmc/host/omap_hsmmc.c:1106:	clk_disable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1107:	clk_disable(host->iclk);
drivers/mmc/host/omap_hsmmc.c:1108:	if (host->got_dbclk)
drivers/mmc/host/omap_hsmmc.c:1109:		clk_disable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:1112:	ret = mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
drivers/mmc/host/omap_hsmmc.c:1116:		ret = mmc_slot(host).set_power(host->dev, host->slot_id, 1,
drivers/mmc/host/omap_hsmmc.c:1118:	clk_enable(host->iclk);
drivers/mmc/host/omap_hsmmc.c:1119:	clk_enable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1120:	if (host->got_dbclk)
drivers/mmc/host/omap_hsmmc.c:1121:		clk_enable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:1126:	OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:1127:		OMAP_HSMMC_READ(host->base, HCTL) & SDVSCLR);
drivers/mmc/host/omap_hsmmc.c:1128:	reg_val = OMAP_HSMMC_READ(host->base, HCTL);
drivers/mmc/host/omap_hsmmc.c:1150:	OMAP_HSMMC_WRITE(host->base, HCTL, reg_val);
drivers/mmc/host/omap_hsmmc.c:1155:	dev_dbg(mmc_dev(host->mmc), "Unable to switch operating voltage\n");
drivers/mmc/host/omap_hsmmc.c:1165:	host->reqs_blocked = 0;
drivers/mmc/host/omap_hsmmc.c:1166:	if (mmc_slot(host).get_cover_state(host->dev, host->slot_id)) {
drivers/mmc/host/omap_hsmmc.c:1167:		if (host->protect_card) {
drivers/mmc/host/omap_hsmmc.c:1170:					 mmc_hostname(host->mmc));
drivers/mmc/host/omap_hsmmc.c:1171:			host->protect_card = 0;
drivers/mmc/host/omap_hsmmc.c:1174:		if (!host->protect_card) {
drivers/mmc/host/omap_hsmmc.c:1177:					 mmc_hostname(host->mmc));
drivers/mmc/host/omap_hsmmc.c:1178:			host->protect_card = 1;
drivers/mmc/host/omap_hsmmc.c:1193:	if (host->suspended)
drivers/mmc/host/omap_hsmmc.c:1196:	sysfs_notify(&host->mmc->class_dev.kobj, NULL, "cover_switch");
drivers/mmc/host/omap_hsmmc.c:1199:		carddetect = slot->card_detect(host->dev, host->slot_id);
drivers/mmc/host/omap_hsmmc.c:1206:		mmc_detect_change(host->mmc, (HZ * 200) / 1000);
drivers/mmc/host/omap_hsmmc.c:1208:		mmc_detect_change(host->mmc, (HZ * 50) / 1000);
drivers/mmc/host/omap_hsmmc.c:1218:	if (host->suspended)
drivers/mmc/host/omap_hsmmc.c:1220:	schedule_work(&host->mmc_carddetect_work);
drivers/mmc/host/omap_hsmmc.c:1231:		sync_dev = host->dma_line_tx;
drivers/mmc/host/omap_hsmmc.c:1233:		sync_dev = host->dma_line_rx;
drivers/mmc/host/omap_hsmmc.c:1243:	dma_ch = host->dma_ch;
drivers/mmc/host/omap_hsmmc.c:1246:			(host->mapbase + OMAP_HSMMC_DATA), 0, 0);
drivers/mmc/host/omap_hsmmc.c:1251:			(host->mapbase + OMAP_HSMMC_DATA), 0, 0);
drivers/mmc/host/omap_hsmmc.c:1256:	blksz = host->data->blksz;
drivers/mmc/host/omap_hsmmc.c:1273:	struct mmc_data *data = host->mrq->data;
drivers/mmc/host/omap_hsmmc.c:1277:		dev_dbg(mmc_dev(host->mmc), "MISALIGNED_ADRS_ERR\n");
drivers/mmc/host/omap_hsmmc.c:1279:	spin_lock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:1280:	if (host->dma_ch < 0) {
drivers/mmc/host/omap_hsmmc.c:1281:		spin_unlock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:1285:	host->dma_sg_idx++;
drivers/mmc/host/omap_hsmmc.c:1286:	if (host->dma_sg_idx < host->dma_len) {
drivers/mmc/host/omap_hsmmc.c:1289:					   data->sg + host->dma_sg_idx);
drivers/mmc/host/omap_hsmmc.c:1290:		spin_unlock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:1294:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_len,
drivers/mmc/host/omap_hsmmc.c:1297:	req_in_progress = host->req_in_progress;
drivers/mmc/host/omap_hsmmc.c:1298:	dma_ch = host->dma_ch;
drivers/mmc/host/omap_hsmmc.c:1299:	host->dma_ch = -1;
drivers/mmc/host/omap_hsmmc.c:1300:	spin_unlock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:1306:		struct mmc_request *mrq = host->mrq;
drivers/mmc/host/omap_hsmmc.c:1308:		host->mrq = NULL;
drivers/mmc/host/omap_hsmmc.c:1309:		mmc_request_done(host->mmc, mrq);
drivers/mmc/host/omap_hsmmc.c:1336:	BUG_ON(host->dma_ch != -1);
drivers/mmc/host/omap_hsmmc.c:1341:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:1343:			mmc_hostname(host->mmc), ret);
drivers/mmc/host/omap_hsmmc.c:1347:	host->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/omap_hsmmc.c:1349:	host->dma_ch = dma_ch;
drivers/mmc/host/omap_hsmmc.c:1350:	host->dma_sg_idx = 0;
drivers/mmc/host/omap_hsmmc.c:1364:	reg = OMAP_HSMMC_READ(host->base, SYSCTL);
drivers/mmc/host/omap_hsmmc.c:1369:	cycle_ns = 1000000000 / (clk_get_rate(host->fclk) / clkd);
drivers/mmc/host/omap_hsmmc.c:1391:	OMAP_HSMMC_WRITE(host->base, SYSCTL, reg);
drivers/mmc/host/omap_hsmmc.c:1401:	host->data = req->data;
drivers/mmc/host/omap_hsmmc.c:1404:		OMAP_HSMMC_WRITE(host->base, BLK, 0);
drivers/mmc/host/omap_hsmmc.c:1414:	OMAP_HSMMC_WRITE(host->base, BLK, (req->data->blksz)
drivers/mmc/host/omap_hsmmc.c:1418:	if (host->use_dma) {
drivers/mmc/host/omap_hsmmc.c:1421:			dev_dbg(mmc_dev(host->mmc), "MMC start dma failure\n");
drivers/mmc/host/omap_hsmmc.c:1436:	BUG_ON(host->req_in_progress);
drivers/mmc/host/omap_hsmmc.c:1437:	BUG_ON(host->dma_ch != -1);
drivers/mmc/host/omap_hsmmc.c:1438:	if (host->protect_card) {
drivers/mmc/host/omap_hsmmc.c:1439:		if (host->reqs_blocked < 3) {
drivers/mmc/host/omap_hsmmc.c:1447:			host->reqs_blocked += 1;
drivers/mmc/host/omap_hsmmc.c:1455:	} else if (host->reqs_blocked)
drivers/mmc/host/omap_hsmmc.c:1456:		host->reqs_blocked = 0;
drivers/mmc/host/omap_hsmmc.c:1457:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/omap_hsmmc.c:1458:	host->mrq = req;
drivers/mmc/host/omap_hsmmc.c:1464:		host->mrq = NULL;
drivers/mmc/host/omap_hsmmc.c:1482:	mmc_host_enable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1484:	if (ios->power_mode != host->power_mode) {
drivers/mmc/host/omap_hsmmc.c:1487:			mmc_slot(host).set_power(host->dev, host->slot_id,
drivers/mmc/host/omap_hsmmc.c:1489:			host->vdd = 0;
drivers/mmc/host/omap_hsmmc.c:1492:			mmc_slot(host).set_power(host->dev, host->slot_id,
drivers/mmc/host/omap_hsmmc.c:1494:			host->vdd = ios->vdd;
drivers/mmc/host/omap_hsmmc.c:1500:		host->power_mode = ios->power_mode;
drivers/mmc/host/omap_hsmmc.c:1505:	con = OMAP_HSMMC_READ(host->base, CON);
drivers/mmc/host/omap_hsmmc.c:1508:		OMAP_HSMMC_WRITE(host->base, CON, con | DW8);
drivers/mmc/host/omap_hsmmc.c:1511:		OMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);
drivers/mmc/host/omap_hsmmc.c:1512:		OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:1513:			OMAP_HSMMC_READ(host->base, HCTL) | FOUR_BIT);
drivers/mmc/host/omap_hsmmc.c:1516:		OMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);
drivers/mmc/host/omap_hsmmc.c:1517:		OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:1518:			OMAP_HSMMC_READ(host->base, HCTL) & ~FOUR_BIT);
drivers/mmc/host/omap_hsmmc.c:1522:	if (host->id == OMAP_MMC1_DEVID) {
drivers/mmc/host/omap_hsmmc.c:1526:		if ((OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET) &&
drivers/mmc/host/omap_hsmmc.c:1535:				dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:1552:	regval = OMAP_HSMMC_READ(host->base, SYSCTL);
drivers/mmc/host/omap_hsmmc.c:1555:	OMAP_HSMMC_WRITE(host->base, SYSCTL, regval);
drivers/mmc/host/omap_hsmmc.c:1556:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:1557:		OMAP_HSMMC_READ(host->base, SYSCTL) | ICE);
drivers/mmc/host/omap_hsmmc.c:1561:	while ((OMAP_HSMMC_READ(host->base, SYSCTL) & ICS) != ICS
drivers/mmc/host/omap_hsmmc.c:1565:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:1566:		OMAP_HSMMC_READ(host->base, SYSCTL) | CEN);
drivers/mmc/host/omap_hsmmc.c:1571:	con = OMAP_HSMMC_READ(host->base, CON);
drivers/mmc/host/omap_hsmmc.c:1573:		OMAP_HSMMC_WRITE(host->base, CON, con | OD);
drivers/mmc/host/omap_hsmmc.c:1575:		OMAP_HSMMC_WRITE(host->base, CON, con & ~OD);
drivers/mmc/host/omap_hsmmc.c:1577:	if (host->power_mode == MMC_POWER_OFF)
drivers/mmc/host/omap_hsmmc.c:1578:		mmc_host_disable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1580:		mmc_host_lazy_disable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1589:	return mmc_slot(host).card_detect(host->dev, host->slot_id);
drivers/mmc/host/omap_hsmmc.c:1598:	return mmc_slot(host).get_ro(host->dev, 0);
drivers/mmc/host/omap_hsmmc.c:1606:	if (host->id == OMAP_MMC1_DEVID) {
drivers/mmc/host/omap_hsmmc.c:1614:	value = OMAP_HSMMC_READ(host->base, HCTL) & ~SDVS_MASK;
drivers/mmc/host/omap_hsmmc.c:1615:	OMAP_HSMMC_WRITE(host->base, HCTL, value | hctl);
drivers/mmc/host/omap_hsmmc.c:1617:	value = OMAP_HSMMC_READ(host->base, CAPA);
drivers/mmc/host/omap_hsmmc.c:1618:	OMAP_HSMMC_WRITE(host->base, CAPA, value | capa);
drivers/mmc/host/omap_hsmmc.c:1621:	value = OMAP_HSMMC_READ(host->base, SYSCONFIG);
drivers/mmc/host/omap_hsmmc.c:1622:	OMAP_HSMMC_WRITE(host->base, SYSCONFIG, value | AUTOIDLE);
drivers/mmc/host/omap_hsmmc.c:1650:	clk_disable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1651:	host->dpm_state = DISABLED;
drivers/mmc/host/omap_hsmmc.c:1653:	dev_dbg(mmc_dev(host->mmc), "ENABLED -> DISABLED\n");
drivers/mmc/host/omap_hsmmc.c:1655:	if (host->power_mode == MMC_POWER_OFF)
drivers/mmc/host/omap_hsmmc.c:1666:	if (!mmc_try_claim_host(host->mmc))
drivers/mmc/host/omap_hsmmc.c:1669:	clk_enable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1671:	if (mmc_card_can_sleep(host->mmc)) {
drivers/mmc/host/omap_hsmmc.c:1672:		err = mmc_card_sleep(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1674:			clk_disable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1675:			mmc_release_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1683:		mmc_slot(host).set_sleep(host->dev, host->slot_id, 1, 0,
drivers/mmc/host/omap_hsmmc.c:1686:	clk_disable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1687:	host->dpm_state = new_state;
drivers/mmc/host/omap_hsmmc.c:1689:	mmc_release_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1691:	dev_dbg(mmc_dev(host->mmc), "DISABLED -> %s\n",
drivers/mmc/host/omap_hsmmc.c:1692:		host->dpm_state == CARDSLEEP ? "CARDSLEEP" : "REGSLEEP");
drivers/mmc/host/omap_hsmmc.c:1697:	if ((host->mmc->caps & MMC_CAP_NONREMOVABLE) ||
drivers/mmc/host/omap_hsmmc.c:1700:	     mmc_slot(host).get_cover_state(host->dev, host->slot_id)))
drivers/mmc/host/omap_hsmmc.c:1709:	if (!mmc_try_claim_host(host->mmc))
drivers/mmc/host/omap_hsmmc.c:1715:	if (!((host->mmc->caps & MMC_CAP_NONREMOVABLE) ||
drivers/mmc/host/omap_hsmmc.c:1718:	       mmc_slot(host).get_cover_state(host->dev, host->slot_id)))) {
drivers/mmc/host/omap_hsmmc.c:1719:		mmc_release_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1723:	mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
drivers/mmc/host/omap_hsmmc.c:1724:	host->vdd = 0;
drivers/mmc/host/omap_hsmmc.c:1725:	host->power_mode = MMC_POWER_OFF;
drivers/mmc/host/omap_hsmmc.c:1727:	dev_dbg(mmc_dev(host->mmc), "%s -> OFF\n",
drivers/mmc/host/omap_hsmmc.c:1728:		host->dpm_state == CARDSLEEP ? "CARDSLEEP" : "REGSLEEP");
drivers/mmc/host/omap_hsmmc.c:1730:	host->dpm_state = OFF;
drivers/mmc/host/omap_hsmmc.c:1732:	mmc_release_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1742:	err = clk_enable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1747:	host->dpm_state = ENABLED;
drivers/mmc/host/omap_hsmmc.c:1749:	dev_dbg(mmc_dev(host->mmc), "DISABLED -> ENABLED\n");
drivers/mmc/host/omap_hsmmc.c:1757:	if (!mmc_try_claim_host(host->mmc))
drivers/mmc/host/omap_hsmmc.c:1760:	clk_enable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1763:		mmc_slot(host).set_sleep(host->dev, host->slot_id, 0,
drivers/mmc/host/omap_hsmmc.c:1764:			 host->vdd, host->dpm_state == CARDSLEEP);
drivers/mmc/host/omap_hsmmc.c:1765:	if (mmc_card_can_sleep(host->mmc))
drivers/mmc/host/omap_hsmmc.c:1766:		mmc_card_awake(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1768:	dev_dbg(mmc_dev(host->mmc), "%s -> ENABLED\n",
drivers/mmc/host/omap_hsmmc.c:1769:		host->dpm_state == CARDSLEEP ? "CARDSLEEP" : "REGSLEEP");
drivers/mmc/host/omap_hsmmc.c:1771:	host->dpm_state = ENABLED;
drivers/mmc/host/omap_hsmmc.c:1773:	mmc_release_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1781:	clk_enable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1785:	mmc_power_restore_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:1787:	host->dpm_state = ENABLED;
drivers/mmc/host/omap_hsmmc.c:1789:	dev_dbg(mmc_dev(host->mmc), "OFF -> ENABLED\n");
drivers/mmc/host/omap_hsmmc.c:1801:	switch (host->dpm_state) {
drivers/mmc/host/omap_hsmmc.c:1810:		dev_dbg(mmc_dev(host->mmc), "UNKNOWN state\n");
drivers/mmc/host/omap_hsmmc.c:1822:	switch (host->dpm_state) {
drivers/mmc/host/omap_hsmmc.c:1837:		dev_dbg(mmc_dev(host->mmc), "UNKNOWN state\n");
drivers/mmc/host/omap_hsmmc.c:1847:	err = clk_enable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1850:	dev_dbg(mmc_dev(host->mmc), "mmc_fclk: enabled\n");
drivers/mmc/host/omap_hsmmc.c:1860:	clk_disable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:1861:	dev_dbg(mmc_dev(host->mmc), "mmc_fclk: disabled\n");
drivers/mmc/host/omap_hsmmc.c:1893:	if (host->pdata->get_context_loss_count)
drivers/mmc/host/omap_hsmmc.c:1894:		context_loss = host->pdata->get_context_loss_count(host->dev);
drivers/mmc/host/omap_hsmmc.c:1903:			host->dpm_state, mmc->nesting_cnt,
drivers/mmc/host/omap_hsmmc.c:1904:			host->context_loss, context_loss);
drivers/mmc/host/omap_hsmmc.c:1906:	if (host->suspended || host->dpm_state == OFF) {
drivers/mmc/host/omap_hsmmc.c:1911:	if (clk_enable(host->fclk) != 0) {
drivers/mmc/host/omap_hsmmc.c:1917:			OMAP_HSMMC_READ(host->base, SYSCONFIG));
drivers/mmc/host/omap_hsmmc.c:1919:			OMAP_HSMMC_READ(host->base, CON));
drivers/mmc/host/omap_hsmmc.c:1921:			OMAP_HSMMC_READ(host->base, HCTL));
drivers/mmc/host/omap_hsmmc.c:1923:			OMAP_HSMMC_READ(host->base, SYSCTL));
drivers/mmc/host/omap_hsmmc.c:1925:			OMAP_HSMMC_READ(host->base, IE));
drivers/mmc/host/omap_hsmmc.c:1927:			OMAP_HSMMC_READ(host->base, ISE));
drivers/mmc/host/omap_hsmmc.c:1929:			OMAP_HSMMC_READ(host->base, CAPA));
drivers/mmc/host/omap_hsmmc.c:1931:	clk_disable(host->fclk);
drivers/mmc/host/omap_hsmmc.c:2002:	host->mmc	= mmc;
drivers/mmc/host/omap_hsmmc.c:2003:	host->pdata	= pdata;
drivers/mmc/host/omap_hsmmc.c:2004:	host->dev	= &pdev->dev;
drivers/mmc/host/omap_hsmmc.c:2005:	host->use_dma	= 1;
drivers/mmc/host/omap_hsmmc.c:2006:	host->dev->dma_mask = &pdata->dma_mask;
drivers/mmc/host/omap_hsmmc.c:2007:	host->dma_ch	= -1;
drivers/mmc/host/omap_hsmmc.c:2008:	host->irq	= irq;
drivers/mmc/host/omap_hsmmc.c:2009:	host->id	= pdev->id;
drivers/mmc/host/omap_hsmmc.c:2010:	host->slot_id	= 0;
drivers/mmc/host/omap_hsmmc.c:2011:	host->mapbase	= res->start;
drivers/mmc/host/omap_hsmmc.c:2012:	host->base	= ioremap(host->mapbase, SZ_4K);
drivers/mmc/host/omap_hsmmc.c:2013:	host->power_mode = MMC_POWER_OFF;
drivers/mmc/host/omap_hsmmc.c:2016:	INIT_WORK(&host->mmc_carddetect_work, omap_hsmmc_detect);
drivers/mmc/host/omap_hsmmc.c:2033:	spin_lock_init(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:2035:	host->iclk = clk_get(&pdev->dev, "ick");
drivers/mmc/host/omap_hsmmc.c:2036:	if (IS_ERR(host->iclk)) {
drivers/mmc/host/omap_hsmmc.c:2037:		ret = PTR_ERR(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2038:		host->iclk = NULL;
drivers/mmc/host/omap_hsmmc.c:2041:	host->fclk = clk_get(&pdev->dev, "fck");
drivers/mmc/host/omap_hsmmc.c:2042:	if (IS_ERR(host->fclk)) {
drivers/mmc/host/omap_hsmmc.c:2043:		ret = PTR_ERR(host->fclk);
drivers/mmc/host/omap_hsmmc.c:2044:		host->fclk = NULL;
drivers/mmc/host/omap_hsmmc.c:2045:		clk_put(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2054:	host->dpm_state = DISABLED;
drivers/mmc/host/omap_hsmmc.c:2056:	if (mmc_host_enable(host->mmc) != 0) {
drivers/mmc/host/omap_hsmmc.c:2057:		clk_put(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2058:		clk_put(host->fclk);
drivers/mmc/host/omap_hsmmc.c:2062:	if (clk_enable(host->iclk) != 0) {
drivers/mmc/host/omap_hsmmc.c:2063:		mmc_host_disable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2064:		clk_put(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2065:		clk_put(host->fclk);
drivers/mmc/host/omap_hsmmc.c:2070:		host->dbclk = clk_get(&pdev->dev, "mmchsdb_fck");
drivers/mmc/host/omap_hsmmc.c:2074:		if (IS_ERR(host->dbclk))
drivers/mmc/host/omap_hsmmc.c:2075:			dev_warn(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:2078:			host->got_dbclk = 1;
drivers/mmc/host/omap_hsmmc.c:2080:		if (host->got_dbclk)
drivers/mmc/host/omap_hsmmc.c:2081:			if (clk_enable(host->dbclk) != 0)
drivers/mmc/host/omap_hsmmc.c:2082:				dev_dbg(mmc_dev(host->mmc), "Enabling debounce"
drivers/mmc/host/omap_hsmmc.c:2110:	switch (host->id) {
drivers/mmc/host/omap_hsmmc.c:2112:		host->dma_line_tx = OMAP24XX_DMA_MMC1_TX;
drivers/mmc/host/omap_hsmmc.c:2113:		host->dma_line_rx = OMAP24XX_DMA_MMC1_RX;
drivers/mmc/host/omap_hsmmc.c:2116:		host->dma_line_tx = OMAP24XX_DMA_MMC2_TX;
drivers/mmc/host/omap_hsmmc.c:2117:		host->dma_line_rx = OMAP24XX_DMA_MMC2_RX;
drivers/mmc/host/omap_hsmmc.c:2120:		host->dma_line_tx = OMAP34XX_DMA_MMC3_TX;
drivers/mmc/host/omap_hsmmc.c:2121:		host->dma_line_rx = OMAP34XX_DMA_MMC3_RX;
drivers/mmc/host/omap_hsmmc.c:2124:		host->dma_line_tx = OMAP44XX_DMA_MMC4_TX;
drivers/mmc/host/omap_hsmmc.c:2125:		host->dma_line_rx = OMAP44XX_DMA_MMC4_RX;
drivers/mmc/host/omap_hsmmc.c:2128:		host->dma_line_tx = OMAP44XX_DMA_MMC5_TX;
drivers/mmc/host/omap_hsmmc.c:2129:		host->dma_line_rx = OMAP44XX_DMA_MMC5_RX;
drivers/mmc/host/omap_hsmmc.c:2132:		dev_err(mmc_dev(host->mmc), "Invalid MMC id\n");
drivers/mmc/host/omap_hsmmc.c:2137:	ret = request_irq(host->irq, omap_hsmmc_irq, IRQF_DISABLED,
drivers/mmc/host/omap_hsmmc.c:2140:		dev_dbg(mmc_dev(host->mmc), "Unable to grab HSMMC IRQ\n");
drivers/mmc/host/omap_hsmmc.c:2146:			dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:2156:		host->use_reg = 1;
drivers/mmc/host/omap_hsmmc.c:2169:			dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:2177:	mmc_host_lazy_disable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2203:	if (host->use_reg)
drivers/mmc/host/omap_hsmmc.c:2206:	if (host->pdata->cleanup)
drivers/mmc/host/omap_hsmmc.c:2207:		host->pdata->cleanup(&pdev->dev);
drivers/mmc/host/omap_hsmmc.c:2209:	free_irq(host->irq, host);
drivers/mmc/host/omap_hsmmc.c:2211:	mmc_host_disable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2212:	clk_disable(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2213:	clk_put(host->fclk);
drivers/mmc/host/omap_hsmmc.c:2214:	clk_put(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2215:	if (host->got_dbclk) {
drivers/mmc/host/omap_hsmmc.c:2216:		clk_disable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:2217:		clk_put(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:2220:	iounmap(host->base);
drivers/mmc/host/omap_hsmmc.c:2236:		mmc_host_enable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2237:		mmc_remove_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2238:		if (host->use_reg)
drivers/mmc/host/omap_hsmmc.c:2240:		if (host->pdata->cleanup)
drivers/mmc/host/omap_hsmmc.c:2241:			host->pdata->cleanup(&pdev->dev);
drivers/mmc/host/omap_hsmmc.c:2242:		free_irq(host->irq, host);
drivers/mmc/host/omap_hsmmc.c:2247:		mmc_host_disable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2248:		clk_disable(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2249:		clk_put(host->fclk);
drivers/mmc/host/omap_hsmmc.c:2250:		clk_put(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2251:		if (host->got_dbclk) {
drivers/mmc/host/omap_hsmmc.c:2252:			clk_disable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:2253:			clk_put(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:2256:		mmc_free_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2257:		iounmap(host->base);
drivers/mmc/host/omap_hsmmc.c:2277:	if (host && host->suspended)
drivers/mmc/host/omap_hsmmc.c:2281:		host->suspended = 1;
drivers/mmc/host/omap_hsmmc.c:2282:		if (host->pdata->suspend) {
drivers/mmc/host/omap_hsmmc.c:2283:			ret = host->pdata->suspend(&pdev->dev,
drivers/mmc/host/omap_hsmmc.c:2284:							host->slot_id);
drivers/mmc/host/omap_hsmmc.c:2286:				dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:2289:				host->suspended = 0;
drivers/mmc/host/omap_hsmmc.c:2293:		cancel_work_sync(&host->mmc_carddetect_work);
drivers/mmc/host/omap_hsmmc.c:2294:		mmc_host_enable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2295:		ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2298:			OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:2299:				OMAP_HSMMC_READ(host->base, HCTL) & ~SDBP);
drivers/mmc/host/omap_hsmmc.c:2300:			mmc_host_disable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2301:			clk_disable(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2302:			if (host->got_dbclk)
drivers/mmc/host/omap_hsmmc.c:2303:				clk_disable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:2305:			host->suspended = 0;
drivers/mmc/host/omap_hsmmc.c:2306:			if (host->pdata->resume) {
drivers/mmc/host/omap_hsmmc.c:2307:				ret = host->pdata->resume(&pdev->dev,
drivers/mmc/host/omap_hsmmc.c:2308:							  host->slot_id);
drivers/mmc/host/omap_hsmmc.c:2310:					dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:2313:			mmc_host_disable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2327:	if (host && !host->suspended)
drivers/mmc/host/omap_hsmmc.c:2331:		ret = clk_enable(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2335:		if (mmc_host_enable(host->mmc) != 0) {
drivers/mmc/host/omap_hsmmc.c:2336:			clk_disable(host->iclk);
drivers/mmc/host/omap_hsmmc.c:2340:		if (host->got_dbclk)
drivers/mmc/host/omap_hsmmc.c:2341:			clk_enable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:2345:		if (host->pdata->resume) {
drivers/mmc/host/omap_hsmmc.c:2346:			ret = host->pdata->resume(&pdev->dev, host->slot_id);
drivers/mmc/host/omap_hsmmc.c:2348:				dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:2355:		ret = mmc_resume_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2357:			host->suspended = 0;
drivers/mmc/host/omap_hsmmc.c:2359:		mmc_host_lazy_disable(host->mmc);
drivers/mmc/host/omap_hsmmc.c:2365:	dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/sdhci-of-core.c:37:	return in_be32(host->ioaddr + reg);
drivers/mmc/host/sdhci-of-core.c:42:	return in_be16(host->ioaddr + (reg ^ 0x2));
drivers/mmc/host/sdhci-of-core.c:47:	return in_8(host->ioaddr + (reg ^ 0x3));
drivers/mmc/host/sdhci-of-core.c:52:	out_be32(host->ioaddr + reg, val);
drivers/mmc/host/sdhci-of-core.c:67:		of_host->xfer_mode_shadow = val;
drivers/mmc/host/sdhci-of-core.c:70:		sdhci_be32bs_writel(host, val << 16 | of_host->xfer_mode_shadow,
drivers/mmc/host/sdhci-of-core.c:74:	clrsetbits_be32(host->ioaddr + base, 0xffff << shift, val << shift);
drivers/mmc/host/sdhci-of-core.c:82:	clrsetbits_be32(host->ioaddr + base , 0xff << shift, val << shift);
drivers/mmc/host/sdhci-of-core.c:92:	return mmc_suspend_host(host->mmc);
drivers/mmc/host/sdhci-of-core.c:99:	return mmc_resume_host(host->mmc);
drivers/mmc/host/sdhci-of-core.c:139:	host->ioaddr = of_iomap(np, 0);
drivers/mmc/host/sdhci-of-core.c:140:	if (!host->ioaddr) {
drivers/mmc/host/sdhci-of-core.c:145:	host->irq = irq_of_parse_and_map(np, 0);
drivers/mmc/host/sdhci-of-core.c:146:	if (!host->irq) {
drivers/mmc/host/sdhci-of-core.c:151:	host->hw_name = dev_name(&ofdev->dev);
drivers/mmc/host/sdhci-of-core.c:153:		host->quirks = sdhci_of_data->quirks;
drivers/mmc/host/sdhci-of-core.c:154:		host->ops = &sdhci_of_data->ops;
drivers/mmc/host/sdhci-of-core.c:158:		host->quirks |= SDHCI_QUIRK_FORCE_1_BIT_DATA;
drivers/mmc/host/sdhci-of-core.c:161:		host->quirks |= SDHCI_QUIRK_INVERTED_WRITE_PROTECT;
drivers/mmc/host/sdhci-of-core.c:165:		of_host->clock = *clk;
drivers/mmc/host/sdhci-of-core.c:174:	irq_dispose_mapping(host->irq);
drivers/mmc/host/sdhci-of-core.c:176:	iounmap(host->ioaddr);
drivers/mmc/host/sdhci-of-core.c:188:	irq_dispose_mapping(host->irq);
drivers/mmc/host/sdhci-of-core.c:189:	iounmap(host->ioaddr);
drivers/mmc/host/msm_sdcc.c:68:	WARN_ON(!host->clks_on);
drivers/mmc/host/msm_sdcc.c:70:	BUG_ON(host->curr.mrq);
drivers/mmc/host/msm_sdcc.c:73:		mod_timer(&host->busclk_timer, jiffies + BUSCLK_TIMEOUT);
drivers/mmc/host/msm_sdcc.c:75:		del_timer_sync(&host->busclk_timer);
drivers/mmc/host/msm_sdcc.c:79:		if (host->clks_on) {
drivers/mmc/host/msm_sdcc.c:80:			clk_disable(host->clk);
drivers/mmc/host/msm_sdcc.c:81:			clk_disable(host->pclk);
drivers/mmc/host/msm_sdcc.c:82:			host->clks_on = 0;
drivers/mmc/host/msm_sdcc.c:92:	del_timer_sync(&host->busclk_timer);
drivers/mmc/host/msm_sdcc.c:94:	if (!host->clks_on) {
drivers/mmc/host/msm_sdcc.c:95:		rc = clk_enable(host->pclk);
drivers/mmc/host/msm_sdcc.c:98:		rc = clk_enable(host->clk);
drivers/mmc/host/msm_sdcc.c:100:			clk_disable(host->pclk);
drivers/mmc/host/msm_sdcc.c:104:		       (host->clk_rate ? host->clk_rate : msmsdcc_fmin)));
drivers/mmc/host/msm_sdcc.c:105:		host->clks_on = 1;
drivers/mmc/host/msm_sdcc.c:113:	return readl(host->base + reg);
drivers/mmc/host/msm_sdcc.c:119:	writel(data, host->base + reg);
drivers/mmc/host/msm_sdcc.c:122:	       (host->clk_rate ? host->clk_rate : msmsdcc_fmin)));
drivers/mmc/host/msm_sdcc.c:132:	BUG_ON(host->curr.data);
drivers/mmc/host/msm_sdcc.c:134:	host->curr.mrq = NULL;
drivers/mmc/host/msm_sdcc.c:135:	host->curr.cmd = NULL;
drivers/mmc/host/msm_sdcc.c:138:		mrq->data->bytes_xfered = host->curr.data_xfered;
drivers/mmc/host/msm_sdcc.c:149:	spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:150:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/msm_sdcc.c:151:	spin_lock(&host->lock);
drivers/mmc/host/msm_sdcc.c:157:	host->curr.data = NULL;
drivers/mmc/host/msm_sdcc.c:158:	host->curr.got_dataend = host->curr.got_datablkend = 0;
drivers/mmc/host/msm_sdcc.c:163:	switch (host->pdev_id) {
drivers/mmc/host/msm_sdcc.c:188:	msmsdcc_writel(host, host->cmd_timeout, MMCIDATATIMER);
drivers/mmc/host/msm_sdcc.c:189:	msmsdcc_writel(host, (unsigned int)host->curr.xfer_size,
drivers/mmc/host/msm_sdcc.c:191:	msmsdcc_writel(host, host->cmd_pio_irqmask, MMCIMASK1);
drivers/mmc/host/msm_sdcc.c:192:	msmsdcc_writel(host, host->cmd_datactrl, MMCIDATACTRL);
drivers/mmc/host/msm_sdcc.c:194:	if (host->cmd_cmd) {
drivers/mmc/host/msm_sdcc.c:196:					   (u32) host->cmd_cmd->arg,
drivers/mmc/host/msm_sdcc.c:197:					   (u32) host->cmd_c);
drivers/mmc/host/msm_sdcc.c:199:	host->dma.active = 1;
drivers/mmc/host/msm_sdcc.c:213:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:214:	host->dma.active = 0;
drivers/mmc/host/msm_sdcc.c:216:	mrq = host->curr.mrq;
drivers/mmc/host/msm_sdcc.c:226:		host->curr.data_xfered = host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:231:			       mmc_hostname(host->mmc), result);
drivers/mmc/host/msm_sdcc.c:234:			       mmc_hostname(host->mmc), result);
drivers/mmc/host/msm_sdcc.c:242:	dma_unmap_sg(mmc_dev(host->mmc), host->dma.sg, host->dma.num_ents,
drivers/mmc/host/msm_sdcc.c:243:		     host->dma.dir);
drivers/mmc/host/msm_sdcc.c:245:	if (host->curr.user_pages) {
drivers/mmc/host/msm_sdcc.c:246:		struct scatterlist *sg = host->dma.sg;
drivers/mmc/host/msm_sdcc.c:249:		for (i = 0; i < host->dma.num_ents; i++)
drivers/mmc/host/msm_sdcc.c:253:	host->dma.sg = NULL;
drivers/mmc/host/msm_sdcc.c:254:	host->dma.busy = 0;
drivers/mmc/host/msm_sdcc.c:256:	if ((host->curr.got_dataend && host->curr.got_datablkend)
drivers/mmc/host/msm_sdcc.c:266:			host->curr.data_xfered = host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:268:			host->curr.mrq = NULL;
drivers/mmc/host/msm_sdcc.c:269:			host->curr.cmd = NULL;
drivers/mmc/host/msm_sdcc.c:270:			mrq->data->bytes_xfered = host->curr.data_xfered;
drivers/mmc/host/msm_sdcc.c:272:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:276:			mmc_request_done(host->mmc, mrq);
drivers/mmc/host/msm_sdcc.c:283:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:289:	if (host->dma.channel == -1)
drivers/mmc/host/msm_sdcc.c:313:	host->dma.sg = data->sg;
drivers/mmc/host/msm_sdcc.c:314:	host->dma.num_ents = data->sg_len;
drivers/mmc/host/msm_sdcc.c:316:       BUG_ON(host->dma.num_ents > NR_SG); /* Prevent memory corruption */
drivers/mmc/host/msm_sdcc.c:318:	nc = host->dma.nc;
drivers/mmc/host/msm_sdcc.c:320:	switch (host->pdev_id) {
drivers/mmc/host/msm_sdcc.c:334:		host->dma.sg = NULL;
drivers/mmc/host/msm_sdcc.c:335:		host->dma.num_ents = 0;
drivers/mmc/host/msm_sdcc.c:340:		host->dma.dir = DMA_FROM_DEVICE;
drivers/mmc/host/msm_sdcc.c:342:		host->dma.dir = DMA_TO_DEVICE;
drivers/mmc/host/msm_sdcc.c:344:	host->curr.user_pages = 0;
drivers/mmc/host/msm_sdcc.c:347:	for (i = 0; i < host->dma.num_ents; i++) {
drivers/mmc/host/msm_sdcc.c:351:	sg->dma_address = page_to_dma(mmc_dev(host->mmc), sg_page(sg))
drivers/mmc/host/msm_sdcc.c:354:	if (i == (host->dma.num_ents - 1))
drivers/mmc/host/msm_sdcc.c:386:	BUG_ON(host->dma.cmd_busaddr & 0x07);
drivers/mmc/host/msm_sdcc.c:388:	nc->cmdptr = (host->dma.cmd_busaddr >> 3) | CMD_PTR_LP;
drivers/mmc/host/msm_sdcc.c:389:	host->dma.hdr.cmdptr = DMOV_CMD_PTR_LIST |
drivers/mmc/host/msm_sdcc.c:390:			       DMOV_CMD_ADDR(host->dma.cmdptr_busaddr);
drivers/mmc/host/msm_sdcc.c:391:	host->dma.hdr.complete_func = msmsdcc_dma_complete_func;
drivers/mmc/host/msm_sdcc.c:393:	n = dma_map_sg(mmc_dev(host->mmc), host->dma.sg,
drivers/mmc/host/msm_sdcc.c:394:			host->dma.num_ents, host->dma.dir);
drivers/mmc/host/msm_sdcc.c:397:	if (n != host->dma.num_ents) {
drivers/mmc/host/msm_sdcc.c:399:			mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:400:		host->dma.sg = NULL;
drivers/mmc/host/msm_sdcc.c:401:		host->dma.num_ents = 0;
drivers/mmc/host/msm_sdcc.c:444:	if (host->curr.cmd != NULL) {
drivers/mmc/host/msm_sdcc.c:446:			mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:448:	host->curr.cmd = cmd;
drivers/mmc/host/msm_sdcc.c:459:	host->curr.data = data;
drivers/mmc/host/msm_sdcc.c:460:	host->curr.xfer_size = data->blksz * data->blocks;
drivers/mmc/host/msm_sdcc.c:461:	host->curr.xfer_remain = host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:462:	host->curr.data_xfered = 0;
drivers/mmc/host/msm_sdcc.c:463:	host->curr.got_dataend = 0;
drivers/mmc/host/msm_sdcc.c:464:	host->curr.got_datablkend = 0;
drivers/mmc/host/msm_sdcc.c:466:	memset(&host->pio, 0, sizeof(host->pio));
drivers/mmc/host/msm_sdcc.c:473:		host->pio.sg = data->sg;
drivers/mmc/host/msm_sdcc.c:474:		host->pio.sg_len = data->sg_len;
drivers/mmc/host/msm_sdcc.c:475:		host->pio.sg_off = 0;
drivers/mmc/host/msm_sdcc.c:479:			if (host->curr.xfer_remain < MCI_FIFOSIZE)
drivers/mmc/host/msm_sdcc.c:488:	clks = (unsigned long long)data->timeout_ns * host->clk_rate;
drivers/mmc/host/msm_sdcc.c:494:		host->cmd_timeout = timeout;
drivers/mmc/host/msm_sdcc.c:495:		host->cmd_pio_irqmask = pio_irqmask;
drivers/mmc/host/msm_sdcc.c:496:		host->cmd_datactrl = datactrl;
drivers/mmc/host/msm_sdcc.c:497:		host->cmd_cmd = cmd;
drivers/mmc/host/msm_sdcc.c:499:		host->dma.hdr.execute_func = msmsdcc_dma_exec_func;
drivers/mmc/host/msm_sdcc.c:500:		host->dma.hdr.data = (void *)host;
drivers/mmc/host/msm_sdcc.c:501:		host->dma.busy = 1;
drivers/mmc/host/msm_sdcc.c:505:			host->cmd_c = c;
drivers/mmc/host/msm_sdcc.c:507:		msm_dmov_enqueue_cmd(host->dma.channel, &host->dma.hdr);
drivers/mmc/host/msm_sdcc.c:511:		msmsdcc_writel(host, host->curr.xfer_size, MMCIDATALENGTH);
drivers/mmc/host/msm_sdcc.c:529:	host->stats.cmds++;
drivers/mmc/host/msm_sdcc.c:540:		pr_err("%s: Data CRC error\n", mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:547:		pr_err("%s: Data timeout\n", mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:550:		pr_err("%s: RX overrun\n", mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:553:		pr_err("%s: TX underrun\n", mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:557:		       mmc_hostname(host->mmc), status);
drivers/mmc/host/msm_sdcc.c:585:	void __iomem *base = host->base;
drivers/mmc/host/msm_sdcc.c:634:			if (host->curr.xfer_remain == 0 || !msmsdcc_piopoll)
drivers/mmc/host/msm_sdcc.c:647:		buffer = kmap_atomic(sg_page(host->pio.sg),
drivers/mmc/host/msm_sdcc.c:648:				     KM_BIO_SRC_IRQ) + host->pio.sg->offset;
drivers/mmc/host/msm_sdcc.c:649:		buffer += host->pio.sg_off;
drivers/mmc/host/msm_sdcc.c:650:		remain = host->pio.sg->length - host->pio.sg_off;
drivers/mmc/host/msm_sdcc.c:661:		host->pio.sg_off += len;
drivers/mmc/host/msm_sdcc.c:662:		host->curr.xfer_remain -= len;
drivers/mmc/host/msm_sdcc.c:663:		host->curr.data_xfered += len;
drivers/mmc/host/msm_sdcc.c:668:			if (status & MCI_RXACTIVE && host->curr.user_pages)
drivers/mmc/host/msm_sdcc.c:669:				flush_dcache_page(sg_page(host->pio.sg));
drivers/mmc/host/msm_sdcc.c:671:			if (!--host->pio.sg_len) {
drivers/mmc/host/msm_sdcc.c:672:				memset(&host->pio, 0, sizeof(host->pio));
drivers/mmc/host/msm_sdcc.c:677:			host->pio.sg++;
drivers/mmc/host/msm_sdcc.c:678:			host->pio.sg_off = 0;
drivers/mmc/host/msm_sdcc.c:684:	if (status & MCI_RXACTIVE && host->curr.xfer_remain < MCI_FIFOSIZE)
drivers/mmc/host/msm_sdcc.c:687:	if (!host->curr.xfer_remain)
drivers/mmc/host/msm_sdcc.c:695:	struct mmc_command *cmd = host->curr.cmd;
drivers/mmc/host/msm_sdcc.c:697:	host->curr.cmd = NULL;
drivers/mmc/host/msm_sdcc.c:707:		pr_err("%s: Command CRC error\n", mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:712:		if (host->curr.data && host->dma.sg)
drivers/mmc/host/msm_sdcc.c:713:			msm_dmov_stop_cmd(host->dma.channel,
drivers/mmc/host/msm_sdcc.c:714:					  &host->dma.hdr, 0);
drivers/mmc/host/msm_sdcc.c:715:		else if (host->curr.data) { /* Non DMA */
drivers/mmc/host/msm_sdcc.c:718:		} else /* host->data == NULL */
drivers/mmc/host/msm_sdcc.c:730:	struct mmc_data *data = host->curr.data;
drivers/mmc/host/msm_sdcc.c:733:	              MCI_CMDTIMEOUT) && host->curr.cmd) {
drivers/mmc/host/msm_sdcc.c:744:		host->curr.data_xfered = 0;
drivers/mmc/host/msm_sdcc.c:745:		if (host->dma.sg)
drivers/mmc/host/msm_sdcc.c:746:			msm_dmov_stop_cmd(host->dma.channel,
drivers/mmc/host/msm_sdcc.c:747:					  &host->dma.hdr, 0);
drivers/mmc/host/msm_sdcc.c:749:			if (host->curr.data)
drivers/mmc/host/msm_sdcc.c:759:	if (!host->curr.got_dataend && (status & MCI_DATAEND))
drivers/mmc/host/msm_sdcc.c:760:		host->curr.got_dataend = 1;
drivers/mmc/host/msm_sdcc.c:762:	if (!host->curr.got_datablkend && (status & MCI_DATABLOCKEND))
drivers/mmc/host/msm_sdcc.c:763:		host->curr.got_datablkend = 1;
drivers/mmc/host/msm_sdcc.c:768:	if (host->curr.got_dataend && host->curr.got_datablkend &&
drivers/mmc/host/msm_sdcc.c:769:	    !host->dma.busy) {
drivers/mmc/host/msm_sdcc.c:784:			host->curr.data_xfered = host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:797:	void __iomem		*base = host->base;
drivers/mmc/host/msm_sdcc.c:802:	spin_lock(&host->lock);
drivers/mmc/host/msm_sdcc.c:825:	spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:832:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:843:	WARN_ON(host->curr.mrq != NULL);
drivers/mmc/host/msm_sdcc.c:844:	WARN_ON(host->pwr == 0);
drivers/mmc/host/msm_sdcc.c:846:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:848:	host->stats.reqs++;
drivers/mmc/host/msm_sdcc.c:850:	if (host->eject) {
drivers/mmc/host/msm_sdcc.c:858:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:865:	host->curr.mrq = mrq;
drivers/mmc/host/msm_sdcc.c:873:	if (host->cmdpoll && !msmsdcc_spin_on_status(host,
drivers/mmc/host/msm_sdcc.c:881:		host->stats.cmdpoll_hits++;
drivers/mmc/host/msm_sdcc.c:883:		host->stats.cmdpoll_misses++;
drivers/mmc/host/msm_sdcc.c:885:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:896:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:901:		if (ios->clock != host->clk_rate) {
drivers/mmc/host/msm_sdcc.c:902:			rc = clk_set_rate(host->clk, ios->clock);
drivers/mmc/host/msm_sdcc.c:905:				       mmc_hostname(host->mmc), rc);
drivers/mmc/host/msm_sdcc.c:907:				host->clk_rate = ios->clock;
drivers/mmc/host/msm_sdcc.c:921:	if (host->plat->translate_vdd)
drivers/mmc/host/msm_sdcc.c:922:		pwr |= host->plat->translate_vdd(mmc_dev(mmc), ios->vdd);
drivers/mmc/host/msm_sdcc.c:940:	if (host->pwr != pwr) {
drivers/mmc/host/msm_sdcc.c:941:		host->pwr = pwr;
drivers/mmc/host/msm_sdcc.c:947:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:956:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:963:		host->saved_irq0mask = status;
drivers/mmc/host/msm_sdcc.c:966:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:981:	if (!host->plat->status) {
drivers/mmc/host/msm_sdcc.c:982:		mmc_detect_change(host->mmc, 0);
drivers/mmc/host/msm_sdcc.c:986:	status = host->plat->status(mmc_dev(host->mmc));
drivers/mmc/host/msm_sdcc.c:987:	host->eject = !status;
drivers/mmc/host/msm_sdcc.c:988:	if (status ^ host->oldstat) {
drivers/mmc/host/msm_sdcc.c:990:			mmc_hostname(host->mmc), host->oldstat, status);
drivers/mmc/host/msm_sdcc.c:992:			mmc_detect_change(host->mmc, (5 * HZ) / 2);
drivers/mmc/host/msm_sdcc.c:994:			mmc_detect_change(host->mmc, 0);
drivers/mmc/host/msm_sdcc.c:997:	host->oldstat = status;
drivers/mmc/host/msm_sdcc.c:1000:	if (host->timer.function)
drivers/mmc/host/msm_sdcc.c:1001:		mod_timer(&host->timer, jiffies + HZ);
drivers/mmc/host/msm_sdcc.c:1019:	printk(KERN_DEBUG "%s: card_present %d\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:1029:	if (host->clks_on)
drivers/mmc/host/msm_sdcc.c:1036:	memset(&host->dma, 0, sizeof(struct msmsdcc_dma_data));
drivers/mmc/host/msm_sdcc.c:1037:	host->dma.host = host;
drivers/mmc/host/msm_sdcc.c:1038:	host->dma.channel = -1;
drivers/mmc/host/msm_sdcc.c:1040:	if (!host->dmares)
drivers/mmc/host/msm_sdcc.c:1043:	host->dma.nc = dma_alloc_coherent(NULL,
drivers/mmc/host/msm_sdcc.c:1045:					  &host->dma.nc_busaddr,
drivers/mmc/host/msm_sdcc.c:1047:	if (host->dma.nc == NULL) {
drivers/mmc/host/msm_sdcc.c:1051:	memset(host->dma.nc, 0x00, sizeof(struct msmsdcc_nc_dmadata));
drivers/mmc/host/msm_sdcc.c:1052:	host->dma.cmd_busaddr = host->dma.nc_busaddr;
drivers/mmc/host/msm_sdcc.c:1053:	host->dma.cmdptr_busaddr = host->dma.nc_busaddr +
drivers/mmc/host/msm_sdcc.c:1055:	host->dma.channel = host->dmares->start;
drivers/mmc/host/msm_sdcc.c:1066:	struct mmc_host	*mmc = host->mmc;
drivers/mmc/host/msm_sdcc.c:1070:		if (host->stat_irq)
drivers/mmc/host/msm_sdcc.c:1071:			enable_irq(host->stat_irq);
drivers/mmc/host/msm_sdcc.c:1129:	host->pdev_id = pdev->id;
drivers/mmc/host/msm_sdcc.c:1130:	host->plat = plat;
drivers/mmc/host/msm_sdcc.c:1131:	host->mmc = mmc;
drivers/mmc/host/msm_sdcc.c:1132:	host->curr.cmd = NULL;
drivers/mmc/host/msm_sdcc.c:1134:	host->cmdpoll = 1;
drivers/mmc/host/msm_sdcc.c:1136:	host->base = ioremap(memres->start, PAGE_SIZE);
drivers/mmc/host/msm_sdcc.c:1137:	if (!host->base) {
drivers/mmc/host/msm_sdcc.c:1142:	host->cmd_irqres = cmd_irqres;
drivers/mmc/host/msm_sdcc.c:1143:	host->pio_irqres = pio_irqres;
drivers/mmc/host/msm_sdcc.c:1144:	host->memres = memres;
drivers/mmc/host/msm_sdcc.c:1145:	host->dmares = dmares;
drivers/mmc/host/msm_sdcc.c:1146:	spin_lock_init(&host->lock);
drivers/mmc/host/msm_sdcc.c:1163:	host->pclk = clk_get(&pdev->dev, "sdc_pclk");
drivers/mmc/host/msm_sdcc.c:1164:	if (IS_ERR(host->pclk)) {
drivers/mmc/host/msm_sdcc.c:1165:		ret = PTR_ERR(host->pclk);
drivers/mmc/host/msm_sdcc.c:1169:	host->clk = clk_get(&pdev->dev, "sdc_clk");
drivers/mmc/host/msm_sdcc.c:1170:	if (IS_ERR(host->clk)) {
drivers/mmc/host/msm_sdcc.c:1171:		ret = PTR_ERR(host->clk);
drivers/mmc/host/msm_sdcc.c:1180:	ret = clk_set_rate(host->clk, msmsdcc_fmin);
drivers/mmc/host/msm_sdcc.c:1186:	host->pclk_rate = clk_get_rate(host->pclk);
drivers/mmc/host/msm_sdcc.c:1187:	host->clk_rate = clk_get_rate(host->clk);
drivers/mmc/host/msm_sdcc.c:1215:	host->saved_irq0mask = MCI_IRQENABLE;
drivers/mmc/host/msm_sdcc.c:1221:	memset(&host->timer, 0, sizeof(host->timer));
drivers/mmc/host/msm_sdcc.c:1227:		host->stat_irq = stat_irqres->start;
drivers/mmc/host/msm_sdcc.c:1228:		ret = request_irq(host->stat_irq,
drivers/mmc/host/msm_sdcc.c:1235:			       mmc_hostname(mmc), host->stat_irq, ret);
drivers/mmc/host/msm_sdcc.c:1244:		init_timer(&host->timer);
drivers/mmc/host/msm_sdcc.c:1245:		host->timer.data = (unsigned long)host;
drivers/mmc/host/msm_sdcc.c:1246:		host->timer.function = msmsdcc_check_status;
drivers/mmc/host/msm_sdcc.c:1247:		host->timer.expires = jiffies + HZ;
drivers/mmc/host/msm_sdcc.c:1248:		add_timer(&host->timer);
drivers/mmc/host/msm_sdcc.c:1252:		host->oldstat = host->plat->status(mmc_dev(host->mmc));
drivers/mmc/host/msm_sdcc.c:1253:		host->eject = !host->oldstat;
drivers/mmc/host/msm_sdcc.c:1256:	init_timer(&host->busclk_timer);
drivers/mmc/host/msm_sdcc.c:1257:	host->busclk_timer.data = (unsigned long) host;
drivers/mmc/host/msm_sdcc.c:1258:	host->busclk_timer.function = msmsdcc_busclk_expired;
drivers/mmc/host/msm_sdcc.c:1276:		(unsigned int) host->stat_irq, host->dma.channel);
drivers/mmc/host/msm_sdcc.c:1280:		mmc_hostname(mmc), msmsdcc_fmin, msmsdcc_fmax, host->pclk_rate);
drivers/mmc/host/msm_sdcc.c:1281:	pr_info("%s: Slot eject status = %d\n", mmc_hostname(mmc), host->eject);
drivers/mmc/host/msm_sdcc.c:1285:	if (host->dma.channel != -1) {
drivers/mmc/host/msm_sdcc.c:1287:			mmc_hostname(mmc), host->dma.nc, host->dma.nc_busaddr);
drivers/mmc/host/msm_sdcc.c:1289:			mmc_hostname(mmc), host->dma.cmd_busaddr,
drivers/mmc/host/msm_sdcc.c:1290:			host->dma.cmdptr_busaddr);
drivers/mmc/host/msm_sdcc.c:1293:	if (host->timer.function)
drivers/mmc/host/msm_sdcc.c:1303:	if (host->stat_irq)
drivers/mmc/host/msm_sdcc.c:1304:		free_irq(host->stat_irq, host);
drivers/mmc/host/msm_sdcc.c:1308:	clk_put(host->clk);
drivers/mmc/host/msm_sdcc.c:1310:	clk_put(host->pclk);
drivers/mmc/host/msm_sdcc.c:1326:		if (host->stat_irq)
drivers/mmc/host/msm_sdcc.c:1327:			disable_irq(host->stat_irq);
drivers/mmc/host/msm_sdcc.c:1333:		if (host->clks_on)
drivers/mmc/host/msm_sdcc.c:1349:		msmsdcc_writel(host, host->saved_irq0mask, MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:1353:		if (host->stat_irq)
drivers/mmc/host/msm_sdcc.c:1354:			enable_irq(host->stat_irq);
drivers/mmc/host/mvsdio.c:63:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:81:				dev_warn(host->dev, "FIFO_EMPTY bit missing\n");
drivers/mmc/host/mvsdio.c:87:		dev_dbg(host->dev, "*** wait for FIFO_EMPTY bit "
drivers/mmc/host/mvsdio.c:93:	tmout = DIV_ROUND_UP(data->timeout_ns, host->ns_per_clk);
drivers/mmc/host/mvsdio.c:101:	dev_dbg(host->dev, "data %s at 0x%08x: blocks=%d blksz=%d tmout=%u (%d)\n",
drivers/mmc/host/mvsdio.c:106:	host->ctrl &= ~MVSD_HOST_CTRL_TMOUT_MASK;
drivers/mmc/host/mvsdio.c:107:	host->ctrl |= MVSD_HOST_CTRL_TMOUT(tmout_index);
drivers/mmc/host/mvsdio.c:108:	mvsd_write(MVSD_HOST_CTRL, host->ctrl);
drivers/mmc/host/mvsdio.c:117:		host->pio_size = data->blocks * data->blksz;
drivers/mmc/host/mvsdio.c:118:		host->pio_ptr = sg_virt(data->sg);
drivers/mmc/host/mvsdio.c:122:					  mmc_hostname(host->mmc),
drivers/mmc/host/mvsdio.c:123:					  host->pio_ptr, host->pio_size);
drivers/mmc/host/mvsdio.c:129:		host->sg_frags = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/mvsdio.c:141:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:146:	BUG_ON(host->mrq != NULL);
drivers/mmc/host/mvsdio.c:147:	host->mrq = mrq;
drivers/mmc/host/mvsdio.c:149:	dev_dbg(host->dev, "cmd %d (hw state 0x%04x)\n",
drivers/mmc/host/mvsdio.c:189:			else if (host->pio_size > 32)
drivers/mmc/host/mvsdio.c:221:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mvsdio.c:223:	host->xfer_mode &= MVSD_XFER_MODE_INT_CHK_EN;
drivers/mmc/host/mvsdio.c:224:	host->xfer_mode |= xfer;
drivers/mmc/host/mvsdio.c:225:	mvsd_write(MVSD_XFER_MODE, host->xfer_mode);
drivers/mmc/host/mvsdio.c:231:	host->intr_en &= MVSD_NOR_CARD_INT;
drivers/mmc/host/mvsdio.c:232:	host->intr_en |= intr | MVSD_NOR_ERROR;
drivers/mmc/host/mvsdio.c:233:	mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:236:	mod_timer(&host->timer, jiffies + 5 * HZ);
drivers/mmc/host/mvsdio.c:238:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mvsdio.c:244:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:289:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:291:	if (host->pio_ptr) {
drivers/mmc/host/mvsdio.c:292:		host->pio_ptr = NULL;
drivers/mmc/host/mvsdio.c:293:		host->pio_size = 0;
drivers/mmc/host/mvsdio.c:295:		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_frags,
drivers/mmc/host/mvsdio.c:309:	dev_dbg(host->dev, "data done: blocks_left=%d, bytes_left=%d\n",
drivers/mmc/host/mvsdio.c:331:			dev_dbg(host->dev, "c12err 0x%04x\n", err_cmd12);
drivers/mmc/host/mvsdio.c:348:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:353:	dev_dbg(host->dev, "intr 0x%04x intr_en 0x%04x hw_state 0x%04x\n",
drivers/mmc/host/mvsdio.c:357:	spin_lock(&host->lock);
drivers/mmc/host/mvsdio.c:360:	if (host->pio_size &&
drivers/mmc/host/mvsdio.c:361:	    (intr_status & host->intr_en &
drivers/mmc/host/mvsdio.c:363:		u16 *p = host->pio_ptr;
drivers/mmc/host/mvsdio.c:364:		int s = host->pio_size;
drivers/mmc/host/mvsdio.c:392:				host->intr_en &=
drivers/mmc/host/mvsdio.c:394:				mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:395:			} else if (host->intr_en & MVSD_NOR_RX_FIFO_8W) {
drivers/mmc/host/mvsdio.c:396:				host->intr_en &= ~MVSD_NOR_RX_FIFO_8W;
drivers/mmc/host/mvsdio.c:397:				host->intr_en |= MVSD_NOR_RX_READY;
drivers/mmc/host/mvsdio.c:398:				mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:401:		dev_dbg(host->dev, "pio %d intr 0x%04x hw_state 0x%04x\n",
drivers/mmc/host/mvsdio.c:403:		host->pio_ptr = p;
drivers/mmc/host/mvsdio.c:404:		host->pio_size = s;
drivers/mmc/host/mvsdio.c:406:	} else if (host->pio_size &&
drivers/mmc/host/mvsdio.c:407:		   (intr_status & host->intr_en &
drivers/mmc/host/mvsdio.c:409:		u16 *p = host->pio_ptr;
drivers/mmc/host/mvsdio.c:410:		int s = host->pio_size;
drivers/mmc/host/mvsdio.c:433:				host->intr_en &=
drivers/mmc/host/mvsdio.c:435:				mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:438:		dev_dbg(host->dev, "pio %d intr 0x%04x hw_state 0x%04x\n",
drivers/mmc/host/mvsdio.c:440:		host->pio_ptr = p;
drivers/mmc/host/mvsdio.c:441:		host->pio_size = s;
drivers/mmc/host/mvsdio.c:449:	if (intr_status & host->intr_en & ~intr_done_mask) {
drivers/mmc/host/mvsdio.c:450:		struct mmc_request *mrq = host->mrq;
drivers/mmc/host/mvsdio.c:454:		del_timer(&host->timer);
drivers/mmc/host/mvsdio.c:455:		host->mrq = NULL;
drivers/mmc/host/mvsdio.c:457:		host->intr_en &= MVSD_NOR_CARD_INT;
drivers/mmc/host/mvsdio.c:458:		mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:461:		spin_unlock(&host->lock);
drivers/mmc/host/mvsdio.c:467:			dev_dbg(host->dev, "err 0x%04x\n", err_status);
drivers/mmc/host/mvsdio.c:475:					mmc_hostname(host->mmc), err_status);
drivers/mmc/host/mvsdio.c:479:		mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mvsdio.c:482:		spin_unlock(&host->lock);
drivers/mmc/host/mvsdio.c:485:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/mvsdio.c:493:			"pio=%d\n", mmc_hostname(host->mmc), intr_status,
drivers/mmc/host/mvsdio.c:494:			host->intr_en, host->pio_size);
drivers/mmc/host/mvsdio.c:501:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:505:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mvsdio.c:506:	mrq = host->mrq;
drivers/mmc/host/mvsdio.c:509:				mmc_hostname(host->mmc));
drivers/mmc/host/mvsdio.c:511:				"intr_en=0x%04x\n", mmc_hostname(host->mmc),
drivers/mmc/host/mvsdio.c:516:		host->mrq = NULL;
drivers/mmc/host/mvsdio.c:520:		host->xfer_mode &= MVSD_XFER_MODE_INT_CHK_EN;
drivers/mmc/host/mvsdio.c:521:		mvsd_write(MVSD_XFER_MODE, host->xfer_mode);
drivers/mmc/host/mvsdio.c:523:		host->intr_en &= MVSD_NOR_CARD_INT;
drivers/mmc/host/mvsdio.c:524:		mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:535:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mvsdio.c:538:		mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mvsdio.c:544:	mmc_detect_change(host->mmc, msecs_to_jiffies(100));
drivers/mmc/host/mvsdio.c:551:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:554:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mvsdio.c:556:		host->xfer_mode |= MVSD_XFER_MODE_INT_CHK_EN;
drivers/mmc/host/mvsdio.c:557:		host->intr_en |= MVSD_NOR_CARD_INT;
drivers/mmc/host/mvsdio.c:559:		host->xfer_mode &= ~MVSD_XFER_MODE_INT_CHK_EN;
drivers/mmc/host/mvsdio.c:560:		host->intr_en &= ~MVSD_NOR_CARD_INT;
drivers/mmc/host/mvsdio.c:562:	mvsd_write(MVSD_XFER_MODE, host->xfer_mode);
drivers/mmc/host/mvsdio.c:563:	mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:564:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mvsdio.c:571:	if (host->gpio_write_protect)
drivers/mmc/host/mvsdio.c:572:		return gpio_get_value(host->gpio_write_protect);
drivers/mmc/host/mvsdio.c:583:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:584:	dev_dbg(host->dev, "power up\n");
drivers/mmc/host/mvsdio.c:597:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:598:	dev_dbg(host->dev, "power down\n");
drivers/mmc/host/mvsdio.c:612:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:621:		host->clock = 0;
drivers/mmc/host/mvsdio.c:622:		dev_dbg(host->dev, "clock off\n");
drivers/mmc/host/mvsdio.c:623:	} else if (ios->clock != host->clock) {
drivers/mmc/host/mvsdio.c:624:		u32 m = DIV_ROUND_UP(host->base_clock, ios->clock) - 1;
drivers/mmc/host/mvsdio.c:628:		host->clock = ios->clock;
drivers/mmc/host/mvsdio.c:629:		host->ns_per_clk = 1000000000 / (host->base_clock / (m+1));
drivers/mmc/host/mvsdio.c:630:		dev_dbg(host->dev, "clock=%d (%d), div=0x%04x\n",
drivers/mmc/host/mvsdio.c:631:			ios->clock, host->base_clock / (m+1), m);
drivers/mmc/host/mvsdio.c:661:	host->ctrl = ctrl_reg;
drivers/mmc/host/mvsdio.c:663:	dev_dbg(host->dev, "ctrl 0x%04x: %s %s %s\n", ctrl_reg,
drivers/mmc/host/mvsdio.c:685:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:728:	host->mmc = mmc;
drivers/mmc/host/mvsdio.c:729:	host->dev = &pdev->dev;
drivers/mmc/host/mvsdio.c:730:	host->res = r;
drivers/mmc/host/mvsdio.c:731:	host->base_clock = mvsd_data->clock / 2;
drivers/mmc/host/mvsdio.c:739:	mmc->f_min = DIV_ROUND_UP(host->base_clock, MVSD_BASE_DIV_MAX);
drivers/mmc/host/mvsdio.c:750:	spin_lock_init(&host->lock);
drivers/mmc/host/mvsdio.c:752:	host->base = ioremap(r->start, SZ_4K);
drivers/mmc/host/mvsdio.c:753:	if (!host->base) {
drivers/mmc/host/mvsdio.c:769:		host->irq = irq;
drivers/mmc/host/mvsdio.c:781:				host->gpio_card_detect =
drivers/mmc/host/mvsdio.c:787:	if (!host->gpio_card_detect)
drivers/mmc/host/mvsdio.c:795:			host->gpio_write_protect =
drivers/mmc/host/mvsdio.c:800:	setup_timer(&host->timer, mvsd_timeout_timer, (unsigned long)host);
drivers/mmc/host/mvsdio.c:808:	if (host->gpio_card_detect)
drivers/mmc/host/mvsdio.c:810:		       host->gpio_card_detect);
drivers/mmc/host/mvsdio.c:817:		if (host->irq)
drivers/mmc/host/mvsdio.c:818:			free_irq(host->irq, host);
drivers/mmc/host/mvsdio.c:819:		if (host->gpio_card_detect) {
drivers/mmc/host/mvsdio.c:820:			free_irq(gpio_to_irq(host->gpio_card_detect), host);
drivers/mmc/host/mvsdio.c:821:			gpio_free(host->gpio_card_detect);
drivers/mmc/host/mvsdio.c:823:		if (host->gpio_write_protect)
drivers/mmc/host/mvsdio.c:824:			gpio_free(host->gpio_write_protect);
drivers/mmc/host/mvsdio.c:825:		if (host->base)
drivers/mmc/host/mvsdio.c:826:			iounmap(host->base);
drivers/mmc/host/mvsdio.c:843:		if (host->gpio_card_detect) {
drivers/mmc/host/mvsdio.c:844:			free_irq(gpio_to_irq(host->gpio_card_detect), host);
drivers/mmc/host/mvsdio.c:845:			gpio_free(host->gpio_card_detect);
drivers/mmc/host/mvsdio.c:848:		free_irq(host->irq, host);
drivers/mmc/host/mvsdio.c:849:		if (host->gpio_write_protect)
drivers/mmc/host/mvsdio.c:850:			gpio_free(host->gpio_write_protect);
drivers/mmc/host/mvsdio.c:851:		del_timer_sync(&host->timer);
drivers/mmc/host/mvsdio.c:853:		iounmap(host->base);
drivers/mmc/host/mvsdio.c:854:		release_resource(host->res);
drivers/mmc/host/sdhci.c:87:	if (host->flags & SDHCI_USE_ADMA)
drivers/mmc/host/sdhci.c:89:		       readl(host->ioaddr + SDHCI_ADMA_ERROR),
drivers/mmc/host/sdhci.c:90:		       readl(host->ioaddr + SDHCI_ADMA_ADDRESS));
drivers/mmc/host/sdhci.c:105:	if (unlikely(host->clock < 500000))
drivers/mmc/host/sdhci.c:108:	if (!host->mmc->card || mmc_card_sdio(host->mmc->card))
drivers/mmc/host/sdhci.c:111:	clk = readw(host->ioaddr + SDHCI_CLOCK_CONTROL);
drivers/mmc/host/sdhci.c:113:	writew(clk, host->ioaddr + SDHCI_CLOCK_CONTROL);
drivers/mmc/host/sdhci.c:120:	if (unlikely(host->clock < 500000))
drivers/mmc/host/sdhci.c:123:	if (!host->mmc->card || mmc_card_sdio(host->mmc->card))
drivers/mmc/host/sdhci.c:126:	clk = readw(host->ioaddr + SDHCI_CLOCK_CONTROL);
drivers/mmc/host/sdhci.c:128:	writew(clk, host->ioaddr + SDHCI_CLOCK_CONTROL);
drivers/mmc/host/sdhci.c:156:	if (host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION)
drivers/mmc/host/sdhci.c:180:	if (host->quirks & SDHCI_QUIRK_NO_CARD_NO_RESET) {
drivers/mmc/host/sdhci.c:186:	if (host->quirks & SDHCI_QUIRK_RESTORE_IRQS_AFTER_RESET)
drivers/mmc/host/sdhci.c:192:		host->clock = 0;
drivers/mmc/host/sdhci.c:201:				mmc_hostname(host->mmc), (int)mask);
drivers/mmc/host/sdhci.c:209:	if (host->quirks & SDHCI_QUIRK_RESTORE_IRQS_AFTER_RESET)
drivers/mmc/host/sdhci.c:230:		host->clock = 0;
drivers/mmc/host/sdhci.c:231:		sdhci_set_ios(host->mmc, &host->mmc->ios);
drivers/mmc/host/sdhci.c:266:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:273:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:292:	blksize = host->data->blksz;
drivers/mmc/host/sdhci.c:298:		if (!sg_miter_next(&host->sg_miter))
drivers/mmc/host/sdhci.c:301:		len = min(host->sg_miter.length, blksize);
drivers/mmc/host/sdhci.c:304:		host->sg_miter.consumed = len;
drivers/mmc/host/sdhci.c:306:		buf = host->sg_miter.addr;
drivers/mmc/host/sdhci.c:323:	sg_miter_stop(&host->sg_miter);
drivers/mmc/host/sdhci.c:337:	blksize = host->data->blksz;
drivers/mmc/host/sdhci.c:344:		if (!sg_miter_next(&host->sg_miter))
drivers/mmc/host/sdhci.c:347:		len = min(host->sg_miter.length, blksize);
drivers/mmc/host/sdhci.c:350:		host->sg_miter.consumed = len;
drivers/mmc/host/sdhci.c:352:		buf = host->sg_miter.addr;
drivers/mmc/host/sdhci.c:369:	sg_miter_stop(&host->sg_miter);
drivers/mmc/host/sdhci.c:378:	BUG_ON(!host->data);
drivers/mmc/host/sdhci.c:380:	if (host->blocks == 0)
drivers/mmc/host/sdhci.c:383:	if (host->data->flags & MMC_DATA_READ)
drivers/mmc/host/sdhci.c:393:	if ((host->quirks & SDHCI_QUIRK_BROKEN_SMALL_PIO) &&
drivers/mmc/host/sdhci.c:394:		(host->data->blocks == 1))
drivers/mmc/host/sdhci.c:398:		if (host->quirks & SDHCI_QUIRK_PIO_NEEDS_DELAY)
drivers/mmc/host/sdhci.c:401:		if (host->data->flags & MMC_DATA_READ)
drivers/mmc/host/sdhci.c:406:		host->blocks--;
drivers/mmc/host/sdhci.c:407:		if (host->blocks == 0)
drivers/mmc/host/sdhci.c:471:	host->align_addr = dma_map_single(mmc_dev(host->mmc),
drivers/mmc/host/sdhci.c:472:		host->align_buffer, 128 * 4, direction);
drivers/mmc/host/sdhci.c:473:	if (dma_mapping_error(mmc_dev(host->mmc), host->align_addr))
drivers/mmc/host/sdhci.c:475:	BUG_ON(host->align_addr & 0x3);
drivers/mmc/host/sdhci.c:477:	host->sg_count = dma_map_sg(mmc_dev(host->mmc),
drivers/mmc/host/sdhci.c:479:	if (host->sg_count == 0)
drivers/mmc/host/sdhci.c:482:	desc = host->adma_desc;
drivers/mmc/host/sdhci.c:483:	align = host->align_buffer;
drivers/mmc/host/sdhci.c:485:	align_addr = host->align_addr;
drivers/mmc/host/sdhci.c:487:	for_each_sg(data->sg, sg, host->sg_count, i) {
drivers/mmc/host/sdhci.c:531:		WARN_ON((desc - host->adma_desc) > (128 * 2 + 1) * 4);
drivers/mmc/host/sdhci.c:534:	if (host->quirks & SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC) {
drivers/mmc/host/sdhci.c:538:		if (desc != host->adma_desc) {
drivers/mmc/host/sdhci.c:555:		dma_sync_single_for_device(mmc_dev(host->mmc),
drivers/mmc/host/sdhci.c:556:			host->align_addr, 128 * 4, direction);
drivers/mmc/host/sdhci.c:559:	host->adma_addr = dma_map_single(mmc_dev(host->mmc),
drivers/mmc/host/sdhci.c:560:		host->adma_desc, (128 * 2 + 1) * 4, DMA_TO_DEVICE);
drivers/mmc/host/sdhci.c:561:	if (dma_mapping_error(mmc_dev(host->mmc), host->adma_addr))
drivers/mmc/host/sdhci.c:563:	BUG_ON(host->adma_addr & 0x3);
drivers/mmc/host/sdhci.c:568:	dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/sdhci.c:571:	dma_unmap_single(mmc_dev(host->mmc), host->align_addr,
drivers/mmc/host/sdhci.c:593:	dma_unmap_single(mmc_dev(host->mmc), host->adma_addr,
drivers/mmc/host/sdhci.c:596:	dma_unmap_single(mmc_dev(host->mmc), host->align_addr,
drivers/mmc/host/sdhci.c:600:		dma_sync_sg_for_cpu(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/sdhci.c:603:		align = host->align_buffer;
drivers/mmc/host/sdhci.c:605:		for_each_sg(data->sg, sg, host->sg_count, i) {
drivers/mmc/host/sdhci.c:619:	dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/sdhci.c:634:	if (host->quirks & SDHCI_QUIRK_BROKEN_TIMEOUT_VAL)
drivers/mmc/host/sdhci.c:639:		data->timeout_clks / host->clock;
drivers/mmc/host/sdhci.c:641:	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)
drivers/mmc/host/sdhci.c:642:		host->timeout_clk = host->clock / 1000;
drivers/mmc/host/sdhci.c:650:	 * (2) host->timeout_clk < 2^16
drivers/mmc/host/sdhci.c:655:	current_timeout = (1 << 13) * 1000 / host->timeout_clk;
drivers/mmc/host/sdhci.c:665:			mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:677:	if (host->flags & SDHCI_REQ_USE_DMA)
drivers/mmc/host/sdhci.c:689:	WARN_ON(host->data);
drivers/mmc/host/sdhci.c:696:	BUG_ON(data->blksz > host->mmc->max_blk_size);
drivers/mmc/host/sdhci.c:699:	host->data = data;
drivers/mmc/host/sdhci.c:700:	host->data_early = 0;
drivers/mmc/host/sdhci.c:705:	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA))
drivers/mmc/host/sdhci.c:706:		host->flags |= SDHCI_REQ_USE_DMA;
drivers/mmc/host/sdhci.c:712:	if (host->flags & SDHCI_REQ_USE_DMA) {
drivers/mmc/host/sdhci.c:717:		if (host->flags & SDHCI_USE_ADMA) {
drivers/mmc/host/sdhci.c:718:			if (host->quirks & SDHCI_QUIRK_32BIT_ADMA_SIZE)
drivers/mmc/host/sdhci.c:721:			if (host->quirks & SDHCI_QUIRK_32BIT_DMA_SIZE)
drivers/mmc/host/sdhci.c:731:					host->flags &= ~SDHCI_REQ_USE_DMA;
drivers/mmc/host/sdhci.c:742:	if (host->flags & SDHCI_REQ_USE_DMA) {
drivers/mmc/host/sdhci.c:747:		if (host->flags & SDHCI_USE_ADMA) {
drivers/mmc/host/sdhci.c:753:			if (host->quirks & SDHCI_QUIRK_32BIT_ADMA_SIZE)
drivers/mmc/host/sdhci.c:756:			if (host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR)
drivers/mmc/host/sdhci.c:765:					host->flags &= ~SDHCI_REQ_USE_DMA;
drivers/mmc/host/sdhci.c:772:	if (host->flags & SDHCI_REQ_USE_DMA) {
drivers/mmc/host/sdhci.c:773:		if (host->flags & SDHCI_USE_ADMA) {
drivers/mmc/host/sdhci.c:781:				host->flags &= ~SDHCI_REQ_USE_DMA;
drivers/mmc/host/sdhci.c:783:				sdhci_writel(host, host->adma_addr,
drivers/mmc/host/sdhci.c:789:			sg_cnt = dma_map_sg(mmc_dev(host->mmc),
drivers/mmc/host/sdhci.c:800:				host->flags &= ~SDHCI_REQ_USE_DMA;
drivers/mmc/host/sdhci.c:814:	if (host->version >= SDHCI_SPEC_200) {
drivers/mmc/host/sdhci.c:817:		if ((host->flags & SDHCI_REQ_USE_DMA) &&
drivers/mmc/host/sdhci.c:818:			(host->flags & SDHCI_USE_ADMA))
drivers/mmc/host/sdhci.c:825:	if (!(host->flags & SDHCI_REQ_USE_DMA)) {
drivers/mmc/host/sdhci.c:829:		if (host->data->flags & MMC_DATA_READ)
drivers/mmc/host/sdhci.c:833:		sg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);
drivers/mmc/host/sdhci.c:834:		host->blocks = data->blocks;
drivers/mmc/host/sdhci.c:852:	WARN_ON(!host->data);
drivers/mmc/host/sdhci.c:859:	if (host->flags & SDHCI_REQ_USE_DMA)
drivers/mmc/host/sdhci.c:869:	BUG_ON(!host->data);
drivers/mmc/host/sdhci.c:871:	data = host->data;
drivers/mmc/host/sdhci.c:872:	host->data = NULL;
drivers/mmc/host/sdhci.c:874:	if (host->flags & SDHCI_REQ_USE_DMA) {
drivers/mmc/host/sdhci.c:875:		if (host->flags & SDHCI_USE_ADMA)
drivers/mmc/host/sdhci.c:878:			dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/sdhci.c:908:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:920:	WARN_ON(host->cmd);
drivers/mmc/host/sdhci.c:922:	del_timer(&host->busy_check_timer);
drivers/mmc/host/sdhci.c:933:	if (host->mrq->data && (cmd == host->mrq->data->stop))
drivers/mmc/host/sdhci.c:939:				"inhibit bit(s).\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:942:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:949:	mod_timer(&host->timer, jiffies + 10 * HZ);
drivers/mmc/host/sdhci.c:951:	host->cmd = cmd;
drivers/mmc/host/sdhci.c:965:			mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:967:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:988:	mask = readl(host->ioaddr + SDHCI_INT_STATUS);
drivers/mmc/host/sdhci.c:989:	writel(mask & SDHCI_INT_DATA_MASK & SDHCI_INT_CMD_MASK, host->ioaddr + SDHCI_INT_STATUS);
drivers/mmc/host/sdhci.c:992:		mask = readl(host->ioaddr + S3C64XX_SDHCI_CONTROL4);
drivers/mmc/host/sdhci.c:1005:	BUG_ON(host->cmd == NULL);
drivers/mmc/host/sdhci.c:1007:	if (host->cmd->flags & MMC_RSP_PRESENT) {
drivers/mmc/host/sdhci.c:1008:		if (host->cmd->flags & MMC_RSP_136) {
drivers/mmc/host/sdhci.c:1011:				host->cmd->resp[i] = sdhci_readl(host,
drivers/mmc/host/sdhci.c:1014:					host->cmd->resp[i] |=
drivers/mmc/host/sdhci.c:1019:			host->cmd->resp[0] = sdhci_readl(host, SDHCI_RESPONSE);
drivers/mmc/host/sdhci.c:1023:	host->cmd->error = 0;
drivers/mmc/host/sdhci.c:1025:	if (host->data && host->data_early)
drivers/mmc/host/sdhci.c:1028:	if (!host->cmd->data)
drivers/mmc/host/sdhci.c:1029:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:1031:	host->cmd = NULL;
drivers/mmc/host/sdhci.c:1040:	if (clock == host->clock)
drivers/mmc/host/sdhci.c:1043:	if (host->ops->set_clock) {
drivers/mmc/host/sdhci.c:1044:		host->ops->set_clock(host, clock);
drivers/mmc/host/sdhci.c:1045:		if (host->quirks & SDHCI_QUIRK_NONSTANDARD_CLOCK)
drivers/mmc/host/sdhci.c:1055:		if ((host->max_clk / div) <= clock)
drivers/mmc/host/sdhci.c:1070:				"stabilised.\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:1083:	host->clock = clock;
drivers/mmc/host/sdhci.c:1110:	if (host->pwr == pwr)
drivers/mmc/host/sdhci.c:1113:	host->pwr = pwr;
drivers/mmc/host/sdhci.c:1124:	if (!(host->quirks & SDHCI_QUIRK_SINGLE_POWER_WRITE))
drivers/mmc/host/sdhci.c:1131:	if (host->quirks & SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER)
drivers/mmc/host/sdhci.c:1142:	if (host->quirks & SDHCI_QUIRK_DELAY_AFTER_POWER)
drivers/mmc/host/sdhci.c:1160:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:1162:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/sdhci.c:1168:	host->mrq = mrq;
drivers/mmc/host/sdhci.c:1171:	if ((host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION) ||
drivers/mmc/host/sdhci.c:1172:	    (host->quirks & SDHCI_QUIRK_BROKEN_CARD_PRESENT_BIT))
drivers/mmc/host/sdhci.c:1178:	if (!present || host->flags & SDHCI_DEVICE_DEAD) {
drivers/mmc/host/sdhci.c:1179:		host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/sdhci.c:1180:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:1185:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:1196:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:1198:	if (host->flags & SDHCI_DEVICE_DEAD)
drivers/mmc/host/sdhci.c:1210:	if (host->ops->set_ios)
drivers/mmc/host/sdhci.c:1211:		host->ops->set_ios(host, ios);
drivers/mmc/host/sdhci.c:1227:	if (!(host->quirks & SDHCI_QUIRK_NO_HISPD_BIT) &&
drivers/mmc/host/sdhci.c:1240:	if(host->quirks & SDHCI_QUIRK_RESET_CMD_DATA_ON_IOS)
drivers/mmc/host/sdhci.c:1245:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:1256:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:1258:	if (host->flags & SDHCI_DEVICE_DEAD)
drivers/mmc/host/sdhci.c:1263:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:1265:	if (host->quirks & SDHCI_QUIRK_INVERTED_WRITE_PROTECT)
drivers/mmc/host/sdhci.c:1278:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:1280:	present = host->ops->get_cd(host);
drivers/mmc/host/sdhci.c:1282:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:1294:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:1296:	if (host->flags & SDHCI_DEVICE_DEAD)
drivers/mmc/host/sdhci.c:1306:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:1316:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:1318:	if(host->ops->adjust_cfg)
drivers/mmc/host/sdhci.c:1319:		host->ops->adjust_cfg(host, rw);
drivers/mmc/host/sdhci.c:1324:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:1349:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:1352:		if (host->mrq) {
drivers/mmc/host/sdhci.c:1354:				mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:1356:				mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:1361:			host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/sdhci.c:1362:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:1366:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:1368:	mmc_detect_change(host->mmc, msecs_to_jiffies(500));
drivers/mmc/host/sdhci.c:1382:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:1384:	del_timer(&host->timer);
drivers/mmc/host/sdhci.c:1386:	mrq = host->mrq;
drivers/mmc/host/sdhci.c:1395:	if (!(host->flags & SDHCI_DEVICE_DEAD) &&
drivers/mmc/host/sdhci.c:1399:		   (host->quirks & SDHCI_QUIRK_RESET_AFTER_REQUEST))) {
drivers/mmc/host/sdhci.c:1402:		if (host->quirks & SDHCI_QUIRK_CLOCK_BEFORE_RESET) {
drivers/mmc/host/sdhci.c:1406:			clock = host->clock;
drivers/mmc/host/sdhci.c:1407:			host->clock = 0;
drivers/mmc/host/sdhci.c:1417:	if(readl(host->ioaddr + SDHCI_PRESENT_STATE) & SDHCI_DATA_INHIBIT)
drivers/mmc/host/sdhci.c:1418:		mod_timer(&host->busy_check_timer, jiffies + msecs_to_jiffies(10));
drivers/mmc/host/sdhci.c:1422:	host->mrq = NULL;
drivers/mmc/host/sdhci.c:1423:	host->cmd = NULL;
drivers/mmc/host/sdhci.c:1424:	host->data = NULL;
drivers/mmc/host/sdhci.c:1431:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:1433:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/sdhci.c:1443:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:1445:	if (host->mrq) {
drivers/mmc/host/sdhci.c:1447:			"interrupt.\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:1450:		if (host->data) {
drivers/mmc/host/sdhci.c:1451:			host->data->error = -ETIMEDOUT;
drivers/mmc/host/sdhci.c:1454:			if (host->cmd)
drivers/mmc/host/sdhci.c:1455:				host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/sdhci.c:1457:				host->mrq->cmd->error = -ETIMEDOUT;
drivers/mmc/host/sdhci.c:1459:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:1464:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:1474:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:1476:	if(readl(host->ioaddr + SDHCI_PRESENT_STATE) & (SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT))
drivers/mmc/host/sdhci.c:1477:		mod_timer(&host->busy_check_timer, jiffies + msecs_to_jiffies(10));
drivers/mmc/host/sdhci.c:1481:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:1494:	if (!host->cmd) {
drivers/mmc/host/sdhci.c:1497:			mmc_hostname(host->mmc), (unsigned)intmask);
drivers/mmc/host/sdhci.c:1503:		host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/sdhci.c:1506:		host->cmd->error = -EILSEQ;
drivers/mmc/host/sdhci.c:1508:	if (host->cmd->error) {
drivers/mmc/host/sdhci.c:1509:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:1510:		host->cmd = NULL;
drivers/mmc/host/sdhci.c:1525:	if (host->cmd->flags & MMC_RSP_BUSY) {
drivers/mmc/host/sdhci.c:1526:		if (host->cmd->data)
drivers/mmc/host/sdhci.c:1529:		else if (!(host->quirks & SDHCI_QUIRK_NO_BUSY_IRQ))
drivers/mmc/host/sdhci.c:1543:	const char *name = mmc_hostname(host->mmc);
drivers/mmc/host/sdhci.c:1544:	u8 *desc = host->adma_desc;
drivers/mmc/host/sdhci.c:1573:	if (!host->data) {
drivers/mmc/host/sdhci.c:1579:		if (host->cmd && (host->cmd->flags & MMC_RSP_BUSY)) {
drivers/mmc/host/sdhci.c:1588:			mmc_hostname(host->mmc), (unsigned)intmask);
drivers/mmc/host/sdhci.c:1595:		host->data->error = -ETIMEDOUT;
drivers/mmc/host/sdhci.c:1597:		host->data->error = -EILSEQ;
drivers/mmc/host/sdhci.c:1599:		printk(KERN_ERR "%s: ADMA error\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:1601:		host->data->error = -EIO;
drivers/mmc/host/sdhci.c:1604:	if (host->data->error)
drivers/mmc/host/sdhci.c:1620:			if (host->cmd) {
drivers/mmc/host/sdhci.c:1626:				host->data_early = 1;
drivers/mmc/host/sdhci.c:1641:	spin_lock(&host->lock);
drivers/mmc/host/sdhci.c:1651:		mmc_hostname(host->mmc), intmask);
drivers/mmc/host/sdhci.c:1656:		tasklet_schedule(&host->card_tasklet);
drivers/mmc/host/sdhci.c:1679:			mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:1692:			mmc_hostname(host->mmc), intmask);
drivers/mmc/host/sdhci.c:1702:	spin_unlock(&host->lock);
drivers/mmc/host/sdhci.c:1708:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/sdhci.c:1724:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/sdhci.c:1729:		ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/sdhci.c:1733:	del_timer(&host->busy_check_timer);
drivers/mmc/host/sdhci.c:1735:	if (host->irq)
drivers/mmc/host/sdhci.c:1736:		disable_irq(host->irq);
drivers/mmc/host/sdhci.c:1746:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/sdhci.c:1748:	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {
drivers/mmc/host/sdhci.c:1749:		if (host->ops->enable_dma)
drivers/mmc/host/sdhci.c:1750:			host->ops->enable_dma(host);
drivers/mmc/host/sdhci.c:1753:	if (host->irq)
drivers/mmc/host/sdhci.c:1754:		enable_irq(host->irq);
drivers/mmc/host/sdhci.c:1756:	sdhci_init(host, (host->mmc->pm_flags & MMC_PM_KEEP_POWER));
drivers/mmc/host/sdhci.c:1760:		ret = mmc_resume_host(host->mmc);
drivers/mmc/host/sdhci.c:1791:	host->mmc = mmc;
drivers/mmc/host/sdhci.c:1809:	mmc = host->mmc;
drivers/mmc/host/sdhci.c:1812:		host->quirks = debug_quirks;
drivers/mmc/host/sdhci.c:1816:	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
drivers/mmc/host/sdhci.c:1817:	host->version = (host->version & SDHCI_SPEC_VER_MASK)
drivers/mmc/host/sdhci.c:1819:	if (host->version > SDHCI_SPEC_200) {
drivers/mmc/host/sdhci.c:1822:			host->version);
drivers/mmc/host/sdhci.c:1827:	if (host->quirks & SDHCI_QUIRK_FORCE_DMA)
drivers/mmc/host/sdhci.c:1828:		host->flags |= SDHCI_USE_SDMA;
drivers/mmc/host/sdhci.c:1832:		host->flags |= SDHCI_USE_SDMA;
drivers/mmc/host/sdhci.c:1834:	if ((host->quirks & SDHCI_QUIRK_BROKEN_DMA) &&
drivers/mmc/host/sdhci.c:1835:		(host->flags & SDHCI_USE_SDMA)) {
drivers/mmc/host/sdhci.c:1837:		host->flags &= ~SDHCI_USE_SDMA;
drivers/mmc/host/sdhci.c:1840:	if ((host->version >= SDHCI_SPEC_200) && (caps & SDHCI_CAN_DO_ADMA2))
drivers/mmc/host/sdhci.c:1841:		host->flags |= SDHCI_USE_ADMA;
drivers/mmc/host/sdhci.c:1843:	if ((host->quirks & SDHCI_QUIRK_BROKEN_ADMA) &&
drivers/mmc/host/sdhci.c:1844:		(host->flags & SDHCI_USE_ADMA)) {
drivers/mmc/host/sdhci.c:1846:		host->flags &= ~SDHCI_USE_ADMA;
drivers/mmc/host/sdhci.c:1849:	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {
drivers/mmc/host/sdhci.c:1850:		if (host->ops->enable_dma) {
drivers/mmc/host/sdhci.c:1851:			if (host->ops->enable_dma(host)) {
drivers/mmc/host/sdhci.c:1855:				host->flags &=
drivers/mmc/host/sdhci.c:1861:	if (host->flags & SDHCI_USE_ADMA) {
drivers/mmc/host/sdhci.c:1867:		host->adma_desc = kmalloc((128 * 2 + 1) * 4, GFP_KERNEL);
drivers/mmc/host/sdhci.c:1868:		host->align_buffer = kmalloc(128 * 4, GFP_KERNEL);
drivers/mmc/host/sdhci.c:1869:		if (!host->adma_desc || !host->align_buffer) {
drivers/mmc/host/sdhci.c:1870:			kfree(host->adma_desc);
drivers/mmc/host/sdhci.c:1871:			kfree(host->align_buffer);
drivers/mmc/host/sdhci.c:1875:			host->flags &= ~SDHCI_USE_ADMA;
drivers/mmc/host/sdhci.c:1884:	if (!(host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA))) {
drivers/mmc/host/sdhci.c:1885:		host->dma_mask = DMA_BIT_MASK(64);
drivers/mmc/host/sdhci.c:1886:		mmc_dev(host->mmc)->dma_mask = &host->dma_mask;
drivers/mmc/host/sdhci.c:1889:	host->max_clk =
drivers/mmc/host/sdhci.c:1891:	host->max_clk *= 1000000;
drivers/mmc/host/sdhci.c:1892:	if (host->max_clk == 0 || host->quirks &
drivers/mmc/host/sdhci.c:1894:		if (!host->ops->get_max_clock) {
drivers/mmc/host/sdhci.c:1900:		host->max_clk = host->ops->get_max_clock(host);
drivers/mmc/host/sdhci.c:1903:	host->timeout_clk =
drivers/mmc/host/sdhci.c:1905:	if (host->timeout_clk == 0) {
drivers/mmc/host/sdhci.c:1906:		if (host->ops->get_timeout_clock) {
drivers/mmc/host/sdhci.c:1907:			host->timeout_clk = host->ops->get_timeout_clock(host);
drivers/mmc/host/sdhci.c:1908:		} else if (!(host->quirks &
drivers/mmc/host/sdhci.c:1917:		host->timeout_clk *= 1000;
drivers/mmc/host/sdhci.c:1922:	if(host->ops->get_ro)
drivers/mmc/host/sdhci.c:1923:		sdhci_ops.get_ro = host->ops->get_ro;
drivers/mmc/host/sdhci.c:1926:	if (host->quirks & SDHCI_QUIRK_NONSTANDARD_CLOCK &&
drivers/mmc/host/sdhci.c:1927:			host->ops->set_clock && host->ops->get_min_clock)
drivers/mmc/host/sdhci.c:1928:		mmc->f_min = host->ops->get_min_clock(host);
drivers/mmc/host/sdhci.c:1931:	mmc->f_max = host->max_clk;
drivers/mmc/host/sdhci.c:1934:	if (!(host->quirks & SDHCI_QUIRK_FORCE_1_BIT_DATA))
drivers/mmc/host/sdhci.c:1940:	if (host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION)
drivers/mmc/host/sdhci.c:1957:	spin_lock_init(&host->lock);
drivers/mmc/host/sdhci.c:1963:	if (host->flags & SDHCI_USE_ADMA)
drivers/mmc/host/sdhci.c:1965:	else if (host->flags & SDHCI_USE_SDMA)
drivers/mmc/host/sdhci.c:1982:	if (host->flags & SDHCI_USE_ADMA)
drivers/mmc/host/sdhci.c:1991:	if (host->quirks & SDHCI_QUIRK_FORCE_BLK_SZ_2048) {
drivers/mmc/host/sdhci.c:2008:	mmc->max_blk_count = (host->quirks & SDHCI_QUIRK_NO_MULTIBLOCK) ? 1 : 65535;
drivers/mmc/host/sdhci.c:2013:	tasklet_init(&host->card_tasklet,
drivers/mmc/host/sdhci.c:2015:	tasklet_init(&host->finish_tasklet,
drivers/mmc/host/sdhci.c:2018:	setup_timer(&host->timer, sdhci_timeout_timer, (unsigned long)host);
drivers/mmc/host/sdhci.c:2019:	setup_timer(&host->busy_check_timer, sdhci_busy_check_timer, (unsigned long)host);
drivers/mmc/host/sdhci.c:2021:	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
drivers/mmc/host/sdhci.c:2033:	snprintf(host->led_name, sizeof(host->led_name),
drivers/mmc/host/sdhci.c:2035:	host->led.name = host->led_name;
drivers/mmc/host/sdhci.c:2036:	host->led.brightness = LED_OFF;
drivers/mmc/host/sdhci.c:2037:	host->led.default_trigger = mmc_hostname(mmc);
drivers/mmc/host/sdhci.c:2038:	host->led.brightness_set = sdhci_led_control;
drivers/mmc/host/sdhci.c:2040:	ret = led_classdev_register(mmc_dev(mmc), &host->led);
drivers/mmc/host/sdhci.c:2050:		mmc_hostname(mmc), host->hw_name, dev_name(mmc_dev(mmc)),
drivers/mmc/host/sdhci.c:2051:		(host->flags & SDHCI_USE_ADMA) ? "ADMA" :
drivers/mmc/host/sdhci.c:2052:		(host->flags & SDHCI_USE_SDMA) ? "DMA" : "PIO");
drivers/mmc/host/sdhci.c:2061:	free_irq(host->irq, host);
drivers/mmc/host/sdhci.c:2064:	tasklet_kill(&host->card_tasklet);
drivers/mmc/host/sdhci.c:2065:	tasklet_kill(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:2077:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:2079:		host->flags |= SDHCI_DEVICE_DEAD;
drivers/mmc/host/sdhci.c:2081:		if (host->mrq) {
drivers/mmc/host/sdhci.c:2083:				" transfer!\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:2085:			host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/sdhci.c:2086:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:2089:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:2094:	mmc_remove_host(host->mmc);
drivers/mmc/host/sdhci.c:2097:	led_classdev_unregister(&host->led);
drivers/mmc/host/sdhci.c:2103:	free_irq(host->irq, host);
drivers/mmc/host/sdhci.c:2105:	del_timer_sync(&host->timer);
drivers/mmc/host/sdhci.c:2106:	del_timer_sync(&host->busy_check_timer);
drivers/mmc/host/sdhci.c:2108:	tasklet_kill(&host->card_tasklet);
drivers/mmc/host/sdhci.c:2109:	tasklet_kill(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:2111:	kfree(host->adma_desc);
drivers/mmc/host/sdhci.c:2112:	kfree(host->align_buffer);
drivers/mmc/host/sdhci.c:2114:	host->adma_desc = NULL;
drivers/mmc/host/sdhci.c:2115:	host->align_buffer = NULL;
drivers/mmc/host/sdhci.c:2122:	mmc_free_host(host->mmc);
drivers/mmc/host/sdhci-spear.c:64:	tasklet_schedule(&host->card_tasklet);
drivers/mmc/host/sdhci-spear.c:128:	host->hw_name = "sdhci";
drivers/mmc/host/sdhci-spear.c:129:	host->ops = &sdhci_pltfm_ops;
drivers/mmc/host/sdhci-spear.c:130:	host->irq = platform_get_irq(pdev, 0);
drivers/mmc/host/sdhci-spear.c:131:	host->quirks = SDHCI_QUIRK_BROKEN_ADMA;
drivers/mmc/host/sdhci-spear.c:133:	host->ioaddr = ioremap(iomem->start, resource_size(iomem));
drivers/mmc/host/sdhci-spear.c:134:	if (!host->ioaddr) {
drivers/mmc/host/sdhci-spear.c:200:				mmc_hostname(host->mmc), pdev);
drivers/mmc/host/sdhci-spear.c:223:	iounmap(host->ioaddr);
drivers/mmc/host/sdhci-spear.c:259:	scratch = readl(host->ioaddr + SDHCI_INT_STATUS);
drivers/mmc/host/sdhci-spear.c:264:	iounmap(host->ioaddr);
drivers/mmc/host/bfin_sdh.c:96:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:97:	host->imask |= mask;
drivers/mmc/host/bfin_sdh.c:100:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:107:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:108:	host->imask &= ~mask;
drivers/mmc/host/bfin_sdh.c:109:	bfin_write_SDH_MASK0(host->imask);
drivers/mmc/host/bfin_sdh.c:111:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:121:	dev_dbg(mmc_dev(host->mmc), "%s enter flags: 0x%x\n", __func__, data->flags);
drivers/mmc/host/bfin_sdh.c:122:	host->data = data;
drivers/mmc/host/bfin_sdh.c:141:	cycle_ns = 1000000000 / (get_sclk() / (2 * (host->clk_div + 1)));
drivers/mmc/host/bfin_sdh.c:148:		host->dma_dir = DMA_FROM_DEVICE;
drivers/mmc/host/bfin_sdh.c:151:		host->dma_dir = DMA_TO_DEVICE;
drivers/mmc/host/bfin_sdh.c:154:	host->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma_dir);
drivers/mmc/host/bfin_sdh.c:160:		for_each_sg(data->sg, sg, host->dma_len, i) {
drivers/mmc/host/bfin_sdh.c:161:			host->sg_cpu[i].start_addr = sg_dma_address(sg);
drivers/mmc/host/bfin_sdh.c:162:			host->sg_cpu[i].cfg = dma_cfg;
drivers/mmc/host/bfin_sdh.c:163:			host->sg_cpu[i].x_count = sg_dma_len(sg) / 4;
drivers/mmc/host/bfin_sdh.c:164:			host->sg_cpu[i].x_modify = 4;
drivers/mmc/host/bfin_sdh.c:165:			dev_dbg(mmc_dev(host->mmc), "%d: start_addr:0x%lx, "
drivers/mmc/host/bfin_sdh.c:167:				i, host->sg_cpu[i].start_addr,
drivers/mmc/host/bfin_sdh.c:168:				host->sg_cpu[i].cfg, host->sg_cpu[i].x_count,
drivers/mmc/host/bfin_sdh.c:169:				host->sg_cpu[i].x_modify);
drivers/mmc/host/bfin_sdh.c:172:	flush_dcache_range((unsigned int)host->sg_cpu,
drivers/mmc/host/bfin_sdh.c:173:		(unsigned int)host->sg_cpu +
drivers/mmc/host/bfin_sdh.c:174:			host->dma_len * sizeof(struct dma_desc_array));
drivers/mmc/host/bfin_sdh.c:176:	host->sg_cpu[host->dma_len - 1].cfg &= ~(DMAFLOW | NDSIZE);
drivers/mmc/host/bfin_sdh.c:177:	host->sg_cpu[host->dma_len - 1].cfg |= DI_EN;
drivers/mmc/host/bfin_sdh.c:179:	set_dma_curr_desc_addr(host->dma_ch, (unsigned long *)host->sg_dma);
drivers/mmc/host/bfin_sdh.c:180:	set_dma_x_count(host->dma_ch, 0);
drivers/mmc/host/bfin_sdh.c:181:	set_dma_x_modify(host->dma_ch, 0);
drivers/mmc/host/bfin_sdh.c:182:	set_dma_config(host->dma_ch, dma_cfg);
drivers/mmc/host/bfin_sdh.c:186:	set_dma_start_addr(host->dma_ch, sg_dma_address(&data->sg[0]));
drivers/mmc/host/bfin_sdh.c:187:	set_dma_x_count(host->dma_ch, length / 4);
drivers/mmc/host/bfin_sdh.c:188:	set_dma_x_modify(host->dma_ch, 4);
drivers/mmc/host/bfin_sdh.c:189:	set_dma_config(host->dma_ch, dma_cfg);
drivers/mmc/host/bfin_sdh.c:195:	dev_dbg(mmc_dev(host->mmc), "%s exit\n", __func__);
drivers/mmc/host/bfin_sdh.c:204:	dev_dbg(mmc_dev(host->mmc), "%s enter cmd: 0x%p\n", __func__, cmd);
drivers/mmc/host/bfin_sdh.c:205:	WARN_ON(host->cmd != NULL);
drivers/mmc/host/bfin_sdh.c:206:	host->cmd = cmd;
drivers/mmc/host/bfin_sdh.c:235:	dev_dbg(mmc_dev(host->mmc), "%s enter\n", __func__);
drivers/mmc/host/bfin_sdh.c:236:	host->mrq = NULL;
drivers/mmc/host/bfin_sdh.c:237:	host->cmd = NULL;
drivers/mmc/host/bfin_sdh.c:238:	host->data = NULL;
drivers/mmc/host/bfin_sdh.c:239:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/bfin_sdh.c:244:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/bfin_sdh.c:247:	dev_dbg(mmc_dev(host->mmc), "%s enter cmd: %p\n", __func__, cmd);
drivers/mmc/host/bfin_sdh.c:251:	host->cmd = NULL;
drivers/mmc/host/bfin_sdh.c:268:	if (host->data && !cmd->error) {
drivers/mmc/host/bfin_sdh.c:269:		if (host->data->flags & MMC_DATA_WRITE) {
drivers/mmc/host/bfin_sdh.c:270:			ret = sdh_setup_data(host, host->data);
drivers/mmc/host/bfin_sdh.c:277:		sdh_finish_request(host, host->mrq);
drivers/mmc/host/bfin_sdh.c:284:	struct mmc_data *data = host->data;
drivers/mmc/host/bfin_sdh.c:286:	dev_dbg(mmc_dev(host->mmc), "%s enter stat: 0x%x\n", __func__, stat);
drivers/mmc/host/bfin_sdh.c:290:	disable_dma(host->dma_ch);
drivers/mmc/host/bfin_sdh.c:291:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/bfin_sdh.c:292:		     host->dma_dir);
drivers/mmc/host/bfin_sdh.c:312:	host->data = NULL;
drivers/mmc/host/bfin_sdh.c:313:	if (host->mrq->stop) {
drivers/mmc/host/bfin_sdh.c:315:		sdh_start_cmd(host, host->mrq->stop);
drivers/mmc/host/bfin_sdh.c:317:		sdh_finish_request(host, host->mrq);
drivers/mmc/host/bfin_sdh.c:328:	dev_dbg(mmc_dev(host->mmc), "%s enter, mrp:%p, cmd:%p\n", __func__, mrq, mrq->cmd);
drivers/mmc/host/bfin_sdh.c:329:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/bfin_sdh.c:331:	host->mrq = mrq;
drivers/mmc/host/bfin_sdh.c:332:	host->data = mrq->data;
drivers/mmc/host/bfin_sdh.c:352:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:364:		host->clk_div = clk_div;
drivers/mmc/host/bfin_sdh.c:391:	host->power_mode = ios->power_mode;
drivers/mmc/host/bfin_sdh.c:398:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:400:	dev_dbg(mmc_dev(host->mmc), "SDH: clk_div = 0x%x actual clock:%ld expected clock:%d\n",
drivers/mmc/host/bfin_sdh.c:401:		host->clk_div,
drivers/mmc/host/bfin_sdh.c:402:		host->clk_div ? get_sclk() / (2 * (host->clk_div + 1)) : 0,
drivers/mmc/host/bfin_sdh.c:415:	dev_dbg(mmc_dev(host->mmc), "%s enter, irq_stat: 0x%04x\n", __func__,
drivers/mmc/host/bfin_sdh.c:416:		get_dma_curr_irqstat(host->dma_ch));
drivers/mmc/host/bfin_sdh.c:417:	clear_dma_irqstat(host->dma_ch);
drivers/mmc/host/bfin_sdh.c:429:	dev_dbg(mmc_dev(host->mmc), "%s enter\n", __func__);
drivers/mmc/host/bfin_sdh.c:432:		mmc_detect_change(host->mmc, 0);
drivers/mmc/host/bfin_sdh.c:447:	dev_dbg(mmc_dev(host->mmc), "%s exit\n\n", __func__);
drivers/mmc/host/bfin_sdh.c:482:	host->mmc = mmc;
drivers/mmc/host/bfin_sdh.c:484:	spin_lock_init(&host->lock);
drivers/mmc/host/bfin_sdh.c:485:	host->irq = drv_data->irq_int0;
drivers/mmc/host/bfin_sdh.c:486:	host->dma_ch = drv_data->dma_chan;
drivers/mmc/host/bfin_sdh.c:488:	ret = request_dma(host->dma_ch, DRIVER_NAME "DMA");
drivers/mmc/host/bfin_sdh.c:494:	ret = set_dma_callback(host->dma_ch, sdh_dma_irq, host);
drivers/mmc/host/bfin_sdh.c:500:	host->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);
drivers/mmc/host/bfin_sdh.c:501:	if (host->sg_cpu == NULL) {
drivers/mmc/host/bfin_sdh.c:509:	ret = request_irq(host->irq, sdh_stat_irq, 0, "SDH Status IRQ", host);
drivers/mmc/host/bfin_sdh.c:537:	free_irq(host->irq, host);
drivers/mmc/host/bfin_sdh.c:540:	dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/bfin_sdh.c:542:	free_dma(host->dma_ch);
drivers/mmc/host/bfin_sdh.c:561:		free_irq(host->irq, host);
drivers/mmc/host/bfin_sdh.c:562:		free_dma(host->dma_ch);
drivers/mmc/host/bfin_sdh.c:563:		dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/imxmmc.c:104:	reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:105:	writew(reg & ~STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:108:			reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:110:					host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:113:		reg = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:116:			reg = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:123:	dev_dbg(mmc_dev(host->mmc), "imxmci_stop_clock blocked, no luck\n");
drivers/mmc/host/imxmmc.c:133:	reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:134:	writew(reg & ~STR_STP_CLK_STOP_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:136:	clear_bit(IMXMCI_PEND_STARTED_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:143:	reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:144:	writew(reg | STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:150:			reg = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:153:				reg = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:157:			if (test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:168:		if (!test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:169:			reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:171:					host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:177:	dev_err(mmc_dev(host->mmc), "imxmci_start_clock blocked, no luck\n");
drivers/mmc/host/imxmmc.c:187:	writew(0x08, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:188:	writew(0x0D, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:191:		writew(0x05, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:193:	writew(0xff, host->base + MMC_REG_RES_TO);
drivers/mmc/host/imxmmc.c:194:	writew(512, host->base + MMC_REG_BLK_LEN);
drivers/mmc/host/imxmmc.c:195:	writew(1, host->base + MMC_REG_NOB);
drivers/mmc/host/imxmmc.c:207:			dev_dbg(mmc_dev(host->mmc), "busy wait timeout in %s, STATUS = 0x%x (0x%x)\n",
drivers/mmc/host/imxmmc.c:212:		*pstat |= readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:218:	if (!(stat_mask & STATUS_END_CMD_RESP) || (host->mmc->ios.clock >= 8000000))
drivers/mmc/host/imxmmc.c:219:		dev_info(mmc_dev(host->mmc), "busy wait for %d usec in %s, STATUS = 0x%x (0x%x)\n",
drivers/mmc/host/imxmmc.c:234:	host->data = data;
drivers/mmc/host/imxmmc.c:237:	writew(nob, host->base + MMC_REG_NOB);
drivers/mmc/host/imxmmc.c:238:	writew(blksz, host->base + MMC_REG_BLK_LEN);
drivers/mmc/host/imxmmc.c:249:		host->dma_size = datasz;
drivers/mmc/host/imxmmc.c:251:			host->dma_dir = DMA_FROM_DEVICE;
drivers/mmc/host/imxmmc.c:254:			writew(1, host->base + MMC_REG_NOB);
drivers/mmc/host/imxmmc.c:255:			writew(512, host->base + MMC_REG_BLK_LEN);
drivers/mmc/host/imxmmc.c:257:			host->dma_dir = DMA_TO_DEVICE;
drivers/mmc/host/imxmmc.c:261:		host->data_ptr = (u16 *)sg_virt(data->sg);
drivers/mmc/host/imxmmc.c:262:		host->data_cnt = 0;
drivers/mmc/host/imxmmc.c:264:		clear_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:265:		set_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:271:		host->dma_dir = DMA_FROM_DEVICE;
drivers/mmc/host/imxmmc.c:272:		host->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/imxmmc.c:273:					     data->sg_len,  host->dma_dir);
drivers/mmc/host/imxmmc.c:275:		imx_dma_setup_sg(host->dma, data->sg, data->sg_len, datasz,
drivers/mmc/host/imxmmc.c:276:				 host->res->start + MMC_REG_BUFFER_ACCESS,
drivers/mmc/host/imxmmc.c:279:		/*imx_dma_setup_mem2dev_ccr(host->dma, DMA_MODE_READ, IMX_DMA_WIDTH_16, CCR_REN);*/
drivers/mmc/host/imxmmc.c:280:		CCR(host->dma) = CCR_DMOD_LINEAR | CCR_DSIZ_32 | CCR_SMOD_FIFO | CCR_SSIZ_16 | CCR_REN;
drivers/mmc/host/imxmmc.c:282:		host->dma_dir = DMA_TO_DEVICE;
drivers/mmc/host/imxmmc.c:284:		host->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/imxmmc.c:285:					     data->sg_len,  host->dma_dir);
drivers/mmc/host/imxmmc.c:287:		imx_dma_setup_sg(host->dma, data->sg, data->sg_len, datasz,
drivers/mmc/host/imxmmc.c:288:				 host->res->start + MMC_REG_BUFFER_ACCESS,
drivers/mmc/host/imxmmc.c:291:		/*imx_dma_setup_mem2dev_ccr(host->dma, DMA_MODE_WRITE, IMX_DMA_WIDTH_16, CCR_REN);*/
drivers/mmc/host/imxmmc.c:292:		CCR(host->dma) = CCR_SMOD_LINEAR | CCR_SSIZ_32 | CCR_DMOD_FIFO | CCR_DSIZ_16 | CCR_REN;
drivers/mmc/host/imxmmc.c:296:	host->dma_size = 0;
drivers/mmc/host/imxmmc.c:297:	for (i = 0; i < host->dma_nents; i++)
drivers/mmc/host/imxmmc.c:298:		host->dma_size += data->sg[i].length;
drivers/mmc/host/imxmmc.c:300:	if (datasz > host->dma_size) {
drivers/mmc/host/imxmmc.c:301:		dev_err(mmc_dev(host->mmc), "imxmci_setup_data datasz 0x%x > 0x%x dm_size\n",
drivers/mmc/host/imxmmc.c:302:			datasz, host->dma_size);
drivers/mmc/host/imxmmc.c:306:	host->dma_size = datasz;
drivers/mmc/host/imxmmc.c:310:	set_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:311:	clear_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:314:	if (host->dma_dir == DMA_FROM_DEVICE)
drivers/mmc/host/imxmmc.c:315:		imx_dma_enable(host->dma);
drivers/mmc/host/imxmmc.c:323:	WARN_ON(host->cmd != NULL);
drivers/mmc/host/imxmmc.c:324:	host->cmd = cmd;
drivers/mmc/host/imxmmc.c:347:	if (test_and_clear_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:350:	if (host->actual_bus_width == MMC_BUS_WIDTH_4)
drivers/mmc/host/imxmmc.c:353:	writew(cmd->opcode, host->base + MMC_REG_CMD);
drivers/mmc/host/imxmmc.c:354:	writew(cmd->arg >> 16, host->base + MMC_REG_ARGH);
drivers/mmc/host/imxmmc.c:355:	writew(cmd->arg & 0xffff, host->base + MMC_REG_ARGL);
drivers/mmc/host/imxmmc.c:356:	writew(cmdat, host->base + MMC_REG_CMD_DAT_CONT);
drivers/mmc/host/imxmmc.c:358:	atomic_set(&host->stuck_timeout, 0);
drivers/mmc/host/imxmmc.c:359:	set_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:369:		if (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:373:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/imxmmc.c:374:	host->imask = imask;
drivers/mmc/host/imxmmc.c:375:	writew(host->imask, host->base + MMC_REG_INT_MASK);
drivers/mmc/host/imxmmc.c:376:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/imxmmc.c:378:	dev_dbg(mmc_dev(host->mmc), "CMD%02d (0x%02x) mask set to 0x%04x\n",
drivers/mmc/host/imxmmc.c:388:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/imxmmc.c:390:	host->pending_events &= ~(IMXMCI_PEND_WAIT_RESP_m | IMXMCI_PEND_DMA_END_m |
drivers/mmc/host/imxmmc.c:393:	host->imask = IMXMCI_INT_MASK_DEFAULT;
drivers/mmc/host/imxmmc.c:394:	writew(host->imask, host->base + MMC_REG_INT_MASK);
drivers/mmc/host/imxmmc.c:396:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/imxmmc.c:399:		host->prev_cmd_code = req->cmd->opcode;
drivers/mmc/host/imxmmc.c:401:	host->req = NULL;
drivers/mmc/host/imxmmc.c:402:	host->cmd = NULL;
drivers/mmc/host/imxmmc.c:403:	host->data = NULL;
drivers/mmc/host/imxmmc.c:404:	mmc_request_done(host->mmc, req);
drivers/mmc/host/imxmmc.c:409:	struct mmc_data *data = host->data;
drivers/mmc/host/imxmmc.c:412:	if (test_and_clear_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:413:		imx_dma_disable(host->dma);
drivers/mmc/host/imxmmc.c:414:		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_nents,
drivers/mmc/host/imxmmc.c:415:			     host->dma_dir);
drivers/mmc/host/imxmmc.c:419:		dev_dbg(mmc_dev(host->mmc), "request failed. status: 0x%08x\n", stat);
drivers/mmc/host/imxmmc.c:427:		data->bytes_xfered = host->dma_size;
drivers/mmc/host/imxmmc.c:432:	host->data = NULL;
drivers/mmc/host/imxmmc.c:439:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/imxmmc.c:442:	struct mmc_data *data = host->data;
drivers/mmc/host/imxmmc.c:447:	host->cmd = NULL;
drivers/mmc/host/imxmmc.c:450:		dev_dbg(mmc_dev(host->mmc), "CMD TIMEOUT\n");
drivers/mmc/host/imxmmc.c:453:		dev_dbg(mmc_dev(host->mmc), "cmd crc error\n");
drivers/mmc/host/imxmmc.c:460:				a = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/imxmmc.c:461:				b = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/imxmmc.c:465:			a = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/imxmmc.c:466:			b = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/imxmmc.c:467:			c = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/imxmmc.c:472:	dev_dbg(mmc_dev(host->mmc), "RESP 0x%08x, 0x%08x, 0x%08x, 0x%08x, error %d\n",
drivers/mmc/host/imxmmc.c:476:		if (host->req->data->flags & MMC_DATA_WRITE) {
drivers/mmc/host/imxmmc.c:480:			stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:486:				if (host->req)
drivers/mmc/host/imxmmc.c:487:					imxmci_finish_request(host, host->req);
drivers/mmc/host/imxmmc.c:488:				dev_warn(mmc_dev(host->mmc), "STATUS = 0x%04x\n",
drivers/mmc/host/imxmmc.c:493:			if (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:494:				imx_dma_enable(host->dma);
drivers/mmc/host/imxmmc.c:499:		req = host->req;
drivers/mmc/host/imxmmc.c:507:			dev_warn(mmc_dev(host->mmc), "imxmci_cmd_done: no request to finish\n");
drivers/mmc/host/imxmmc.c:515:	struct mmc_data *data = host->data;
drivers/mmc/host/imxmmc.c:523:	if (host->req->stop) {
drivers/mmc/host/imxmmc.c:525:		imxmci_start_cmd(host, host->req->stop, 0);
drivers/mmc/host/imxmmc.c:528:		req = host->req;
drivers/mmc/host/imxmmc.c:532:			dev_warn(mmc_dev(host->mmc), "imxmci_data_done: no request to finish\n");
drivers/mmc/host/imxmmc.c:545:	if (host->actual_bus_width != MMC_BUS_WIDTH_4)
drivers/mmc/host/imxmmc.c:551:	dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data running STATUS = 0x%x\n",
drivers/mmc/host/imxmmc.c:556:	if (host->dma_dir == DMA_FROM_DEVICE) {
drivers/mmc/host/imxmmc.c:564:		       (host->data_cnt < 512)) {
drivers/mmc/host/imxmmc.c:570:				data = readw(host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/imxmmc.c:572:				if (host->data_cnt+2 <= host->dma_size) {
drivers/mmc/host/imxmmc.c:573:					*(host->data_ptr++) = data;
drivers/mmc/host/imxmmc.c:575:					if (host->data_cnt < host->dma_size)
drivers/mmc/host/imxmmc.c:576:						*(u8 *)(host->data_ptr) = data;
drivers/mmc/host/imxmmc.c:578:				host->data_cnt += 2;
drivers/mmc/host/imxmmc.c:581:			stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:583:			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data read %d burst %d STATUS = 0x%x\n",
drivers/mmc/host/imxmmc.c:584:				host->data_cnt, burst_len, stat);
drivers/mmc/host/imxmmc.c:587:		if ((stat & STATUS_DATA_TRANS_DONE) && (host->data_cnt >= 512))
drivers/mmc/host/imxmmc.c:590:		if (host->dma_size & 0x1ff)
drivers/mmc/host/imxmmc.c:594:			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data read timeout STATUS = 0x%x\n",
drivers/mmc/host/imxmmc.c:605:		       (host->data_cnt < host->dma_size)) {
drivers/mmc/host/imxmmc.c:606:			if (burst_len >= host->dma_size - host->data_cnt) {
drivers/mmc/host/imxmmc.c:607:				burst_len = host->dma_size - host->data_cnt;
drivers/mmc/host/imxmmc.c:608:				host->data_cnt = host->dma_size;
drivers/mmc/host/imxmmc.c:611:				host->data_cnt += burst_len;
drivers/mmc/host/imxmmc.c:615:				writew(*(host->data_ptr++), host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/imxmmc.c:617:			stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:619:			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data write burst %d STATUS = 0x%x\n",
drivers/mmc/host/imxmmc.c:632:	u32 stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:634:	atomic_set(&host->stuck_timeout, 0);
drivers/mmc/host/imxmmc.c:635:	host->status_reg = stat;
drivers/mmc/host/imxmmc.c:636:	set_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:637:	tasklet_schedule(&host->tasklet);
drivers/mmc/host/imxmmc.c:643:	u32 stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:646:	writew(host->imask | INT_MASK_SDIO | INT_MASK_AUTO_CARD_DETECT,
drivers/mmc/host/imxmmc.c:647:			host->base + MMC_REG_INT_MASK);
drivers/mmc/host/imxmmc.c:649:	atomic_set(&host->stuck_timeout, 0);
drivers/mmc/host/imxmmc.c:650:	host->status_reg = stat;
drivers/mmc/host/imxmmc.c:651:	set_bit(IMXMCI_PEND_IRQ_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:652:	set_bit(IMXMCI_PEND_STARTED_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:653:	tasklet_schedule(&host->tasklet);
drivers/mmc/host/imxmmc.c:665:	if (atomic_read(&host->stuck_timeout) > 4) {
drivers/mmc/host/imxmmc.c:668:		stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:669:		host->status_reg = stat;
drivers/mmc/host/imxmmc.c:670:		if (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:671:			if (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:676:			if (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:677:				if (test_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:684:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/imxmmc.c:687:			readw(host->base + MMC_REG_INT_MASK));
drivers/mmc/host/imxmmc.c:688:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/imxmmc.c:690:			readw(host->base + MMC_REG_CMD_DAT_CONT),
drivers/mmc/host/imxmmc.c:691:			readw(host->base + MMC_REG_BLK_LEN),
drivers/mmc/host/imxmmc.c:692:			readw(host->base + MMC_REG_NOB),
drivers/mmc/host/imxmmc.c:693:			CCR(host->dma));
drivers/mmc/host/imxmmc.c:694:		dev_err(mmc_dev(host->mmc), "CMD%d, prevCMD%d, bus %d-bit, dma_size = 0x%x\n",
drivers/mmc/host/imxmmc.c:695:			host->cmd ? host->cmd->opcode : 0,
drivers/mmc/host/imxmmc.c:696:			host->prev_cmd_code,
drivers/mmc/host/imxmmc.c:697:			1 << host->actual_bus_width, host->dma_size);
drivers/mmc/host/imxmmc.c:700:	if (!host->present || timeout)
drivers/mmc/host/imxmmc.c:701:		host->status_reg = STATUS_TIME_OUT_RESP | STATUS_TIME_OUT_READ |
drivers/mmc/host/imxmmc.c:704:	if (test_bit(IMXMCI_PEND_IRQ_b, &host->pending_events) || timeout) {
drivers/mmc/host/imxmmc.c:705:		clear_bit(IMXMCI_PEND_IRQ_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:707:		stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:713:		stat |= host->status_reg;
drivers/mmc/host/imxmmc.c:715:		if (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:718:		if (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:725:			if (test_and_clear_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:727:			if (host->data && (stat & STATUS_ERR_MASK))
drivers/mmc/host/imxmmc.c:731:		if (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:732:			stat |= readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:734:				if (test_and_clear_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:737:						  &host->pending_events);
drivers/mmc/host/imxmmc.c:743:	if (test_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events) &&
drivers/mmc/host/imxmmc.c:744:	    !test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:746:		stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:748:		stat |= host->status_reg;
drivers/mmc/host/imxmmc.c:750:		if (host->dma_dir == DMA_TO_DEVICE)
drivers/mmc/host/imxmmc.c:756:			clear_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:761:	if (test_and_clear_bit(IMXMCI_PEND_CARD_XCHG_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:763:		if (host->cmd)
drivers/mmc/host/imxmmc.c:766:		if (host->data)
drivers/mmc/host/imxmmc.c:770:		if (host->req)
drivers/mmc/host/imxmmc.c:771:			imxmci_finish_request(host, host->req);
drivers/mmc/host/imxmmc.c:773:		mmc_detect_change(host->mmc, msecs_to_jiffies(100));
drivers/mmc/host/imxmmc.c:783:	WARN_ON(host->req != NULL);
drivers/mmc/host/imxmmc.c:785:	host->req = req;
drivers/mmc/host/imxmmc.c:812:		host->actual_bus_width = MMC_BUS_WIDTH_4;
drivers/mmc/host/imxmmc.c:814:		BLR(host->dma) = 0;	/* burst 64 byte read/write */
drivers/mmc/host/imxmmc.c:816:		host->actual_bus_width = MMC_BUS_WIDTH_1;
drivers/mmc/host/imxmmc.c:818:		BLR(host->dma) = 16;	/* burst 16 byte read/write */
drivers/mmc/host/imxmmc.c:821:	if (host->power_mode != ios->power_mode) {
drivers/mmc/host/imxmmc.c:826:			set_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:831:		host->power_mode = ios->power_mode;
drivers/mmc/host/imxmmc.c:841:		clk = clk_get_rate(host->clk);
drivers/mmc/host/imxmmc.c:858:		dev_dbg(mmc_dev(host->mmc), "PERCLK2 %d MHz -> prescaler %d\n",
drivers/mmc/host/imxmmc.c:869:		reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:871:				host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:874:		writew((prescaler << 3) | clk, host->base + MMC_REG_CLK_RATE);
drivers/mmc/host/imxmmc.c:881:		dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/imxmmc.c:883:			readw(host->base + MMC_REG_CLK_RATE));
drivers/mmc/host/imxmmc.c:893:	if (host->pdata && host->pdata->get_ro)
drivers/mmc/host/imxmmc.c:894:		return !!host->pdata->get_ro(mmc_dev(mmc));
drivers/mmc/host/imxmmc.c:913:	if (host->pdata && host->pdata->card_present &&
drivers/mmc/host/imxmmc.c:914:	    host->pdata->card_present(mmc_dev(host->mmc)) != host->present) {
drivers/mmc/host/imxmmc.c:915:		host->present ^= 1;
drivers/mmc/host/imxmmc.c:916:		dev_info(mmc_dev(host->mmc), "card %s\n",
drivers/mmc/host/imxmmc.c:917:		      host->present ? "inserted" : "removed");
drivers/mmc/host/imxmmc.c:919:		set_bit(IMXMCI_PEND_CARD_XCHG_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:920:		tasklet_schedule(&host->tasklet);
drivers/mmc/host/imxmmc.c:923:	if (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events) ||
drivers/mmc/host/imxmmc.c:924:	    test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:925:		atomic_inc(&host->stuck_timeout);
drivers/mmc/host/imxmmc.c:926:		if (atomic_read(&host->stuck_timeout) > 4)
drivers/mmc/host/imxmmc.c:927:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/imxmmc.c:929:		atomic_set(&host->stuck_timeout, 0);
drivers/mmc/host/imxmmc.c:933:	mod_timer(&host->timer, jiffies + (HZ>>1));
drivers/mmc/host/imxmmc.c:976:	host->base = ioremap(r->start, resource_size(r));
drivers/mmc/host/imxmmc.c:977:	if (!host->base) {
drivers/mmc/host/imxmmc.c:982:	host->mmc = mmc;
drivers/mmc/host/imxmmc.c:983:	host->dma_allocated = 0;
drivers/mmc/host/imxmmc.c:984:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/imxmmc.c:985:	if (!host->pdata)
drivers/mmc/host/imxmmc.c:988:	spin_lock_init(&host->lock);
drivers/mmc/host/imxmmc.c:989:	host->res = r;
drivers/mmc/host/imxmmc.c:990:	host->irq = irq;
drivers/mmc/host/imxmmc.c:992:	host->clk = clk_get(&pdev->dev, "perclk2");
drivers/mmc/host/imxmmc.c:993:	if (IS_ERR(host->clk)) {
drivers/mmc/host/imxmmc.c:994:		ret = PTR_ERR(host->clk);
drivers/mmc/host/imxmmc.c:997:	clk_enable(host->clk);
drivers/mmc/host/imxmmc.c:1011:	rev_no = readw(host->base + MMC_REG_REV_NO);
drivers/mmc/host/imxmmc.c:1013:		dev_err(mmc_dev(host->mmc), "wrong rev.no. 0x%08x. aborting.\n",
drivers/mmc/host/imxmmc.c:1014:			readw(host->base + MMC_REG_REV_NO));
drivers/mmc/host/imxmmc.c:1019:	writew(0x2db4, host->base + MMC_REG_READ_TO);
drivers/mmc/host/imxmmc.c:1021:	host->imask = IMXMCI_INT_MASK_DEFAULT;
drivers/mmc/host/imxmmc.c:1022:	writew(host->imask, host->base + MMC_REG_INT_MASK);
drivers/mmc/host/imxmmc.c:1024:	host->dma = imx_dma_request_by_prio(DRIVER_NAME, DMA_PRIO_LOW);
drivers/mmc/host/imxmmc.c:1025:	if(host->dma < 0) {
drivers/mmc/host/imxmmc.c:1026:		dev_err(mmc_dev(host->mmc), "imx_dma_request_by_prio failed\n");
drivers/mmc/host/imxmmc.c:1030:	host->dma_allocated = 1;
drivers/mmc/host/imxmmc.c:1031:	imx_dma_setup_handlers(host->dma, imxmci_dma_irq, NULL, host);
drivers/mmc/host/imxmmc.c:1032:	RSSR(host->dma) = DMA_REQ_SDHC;
drivers/mmc/host/imxmmc.c:1034:	tasklet_init(&host->tasklet, imxmci_tasklet_fnc, (unsigned long)host);
drivers/mmc/host/imxmmc.c:1035:	host->status_reg=0;
drivers/mmc/host/imxmmc.c:1036:	host->pending_events=0;
drivers/mmc/host/imxmmc.c:1038:	ret = request_irq(host->irq, imxmci_irq, 0, DRIVER_NAME, host);
drivers/mmc/host/imxmmc.c:1042:	if (host->pdata && host->pdata->card_present)
drivers/mmc/host/imxmmc.c:1043:		host->present = host->pdata->card_present(mmc_dev(mmc));
drivers/mmc/host/imxmmc.c:1045:		host->present = 1;
drivers/mmc/host/imxmmc.c:1047:	init_timer(&host->timer);
drivers/mmc/host/imxmmc.c:1048:	host->timer.data = (unsigned long)host;
drivers/mmc/host/imxmmc.c:1049:	host->timer.function = imxmci_check_status;
drivers/mmc/host/imxmmc.c:1050:	add_timer(&host->timer);
drivers/mmc/host/imxmmc.c:1051:	mod_timer(&host->timer, jiffies + (HZ >> 1));
drivers/mmc/host/imxmmc.c:1061:		if (host->dma_allocated) {
drivers/mmc/host/imxmmc.c:1062:			imx_dma_free(host->dma);
drivers/mmc/host/imxmmc.c:1063:			host->dma_allocated = 0;
drivers/mmc/host/imxmmc.c:1065:		if (host->clk) {
drivers/mmc/host/imxmmc.c:1066:			clk_disable(host->clk);
drivers/mmc/host/imxmmc.c:1067:			clk_put(host->clk);
drivers/mmc/host/imxmmc.c:1069:		if (host->base)
drivers/mmc/host/imxmmc.c:1070:			iounmap(host->base);
drivers/mmc/host/imxmmc.c:1087:		tasklet_disable(&host->tasklet);
drivers/mmc/host/imxmmc.c:1089:		del_timer_sync(&host->timer);
drivers/mmc/host/imxmmc.c:1092:		free_irq(host->irq, host);
drivers/mmc/host/imxmmc.c:1093:		iounmap(host->base);
drivers/mmc/host/imxmmc.c:1094:		if (host->dma_allocated) {
drivers/mmc/host/imxmmc.c:1095:			imx_dma_free(host->dma);
drivers/mmc/host/imxmmc.c:1096:			host->dma_allocated = 0;
drivers/mmc/host/imxmmc.c:1099:		tasklet_kill(&host->tasklet);
drivers/mmc/host/imxmmc.c:1101:		clk_disable(host->clk);
drivers/mmc/host/imxmmc.c:1102:		clk_put(host->clk);
drivers/mmc/host/imxmmc.c:1104:		release_mem_region(host->res->start, resource_size(host->res));
drivers/mmc/host/imxmmc.c:1132:			set_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events);
drivers/mmc/host/sdricoh_cs.c:106:	unsigned int value = readl(host->iobase + reg);
drivers/mmc/host/sdricoh_cs.c:107:	dev_vdbg(host->dev, "rl %x 0x%x\n", reg, value);
drivers/mmc/host/sdricoh_cs.c:114:	writel(value, host->iobase + reg);
drivers/mmc/host/sdricoh_cs.c:115:	dev_vdbg(host->dev, "wl %x 0x%x\n", reg, value);
drivers/mmc/host/sdricoh_cs.c:122:	unsigned int value = readw(host->iobase + reg);
drivers/mmc/host/sdricoh_cs.c:123:	dev_vdbg(host->dev, "rb %x 0x%x\n", reg, value);
drivers/mmc/host/sdricoh_cs.c:130:	writew(value, host->iobase + reg);
drivers/mmc/host/sdricoh_cs.c:131:	dev_vdbg(host->dev, "ww %x 0x%x\n", reg, value);
drivers/mmc/host/sdricoh_cs.c:137:	unsigned int value = readb(host->iobase + reg);
drivers/mmc/host/sdricoh_cs.c:138:	dev_vdbg(host->dev, "rb %x 0x%x\n", reg, value);
drivers/mmc/host/sdricoh_cs.c:146:	struct device *dev = host->dev;
drivers/mmc/host/sdricoh_cs.c:201:	dev_dbg(host->dev, "reset\n");
drivers/mmc/host/sdricoh_cs.c:271:	struct device *dev = host->dev;
drivers/mmc/host/sdricoh_cs.c:281:	if (host->app_cmd) {
drivers/mmc/host/sdricoh_cs.c:283:		host->app_cmd = 0;
drivers/mmc/host/sdricoh_cs.c:285:		host->app_cmd = 1;
drivers/mmc/host/sdricoh_cs.c:359:	dev_dbg(host->dev, "set_ios\n");
drivers/mmc/host/sdricoh_cs.c:435:	host->iobase = iobase;
drivers/mmc/host/sdricoh_cs.c:436:	host->dev = dev;
drivers/mmc/host/sdricoh_cs.c:437:	host->pci_dev = pci_dev;
drivers/mmc/host/sdricoh_cs.c:509:		pci_iounmap(host->pci_dev, host->iobase);
drivers/mmc/host/sdricoh_cs.c:510:		pci_dev_put(host->pci_dev);
drivers/mmc/host/au1xmmc.c:188:	WARN_ON(host->status != HOST_S_DATA);
drivers/mmc/host/au1xmmc.c:189:	host->status = HOST_S_STOP;
drivers/mmc/host/au1xmmc.c:201:	if (host->platdata && host->platdata->set_power)
drivers/mmc/host/au1xmmc.c:202:		host->platdata->set_power(host->mmc, state);
drivers/mmc/host/au1xmmc.c:209:	if (host->platdata && host->platdata->card_inserted)
drivers/mmc/host/au1xmmc.c:210:		return !!host->platdata->card_inserted(host->mmc);
drivers/mmc/host/au1xmmc.c:219:	if (host->platdata && host->platdata->card_readonly)
drivers/mmc/host/au1xmmc.c:220:		return !!host->platdata->card_readonly(mmc);
drivers/mmc/host/au1xmmc.c:227:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/au1xmmc.c:229:	host->mrq = NULL;
drivers/mmc/host/au1xmmc.c:230:	host->flags &= HOST_F_ACTIVE | HOST_F_DMA;
drivers/mmc/host/au1xmmc.c:232:	host->dma.len = 0;
drivers/mmc/host/au1xmmc.c:233:	host->dma.dir = 0;
drivers/mmc/host/au1xmmc.c:235:	host->pio.index  = 0;
drivers/mmc/host/au1xmmc.c:236:	host->pio.offset = 0;
drivers/mmc/host/au1xmmc.c:237:	host->pio.len = 0;
drivers/mmc/host/au1xmmc.c:239:	host->status = HOST_S_IDLE;
drivers/mmc/host/au1xmmc.c:241:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/au1xmmc.c:321:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/au1xmmc.c:325:	WARN_ON((host->status != HOST_S_DATA) && (host->status != HOST_S_STOP));
drivers/mmc/host/au1xmmc.c:327:	if (host->mrq == NULL)
drivers/mmc/host/au1xmmc.c:336:	while ((host->flags & HOST_F_XMIT) && (status & SD_STATUS_DB))
drivers/mmc/host/au1xmmc.c:340:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma.dir);
drivers/mmc/host/au1xmmc.c:344:	if (host->flags & HOST_F_XMIT)
drivers/mmc/host/au1xmmc.c:356:		if (host->flags & HOST_F_DMA) {
drivers/mmc/host/au1xmmc.c:366:				(data->blocks * data->blksz) - host->pio.len;
drivers/mmc/host/au1xmmc.c:390:	data = host->mrq->data;
drivers/mmc/host/au1xmmc.c:392:	if (!(host->flags & HOST_F_XMIT))
drivers/mmc/host/au1xmmc.c:396:	sg = &data->sg[host->pio.index];
drivers/mmc/host/au1xmmc.c:397:	sg_ptr = sg_virt(sg) + host->pio.offset;
drivers/mmc/host/au1xmmc.c:400:	sg_len = data->sg[host->pio.index].length - host->pio.offset;
drivers/mmc/host/au1xmmc.c:403:	max = (sg_len > host->pio.len) ? host->pio.len : sg_len;
drivers/mmc/host/au1xmmc.c:419:	host->pio.len -= count;
drivers/mmc/host/au1xmmc.c:420:	host->pio.offset += count;
drivers/mmc/host/au1xmmc.c:423:		host->pio.index++;
drivers/mmc/host/au1xmmc.c:424:		host->pio.offset = 0;
drivers/mmc/host/au1xmmc.c:427:	if (host->pio.len == 0) {
drivers/mmc/host/au1xmmc.c:430:		if (host->flags & HOST_F_STOP)
drivers/mmc/host/au1xmmc.c:433:		tasklet_schedule(&host->data_task);
drivers/mmc/host/au1xmmc.c:445:	data = host->mrq->data;
drivers/mmc/host/au1xmmc.c:447:	if (!(host->flags & HOST_F_RECV))
drivers/mmc/host/au1xmmc.c:450:	max = host->pio.len;
drivers/mmc/host/au1xmmc.c:452:	if (host->pio.index < host->dma.len) {
drivers/mmc/host/au1xmmc.c:453:		sg = &data->sg[host->pio.index];
drivers/mmc/host/au1xmmc.c:454:		sg_ptr = sg_virt(sg) + host->pio.offset;
drivers/mmc/host/au1xmmc.c:457:		sg_len = sg_dma_len(&data->sg[host->pio.index]) - host->pio.offset;
drivers/mmc/host/au1xmmc.c:474:			DBG("RX CRC Error [%d + %d].\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:475:					host->pio.len, count);
drivers/mmc/host/au1xmmc.c:480:			DBG("RX Overrun [%d + %d]\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:481:					host->pio.len, count);
drivers/mmc/host/au1xmmc.c:485:			DBG("RX Underrun [%d + %d]\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:486:					host->pio.len,	count);
drivers/mmc/host/au1xmmc.c:496:	host->pio.len -= count;
drivers/mmc/host/au1xmmc.c:497:	host->pio.offset += count;
drivers/mmc/host/au1xmmc.c:500:		host->pio.index++;
drivers/mmc/host/au1xmmc.c:501:		host->pio.offset = 0;
drivers/mmc/host/au1xmmc.c:504:	if (host->pio.len == 0) {
drivers/mmc/host/au1xmmc.c:508:		if (host->flags & HOST_F_STOP)
drivers/mmc/host/au1xmmc.c:511:		tasklet_schedule(&host->data_task);
drivers/mmc/host/au1xmmc.c:520:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/au1xmmc.c:525:	if (!host->mrq)
drivers/mmc/host/au1xmmc.c:533:			r[0] = au_readl(host->iobase + SD_RESP3);
drivers/mmc/host/au1xmmc.c:534:			r[1] = au_readl(host->iobase + SD_RESP2);
drivers/mmc/host/au1xmmc.c:535:			r[2] = au_readl(host->iobase + SD_RESP1);
drivers/mmc/host/au1xmmc.c:536:			r[3] = au_readl(host->iobase + SD_RESP0);
drivers/mmc/host/au1xmmc.c:555:			cmd->resp[0] = au_readl(host->iobase + SD_RESP0);
drivers/mmc/host/au1xmmc.c:563:	trans = host->flags & (HOST_F_XMIT | HOST_F_RECV);
drivers/mmc/host/au1xmmc.c:567:		tasklet_schedule(&host->finish_task);
drivers/mmc/host/au1xmmc.c:571:	host->status = HOST_S_DATA;
drivers/mmc/host/au1xmmc.c:573:	if (host->flags & HOST_F_DMA) {
drivers/mmc/host/au1xmmc.c:579:		if (host->flags & HOST_F_RECV) {
drivers/mmc/host/au1xmmc.c:619:		host->flags |= HOST_F_RECV;
drivers/mmc/host/au1xmmc.c:621:		host->flags |= HOST_F_XMIT;
drivers/mmc/host/au1xmmc.c:623:	if (host->mrq->stop)
drivers/mmc/host/au1xmmc.c:624:		host->flags |= HOST_F_STOP;
drivers/mmc/host/au1xmmc.c:626:	host->dma.dir = DMA_BIDIRECTIONAL;
drivers/mmc/host/au1xmmc.c:628:	host->dma.len = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/au1xmmc.c:629:				   data->sg_len, host->dma.dir);
drivers/mmc/host/au1xmmc.c:631:	if (host->dma.len == 0)
drivers/mmc/host/au1xmmc.c:636:	if (host->flags & HOST_F_DMA) {
drivers/mmc/host/au1xmmc.c:643:		for (i = 0; i < host->dma.len; i++) {
drivers/mmc/host/au1xmmc.c:650:			if (i == host->dma.len - 1)
drivers/mmc/host/au1xmmc.c:653:			if (host->flags & HOST_F_XMIT) {
drivers/mmc/host/au1xmmc.c:668:		host->pio.index = 0;
drivers/mmc/host/au1xmmc.c:669:		host->pio.offset = 0;
drivers/mmc/host/au1xmmc.c:670:		host->pio.len = datalen;
drivers/mmc/host/au1xmmc.c:672:		if (host->flags & HOST_F_XMIT)
drivers/mmc/host/au1xmmc.c:682:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/au1xmmc.c:683:			host->dma.dir);
drivers/mmc/host/au1xmmc.c:694:	WARN_ON(host->status != HOST_S_IDLE);
drivers/mmc/host/au1xmmc.c:696:	host->mrq = mrq;
drivers/mmc/host/au1xmmc.c:697:	host->status = HOST_S_CMD;
drivers/mmc/host/au1xmmc.c:762:	if (ios->clock && ios->clock != host->clock) {
drivers/mmc/host/au1xmmc.c:764:		host->clock = ios->clock;
drivers/mmc/host/au1xmmc.c:795:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/au1xmmc.c:797:	if (host->mrq && (status & STATUS_TIMEOUT)) {
drivers/mmc/host/au1xmmc.c:799:			host->mrq->cmd->error = -ETIMEDOUT;
drivers/mmc/host/au1xmmc.c:801:			host->mrq->data->error = -ETIMEDOUT;
drivers/mmc/host/au1xmmc.c:807:		tasklet_schedule(&host->finish_task);
drivers/mmc/host/au1xmmc.c:812:		if (!(host->flags & HOST_F_DMA) && (status & SD_STATUS_NE))
drivers/mmc/host/au1xmmc.c:816:			/* tasklet_schedule(&host->data_task); */
drivers/mmc/host/au1xmmc.c:821:		if (host->status == HOST_S_CMD)
drivers/mmc/host/au1xmmc.c:824:	} else if (!(host->flags & HOST_F_DMA)) {
drivers/mmc/host/au1xmmc.c:825:		if ((host->flags & HOST_F_XMIT) && (status & STATUS_DATA_OUT))
drivers/mmc/host/au1xmmc.c:827:		else if ((host->flags & HOST_F_RECV) && (status & STATUS_DATA_IN))
drivers/mmc/host/au1xmmc.c:831:			DBG("Unhandled status %8.8x\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:859:	if (!host->mrq)
drivers/mmc/host/au1xmmc.c:862:	if (host->flags & HOST_F_STOP)
drivers/mmc/host/au1xmmc.c:865:	tasklet_schedule(&host->data_task);
drivers/mmc/host/au1xmmc.c:873:	res = platform_get_resource(host->pdev, IORESOURCE_DMA, 0);
drivers/mmc/host/au1xmmc.c:878:	res = platform_get_resource(host->pdev, IORESOURCE_DMA, 1);
drivers/mmc/host/au1xmmc.c:886:	host->tx_chan = au1xxx_dbdma_chan_alloc(memid, txid,
drivers/mmc/host/au1xmmc.c:888:	if (!host->tx_chan) {
drivers/mmc/host/au1xmmc.c:889:		dev_err(&host->pdev->dev, "cannot allocate TX DMA\n");
drivers/mmc/host/au1xmmc.c:893:	host->rx_chan = au1xxx_dbdma_chan_alloc(rxid, memid,
drivers/mmc/host/au1xmmc.c:895:	if (!host->rx_chan) {
drivers/mmc/host/au1xmmc.c:896:		dev_err(&host->pdev->dev, "cannot allocate RX DMA\n");
drivers/mmc/host/au1xmmc.c:897:		au1xxx_dbdma_chan_free(host->tx_chan);
drivers/mmc/host/au1xmmc.c:901:	au1xxx_dbdma_set_devwidth(host->tx_chan, 8);
drivers/mmc/host/au1xmmc.c:902:	au1xxx_dbdma_set_devwidth(host->rx_chan, 8);
drivers/mmc/host/au1xmmc.c:904:	au1xxx_dbdma_ring_alloc(host->tx_chan, AU1XMMC_DESCRIPTOR_COUNT);
drivers/mmc/host/au1xmmc.c:905:	au1xxx_dbdma_ring_alloc(host->rx_chan, AU1XMMC_DESCRIPTOR_COUNT);
drivers/mmc/host/au1xmmc.c:908:	host->flags |= HOST_F_DMA;
drivers/mmc/host/au1xmmc.c:915:	if (host->flags & HOST_F_DMA) {
drivers/mmc/host/au1xmmc.c:916:		host->flags &= ~HOST_F_DMA;
drivers/mmc/host/au1xmmc.c:917:		au1xxx_dbdma_chan_free(host->tx_chan);
drivers/mmc/host/au1xmmc.c:918:		au1xxx_dbdma_chan_free(host->rx_chan);
drivers/mmc/host/au1xmmc.c:956:	host->mmc = mmc;
drivers/mmc/host/au1xmmc.c:957:	host->platdata = pdev->dev.platform_data;
drivers/mmc/host/au1xmmc.c:958:	host->pdev = pdev;
drivers/mmc/host/au1xmmc.c:967:	host->ioarea = request_mem_region(r->start, r->end - r->start + 1,
drivers/mmc/host/au1xmmc.c:969:	if (!host->ioarea) {
drivers/mmc/host/au1xmmc.c:974:	host->iobase = (unsigned long)ioremap(r->start, 0x3c);
drivers/mmc/host/au1xmmc.c:975:	if (!host->iobase) {
drivers/mmc/host/au1xmmc.c:986:	host->irq = r->start;
drivers/mmc/host/au1xmmc.c:988:	ret = request_irq(host->irq, au1xmmc_irq, IRQF_SHARED,
drivers/mmc/host/au1xmmc.c:1009:	host->status = HOST_S_IDLE;
drivers/mmc/host/au1xmmc.c:1012:	if (host->platdata && host->platdata->cd_setup) {
drivers/mmc/host/au1xmmc.c:1013:		ret = host->platdata->cd_setup(mmc, 1);
drivers/mmc/host/au1xmmc.c:1022:	if (host->platdata)
drivers/mmc/host/au1xmmc.c:1023:		mmc->caps &= ~(host->platdata->mask_host_caps);
drivers/mmc/host/au1xmmc.c:1025:	tasklet_init(&host->data_task, au1xmmc_tasklet_data,
drivers/mmc/host/au1xmmc.c:1028:	tasklet_init(&host->finish_task, au1xmmc_tasklet_finish,
drivers/mmc/host/au1xmmc.c:1038:	if (host->platdata && host->platdata->led) {
drivers/mmc/host/au1xmmc.c:1039:		struct led_classdev *led = host->platdata->led;
drivers/mmc/host/au1xmmc.c:1060:		" (mode=%s)\n", pdev->id, host->iobase,
drivers/mmc/host/au1xmmc.c:1061:		host->flags & HOST_F_DMA ? "dma" : "pio");
drivers/mmc/host/au1xmmc.c:1067:	if (host->platdata && host->platdata->led)
drivers/mmc/host/au1xmmc.c:1068:		led_classdev_unregister(host->platdata->led);
drivers/mmc/host/au1xmmc.c:1080:	tasklet_kill(&host->data_task);
drivers/mmc/host/au1xmmc.c:1081:	tasklet_kill(&host->finish_task);
drivers/mmc/host/au1xmmc.c:1083:	if (host->platdata && host->platdata->cd_setup &&
drivers/mmc/host/au1xmmc.c:1085:		host->platdata->cd_setup(mmc, 0);
drivers/mmc/host/au1xmmc.c:1087:	free_irq(host->irq, host);
drivers/mmc/host/au1xmmc.c:1089:	iounmap((void *)host->iobase);
drivers/mmc/host/au1xmmc.c:1091:	release_resource(host->ioarea);
drivers/mmc/host/au1xmmc.c:1092:	kfree(host->ioarea);
drivers/mmc/host/au1xmmc.c:1104:		mmc_remove_host(host->mmc);
drivers/mmc/host/au1xmmc.c:1107:		if (host->platdata && host->platdata->led)
drivers/mmc/host/au1xmmc.c:1108:			led_classdev_unregister(host->platdata->led);
drivers/mmc/host/au1xmmc.c:1111:		if (host->platdata && host->platdata->cd_setup &&
drivers/mmc/host/au1xmmc.c:1112:		    !(host->mmc->caps & MMC_CAP_NEEDS_POLL))
drivers/mmc/host/au1xmmc.c:1113:			host->platdata->cd_setup(host->mmc, 0);
drivers/mmc/host/au1xmmc.c:1120:		tasklet_kill(&host->data_task);
drivers/mmc/host/au1xmmc.c:1121:		tasklet_kill(&host->finish_task);
drivers/mmc/host/au1xmmc.c:1128:		free_irq(host->irq, host);
drivers/mmc/host/au1xmmc.c:1129:		iounmap((void *)host->iobase);
drivers/mmc/host/au1xmmc.c:1130:		release_resource(host->ioarea);
drivers/mmc/host/au1xmmc.c:1131:		kfree(host->ioarea);
drivers/mmc/host/au1xmmc.c:1133:		mmc_free_host(host->mmc);
drivers/mmc/host/au1xmmc.c:1145:	ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/au1xmmc.c:1164:	return mmc_resume_host(host->mmc);
drivers/mmc/host/sdhci-of-esdhc.c:44:		ret = in_be16(host->ioaddr + reg);
drivers/mmc/host/sdhci-of-esdhc.c:76:	clrbits32(host->ioaddr + ESDHC_SYSTEM_CONTROL, ESDHC_CLOCK_IPGEN |
drivers/mmc/host/sdhci-of-esdhc.c:82:	while (host->max_clk / pre_div / 16 > clock && pre_div < 256)
drivers/mmc/host/sdhci-of-esdhc.c:85:	while (host->max_clk / pre_div / div > clock && div < 16)
drivers/mmc/host/sdhci-of-esdhc.c:88:	dev_dbg(mmc_dev(host->mmc), "desired SD clock: %d, actual: %d\n",
drivers/mmc/host/sdhci-of-esdhc.c:89:		clock, host->max_clk / pre_div / div);
drivers/mmc/host/sdhci-of-esdhc.c:94:	setbits32(host->ioaddr + ESDHC_SYSTEM_CONTROL, ESDHC_CLOCK_IPGEN |
drivers/mmc/host/sdhci-of-esdhc.c:99:	host->clock = clock;
drivers/mmc/host/sdhci-of-esdhc.c:104:	setbits32(host->ioaddr + ESDHC_DMA_SYSCTL, ESDHC_DMA_SNOOP);
drivers/mmc/host/sdhci-of-esdhc.c:112:	return of_host->clock;
drivers/mmc/host/sdhci-of-esdhc.c:119:	return of_host->clock / 256 / 16;
Binary file drivers/mmc/host/built-in.o matches
drivers/mmc/host/atmel-mci.c:181: * @clock: Clock rate configured by set_ios(). Protected by host->lock.
drivers/mmc/host/atmel-mci.c:214:	test_and_clear_bit(event, &host->pending_events)
drivers/mmc/host/atmel-mci.c:216:	set_bit(event, &host->completed_events)
drivers/mmc/host/atmel-mci.c:218:	set_bit(event, &host->pending_events)
drivers/mmc/host/atmel-mci.c:258:	spin_lock_bh(&slot->host->lock);
drivers/mmc/host/atmel-mci.c:284:	spin_unlock_bh(&slot->host->lock);
drivers/mmc/host/atmel-mci.c:362:	spin_lock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:363:	clk_enable(host->mck);
drivers/mmc/host/atmel-mci.c:364:	memcpy_fromio(buf, host->regs, MCI_REGS_SIZE);
drivers/mmc/host/atmel-mci.c:365:	clk_disable(host->mck);
drivers/mmc/host/atmel-mci.c:366:	spin_unlock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:447:	node = debugfs_create_u32("state", S_IRUSR, root, (u32 *)&host->state);
drivers/mmc/host/atmel-mci.c:452:				     (u32 *)&host->pending_events);
drivers/mmc/host/atmel-mci.c:457:				     (u32 *)&host->completed_events);
drivers/mmc/host/atmel-mci.c:470:	return (ns * (host->bus_hz / 1000000) + 999) / 1000;
drivers/mmc/host/atmel-mci.c:552:	WARN_ON(host->cmd);
drivers/mmc/host/atmel-mci.c:553:	host->cmd = cmd;
drivers/mmc/host/atmel-mci.c:555:	dev_vdbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:565:	atmci_start_command(host, data->stop, host->stop_cmdr);
drivers/mmc/host/atmel-mci.c:572:	struct mmc_data			*data = host->data;
drivers/mmc/host/atmel-mci.c:575:		dma_unmap_sg(&host->pdev->dev, data->sg, data->sg_len,
drivers/mmc/host/atmel-mci.c:582:	struct dma_chan *chan = host->data_chan;
drivers/mmc/host/atmel-mci.c:598:	struct mmc_data		*data = host->data;
drivers/mmc/host/atmel-mci.c:600:	dev_vdbg(&host->pdev->dev, "DMA complete\n");
drivers/mmc/host/atmel-mci.c:614:		tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:666:	chan = host->dma.chan;
drivers/mmc/host/atmel-mci.c:668:		host->data_chan = chan;
drivers/mmc/host/atmel-mci.c:681:	sglen = dma_map_sg(&host->pdev->dev, data->sg, data->sg_len, direction);
drivers/mmc/host/atmel-mci.c:690:	host->dma.data_desc = desc;
drivers/mmc/host/atmel-mci.c:696:	dma_unmap_sg(&host->pdev->dev, data->sg, sglen, direction);
drivers/mmc/host/atmel-mci.c:702:	struct dma_chan			*chan = host->data_chan;
drivers/mmc/host/atmel-mci.c:703:	struct dma_async_tx_descriptor	*desc = host->dma.data_desc;
drivers/mmc/host/atmel-mci.c:739:	WARN_ON(host->data);
drivers/mmc/host/atmel-mci.c:740:	host->sg = NULL;
drivers/mmc/host/atmel-mci.c:741:	host->data = data;
drivers/mmc/host/atmel-mci.c:745:		host->data_chan = NULL;
drivers/mmc/host/atmel-mci.c:756:			host->need_reset = true;
drivers/mmc/host/atmel-mci.c:758:		host->sg = data->sg;
drivers/mmc/host/atmel-mci.c:759:		host->pio_offset = 0;
drivers/mmc/host/atmel-mci.c:779:	host->cur_slot = slot;
drivers/mmc/host/atmel-mci.c:780:	host->mrq = mrq;
drivers/mmc/host/atmel-mci.c:782:	host->pending_events = 0;
drivers/mmc/host/atmel-mci.c:783:	host->completed_events = 0;
drivers/mmc/host/atmel-mci.c:784:	host->data_status = 0;
drivers/mmc/host/atmel-mci.c:786:	if (host->need_reset) {
drivers/mmc/host/atmel-mci.c:789:		mci_writel(host, MR, host->mode_reg);
drivers/mmc/host/atmel-mci.c:791:			mci_writel(host, CFG, host->cfg_reg);
drivers/mmc/host/atmel-mci.c:792:		host->need_reset = false;
drivers/mmc/host/atmel-mci.c:830:		host->stop_cmdr = atmci_prepare_command(slot->mmc, mrq->stop);
drivers/mmc/host/atmel-mci.c:831:		host->stop_cmdr |= MCI_CMDR_STOP_XFER;
drivers/mmc/host/atmel-mci.c:833:			host->stop_cmdr |= MCI_CMDR_TRDIR_READ;
drivers/mmc/host/atmel-mci.c:835:			host->stop_cmdr |= MCI_CMDR_STREAM;
drivers/mmc/host/atmel-mci.c:837:			host->stop_cmdr |= MCI_CMDR_MULTI_BLOCK;
drivers/mmc/host/atmel-mci.c:853:			host->state);
drivers/mmc/host/atmel-mci.c:855:	spin_lock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:857:	if (host->state == STATE_IDLE) {
drivers/mmc/host/atmel-mci.c:858:		host->state = STATE_SENDING_CMD;
drivers/mmc/host/atmel-mci.c:861:		list_add_tail(&slot->queue_node, &host->queue);
drivers/mmc/host/atmel-mci.c:863:	spin_unlock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:918:		spin_lock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:919:		if (!host->mode_reg) {
drivers/mmc/host/atmel-mci.c:920:			clk_enable(host->mck);
drivers/mmc/host/atmel-mci.c:924:				mci_writel(host, CFG, host->cfg_reg);
drivers/mmc/host/atmel-mci.c:933:			if (host->slot[i] && host->slot[i]->clock
drivers/mmc/host/atmel-mci.c:934:					&& host->slot[i]->clock < clock_min)
drivers/mmc/host/atmel-mci.c:935:				clock_min = host->slot[i]->clock;
drivers/mmc/host/atmel-mci.c:939:		clkdiv = DIV_ROUND_UP(host->bus_hz, 2 * clock_min) - 1;
drivers/mmc/host/atmel-mci.c:943:				clock_min, host->bus_hz / (2 * 256));
drivers/mmc/host/atmel-mci.c:947:		host->mode_reg = MCI_MR_CLKDIV(clkdiv);
drivers/mmc/host/atmel-mci.c:955:			host->mode_reg |= (MCI_MR_WRPROOF | MCI_MR_RDPROOF);
drivers/mmc/host/atmel-mci.c:960:				host->cfg_reg |= MCI_CFG_HSMODE;
drivers/mmc/host/atmel-mci.c:962:				host->cfg_reg &= ~MCI_CFG_HSMODE;
drivers/mmc/host/atmel-mci.c:965:		if (list_empty(&host->queue)) {
drivers/mmc/host/atmel-mci.c:966:			mci_writel(host, MR, host->mode_reg);
drivers/mmc/host/atmel-mci.c:968:				mci_writel(host, CFG, host->cfg_reg);
drivers/mmc/host/atmel-mci.c:970:			host->need_clock_update = true;
drivers/mmc/host/atmel-mci.c:973:		spin_unlock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:977:		spin_lock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:980:			if (host->slot[i] && host->slot[i]->clock) {
drivers/mmc/host/atmel-mci.c:987:			if (host->mode_reg) {
drivers/mmc/host/atmel-mci.c:989:				clk_disable(host->mck);
drivers/mmc/host/atmel-mci.c:991:			host->mode_reg = 0;
drivers/mmc/host/atmel-mci.c:993:		spin_unlock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:1065:/* Called with host->lock held */
drivers/mmc/host/atmel-mci.c:1067:	__releases(&host->lock)
drivers/mmc/host/atmel-mci.c:1068:	__acquires(&host->lock)
drivers/mmc/host/atmel-mci.c:1071:	struct mmc_host		*prev_mmc = host->cur_slot->mmc;
drivers/mmc/host/atmel-mci.c:1073:	WARN_ON(host->cmd || host->data);
drivers/mmc/host/atmel-mci.c:1080:	if (host->need_clock_update) {
drivers/mmc/host/atmel-mci.c:1081:		mci_writel(host, MR, host->mode_reg);
drivers/mmc/host/atmel-mci.c:1083:			mci_writel(host, CFG, host->cfg_reg);
drivers/mmc/host/atmel-mci.c:1086:	host->cur_slot->mrq = NULL;
drivers/mmc/host/atmel-mci.c:1087:	host->mrq = NULL;
drivers/mmc/host/atmel-mci.c:1088:	if (!list_empty(&host->queue)) {
drivers/mmc/host/atmel-mci.c:1089:		slot = list_entry(host->queue.next,
drivers/mmc/host/atmel-mci.c:1092:		dev_vdbg(&host->pdev->dev, "list not empty: %s is next\n",
drivers/mmc/host/atmel-mci.c:1094:		host->state = STATE_SENDING_CMD;
drivers/mmc/host/atmel-mci.c:1097:		dev_vdbg(&host->pdev->dev, "list empty\n");
drivers/mmc/host/atmel-mci.c:1098:		host->state = STATE_IDLE;
drivers/mmc/host/atmel-mci.c:1101:	spin_unlock(&host->lock);
drivers/mmc/host/atmel-mci.c:1103:	spin_lock(&host->lock);
drivers/mmc/host/atmel-mci.c:1109:	u32		status = host->cmd_status;
drivers/mmc/host/atmel-mci.c:1127:		dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:1132:			host->data = NULL;
drivers/mmc/host/atmel-mci.c:1171:		spin_lock(&host->lock);
drivers/mmc/host/atmel-mci.c:1181:			if (mrq == host->mrq) {
drivers/mmc/host/atmel-mci.c:1188:				mci_writel(host, MR, host->mode_reg);
drivers/mmc/host/atmel-mci.c:1190:					mci_writel(host, CFG, host->cfg_reg);
drivers/mmc/host/atmel-mci.c:1192:				host->data = NULL;
drivers/mmc/host/atmel-mci.c:1193:				host->cmd = NULL;
drivers/mmc/host/atmel-mci.c:1195:				switch (host->state) {
drivers/mmc/host/atmel-mci.c:1228:				spin_unlock(&host->lock);
drivers/mmc/host/atmel-mci.c:1230:				spin_lock(&host->lock);
drivers/mmc/host/atmel-mci.c:1233:		spin_unlock(&host->lock);
drivers/mmc/host/atmel-mci.c:1242:	struct mmc_request	*mrq = host->mrq;
drivers/mmc/host/atmel-mci.c:1243:	struct mmc_data		*data = host->data;
drivers/mmc/host/atmel-mci.c:1244:	struct mmc_command	*cmd = host->cmd;
drivers/mmc/host/atmel-mci.c:1245:	enum atmel_mci_state	state = host->state;
drivers/mmc/host/atmel-mci.c:1249:	spin_lock(&host->lock);
drivers/mmc/host/atmel-mci.c:1251:	state = host->state;
drivers/mmc/host/atmel-mci.c:1253:	dev_vdbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:1255:		state, host->pending_events, host->completed_events,
drivers/mmc/host/atmel-mci.c:1270:			host->cmd = NULL;
drivers/mmc/host/atmel-mci.c:1274:				atmci_request_end(host, host->mrq);
drivers/mmc/host/atmel-mci.c:1304:			host->data = NULL;
drivers/mmc/host/atmel-mci.c:1306:			status = host->data_status;
drivers/mmc/host/atmel-mci.c:1309:					dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:1313:					dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:1317:					dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:1329:				atmci_request_end(host, host->mrq);
drivers/mmc/host/atmel-mci.c:1343:			host->cmd = NULL;
drivers/mmc/host/atmel-mci.c:1345:			atmci_request_end(host, host->mrq);
drivers/mmc/host/atmel-mci.c:1358:	host->state = state;
drivers/mmc/host/atmel-mci.c:1361:	spin_unlock(&host->lock);
drivers/mmc/host/atmel-mci.c:1366:	struct scatterlist	*sg = host->sg;
drivers/mmc/host/atmel-mci.c:1368:	unsigned int		offset = host->pio_offset;
drivers/mmc/host/atmel-mci.c:1369:	struct mmc_data		*data = host->data;
drivers/mmc/host/atmel-mci.c:1384:				host->sg = sg = sg_next(sg);
drivers/mmc/host/atmel-mci.c:1397:			host->sg = sg = sg_next(sg);
drivers/mmc/host/atmel-mci.c:1411:			host->data_status = status;
drivers/mmc/host/atmel-mci.c:1415:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:1420:	host->pio_offset = offset;
drivers/mmc/host/atmel-mci.c:1435:	struct scatterlist	*sg = host->sg;
drivers/mmc/host/atmel-mci.c:1437:	unsigned int		offset = host->pio_offset;
drivers/mmc/host/atmel-mci.c:1438:	struct mmc_data		*data = host->data;
drivers/mmc/host/atmel-mci.c:1451:				host->sg = sg = sg_next(sg);
drivers/mmc/host/atmel-mci.c:1465:			host->sg = sg = sg_next(sg);
drivers/mmc/host/atmel-mci.c:1482:			host->data_status = status;
drivers/mmc/host/atmel-mci.c:1486:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:1491:	host->pio_offset = offset;
drivers/mmc/host/atmel-mci.c:1508:	host->cmd_status = status;
drivers/mmc/host/atmel-mci.c:1511:	tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:1519:		struct atmel_mci_slot *slot = host->slot[i];
drivers/mmc/host/atmel-mci.c:1545:			host->data_status = status;
drivers/mmc/host/atmel-mci.c:1548:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:1553:			if (!host->data_status)
drivers/mmc/host/atmel-mci.c:1554:				host->data_status = status;
drivers/mmc/host/atmel-mci.c:1557:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:1597:	mmc = mmc_alloc_host(sizeof(struct atmel_mci_slot), &host->pdev->dev);
drivers/mmc/host/atmel-mci.c:1611:	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 512);
drivers/mmc/host/atmel-mci.c:1612:	mmc->f_max = host->bus_hz / 2;
drivers/mmc/host/atmel-mci.c:1649:	host->slot[id] = slot;
drivers/mmc/host/atmel-mci.c:1696:	slot->host->slot[id] = NULL;
drivers/mmc/host/atmel-mci.c:1720:	pdata = host->pdev->dev.platform_data;
drivers/mmc/host/atmel-mci.c:1726:			       host->mapbase + MCI_TDR,
drivers/mmc/host/atmel-mci.c:1727:			       host->mapbase + MCI_RDR);
drivers/mmc/host/atmel-mci.c:1732:		host->dma.chan =
drivers/mmc/host/atmel-mci.c:1735:	if (!host->dma.chan)
drivers/mmc/host/atmel-mci.c:1736:		dev_notice(&host->pdev->dev, "DMA not available, using PIO\n");
drivers/mmc/host/atmel-mci.c:1738:		dev_info(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:1740:					dma_chan_name(host->dma.chan));
drivers/mmc/host/atmel-mci.c:1769:	host->pdev = pdev;
drivers/mmc/host/atmel-mci.c:1770:	spin_lock_init(&host->lock);
drivers/mmc/host/atmel-mci.c:1771:	INIT_LIST_HEAD(&host->queue);
drivers/mmc/host/atmel-mci.c:1773:	host->mck = clk_get(&pdev->dev, "mci_clk");
drivers/mmc/host/atmel-mci.c:1774:	if (IS_ERR(host->mck)) {
drivers/mmc/host/atmel-mci.c:1775:		ret = PTR_ERR(host->mck);
drivers/mmc/host/atmel-mci.c:1780:	host->regs = ioremap(regs->start, regs->end - regs->start + 1);
drivers/mmc/host/atmel-mci.c:1781:	if (!host->regs)
drivers/mmc/host/atmel-mci.c:1784:	clk_enable(host->mck);
drivers/mmc/host/atmel-mci.c:1786:	host->bus_hz = clk_get_rate(host->mck);
drivers/mmc/host/atmel-mci.c:1787:	clk_disable(host->mck);
drivers/mmc/host/atmel-mci.c:1789:	host->mapbase = regs->start;
drivers/mmc/host/atmel-mci.c:1791:	tasklet_init(&host->tasklet, atmci_tasklet_func, (unsigned long)host);
drivers/mmc/host/atmel-mci.c:1824:			host->mapbase, irq, nr_slots);
drivers/mmc/host/atmel-mci.c:1830:	if (host->dma.chan)
drivers/mmc/host/atmel-mci.c:1831:		dma_release_channel(host->dma.chan);
drivers/mmc/host/atmel-mci.c:1835:	iounmap(host->regs);
drivers/mmc/host/atmel-mci.c:1837:	clk_put(host->mck);
drivers/mmc/host/atmel-mci.c:1851:		if (host->slot[i])
drivers/mmc/host/atmel-mci.c:1852:			atmci_cleanup_slot(host->slot[i], i);
drivers/mmc/host/atmel-mci.c:1855:	clk_enable(host->mck);
drivers/mmc/host/atmel-mci.c:1859:	clk_disable(host->mck);
drivers/mmc/host/atmel-mci.c:1862:	if (host->dma.chan)
drivers/mmc/host/atmel-mci.c:1863:		dma_release_channel(host->dma.chan);
drivers/mmc/host/atmel-mci.c:1867:	iounmap(host->regs);
drivers/mmc/host/atmel-mci.c:1869:	clk_put(host->mck);
Binary file drivers/mmc/host/sdhci.o matches
drivers/mmc/host/tmio_mmc.h:125:	return readw(host->ctl + (addr << host->bus_shift));
drivers/mmc/host/tmio_mmc.h:131:	readsw(host->ctl + (addr << host->bus_shift), buf, count);
drivers/mmc/host/tmio_mmc.h:136:	return readw(host->ctl + (addr << host->bus_shift)) |
drivers/mmc/host/tmio_mmc.h:137:	       readw(host->ctl + ((addr + 2) << host->bus_shift)) << 16;
drivers/mmc/host/tmio_mmc.h:143:	writew(val, host->ctl + (addr << host->bus_shift));
drivers/mmc/host/tmio_mmc.h:149:	writesw(host->ctl + (addr << host->bus_shift), buf, count);
drivers/mmc/host/tmio_mmc.h:155:	writew(val, host->ctl + (addr << host->bus_shift));
drivers/mmc/host/tmio_mmc.h:156:	writew(val >> 16, host->ctl + ((addr + 2) << host->bus_shift));
drivers/mmc/host/tmio_mmc.h:165:	host->sg_len = data->sg_len;
drivers/mmc/host/tmio_mmc.h:166:	host->sg_ptr = data->sg;
drivers/mmc/host/tmio_mmc.h:167:	host->sg_off = 0;
drivers/mmc/host/tmio_mmc.h:172:	host->sg_ptr = sg_next(host->sg_ptr);
drivers/mmc/host/tmio_mmc.h:173:	host->sg_off = 0;
drivers/mmc/host/tmio_mmc.h:174:	return --host->sg_len;
drivers/mmc/host/davinci_mmc.c:217:	host->buffer_bytes_left = sg_dma_len(host->sg);
drivers/mmc/host/davinci_mmc.c:218:	host->buffer = sg_virt(host->sg);
drivers/mmc/host/davinci_mmc.c:219:	if (host->buffer_bytes_left > host->bytes_left)
drivers/mmc/host/davinci_mmc.c:220:		host->buffer_bytes_left = host->bytes_left;
drivers/mmc/host/davinci_mmc.c:229:	if (host->buffer_bytes_left == 0) {
drivers/mmc/host/davinci_mmc.c:230:		host->sg = sg_next(host->data->sg);
drivers/mmc/host/davinci_mmc.c:234:	p = host->buffer;
drivers/mmc/host/davinci_mmc.c:235:	if (n > host->buffer_bytes_left)
drivers/mmc/host/davinci_mmc.c:236:		n = host->buffer_bytes_left;
drivers/mmc/host/davinci_mmc.c:237:	host->buffer_bytes_left -= n;
drivers/mmc/host/davinci_mmc.c:238:	host->bytes_left -= n;
drivers/mmc/host/davinci_mmc.c:244:	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
drivers/mmc/host/davinci_mmc.c:246:			writel(*((u32 *)p), host->base + DAVINCI_MMCDXR);
drivers/mmc/host/davinci_mmc.c:250:			iowrite8_rep(host->base + DAVINCI_MMCDXR, p, (n & 3));
drivers/mmc/host/davinci_mmc.c:255:			*((u32 *)p) = readl(host->base + DAVINCI_MMCDRR);
drivers/mmc/host/davinci_mmc.c:259:			ioread8_rep(host->base + DAVINCI_MMCDRR, p, (n & 3));
drivers/mmc/host/davinci_mmc.c:263:	host->buffer = p;
drivers/mmc/host/davinci_mmc.c:272:	dev_dbg(mmc_dev(host->mmc), "CMD%d, arg 0x%08x%s\n",
drivers/mmc/host/davinci_mmc.c:292:	host->cmd = cmd;
drivers/mmc/host/davinci_mmc.c:313:		dev_dbg(mmc_dev(host->mmc), "unknown resp_type %04x\n",
drivers/mmc/host/davinci_mmc.c:322:	if (host->do_dma)
drivers/mmc/host/davinci_mmc.c:325:	if (host->version == MMC_CTLR_VERSION_2 && host->data != NULL &&
drivers/mmc/host/davinci_mmc.c:326:			host->data_dir == DAVINCI_MMC_DATADIR_READ)
drivers/mmc/host/davinci_mmc.c:338:	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE)
drivers/mmc/host/davinci_mmc.c:341:	if (host->bus_mode == MMC_BUSMODE_PUSHPULL)
drivers/mmc/host/davinci_mmc.c:345:	writel(0x1FFF, host->base + DAVINCI_MMCTOR);
drivers/mmc/host/davinci_mmc.c:349:	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
drivers/mmc/host/davinci_mmc.c:352:		if (!host->do_dma)
drivers/mmc/host/davinci_mmc.c:354:	} else if (host->data_dir == DAVINCI_MMC_DATADIR_READ) {
drivers/mmc/host/davinci_mmc.c:357:		if (!host->do_dma)
drivers/mmc/host/davinci_mmc.c:365:	if (!host->do_dma && (host->data_dir == DAVINCI_MMC_DATADIR_WRITE))
drivers/mmc/host/davinci_mmc.c:368:	writel(cmd->arg, host->base + DAVINCI_MMCARGHL);
drivers/mmc/host/davinci_mmc.c:369:	writel(cmd_reg,  host->base + DAVINCI_MMCCMD);
drivers/mmc/host/davinci_mmc.c:370:	writel(im_val, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:381:	if (host->data_dir == DAVINCI_MMC_DATADIR_READ)
drivers/mmc/host/davinci_mmc.c:382:		sync_dev = host->rxdma;
drivers/mmc/host/davinci_mmc.c:384:		sync_dev = host->txdma;
drivers/mmc/host/davinci_mmc.c:402:		dev_warn(mmc_dev(host->mmc), "DMA %s error\n",
drivers/mmc/host/davinci_mmc.c:403:			(host->data->flags & MMC_DATA_WRITE)
drivers/mmc/host/davinci_mmc.c:405:		host->data->error = -EIO;
drivers/mmc/host/davinci_mmc.c:406:		mmc_davinci_xfer_done(host, host->data);
drivers/mmc/host/davinci_mmc.c:434:		sync_dev = host->txdma;
drivers/mmc/host/davinci_mmc.c:440:		dst_port = host->mem_res->start + DAVINCI_MMCDXR;
drivers/mmc/host/davinci_mmc.c:444:		sync_dev = host->rxdma;
drivers/mmc/host/davinci_mmc.c:446:		src_port = host->mem_res->start + DAVINCI_MMCDRR;
drivers/mmc/host/davinci_mmc.c:482:	unsigned		bytes_left = host->bytes_left;
drivers/mmc/host/davinci_mmc.c:485:	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
drivers/mmc/host/davinci_mmc.c:486:		template = &host->tx_template;
drivers/mmc/host/davinci_mmc.c:487:		channel = host->txdma;
drivers/mmc/host/davinci_mmc.c:489:		template = &host->rx_template;
drivers/mmc/host/davinci_mmc.c:490:		channel = host->rxdma;
drivers/mmc/host/davinci_mmc.c:499:	for (slot = channel, link = 0, sg = data->sg, sg_len = host->sg_len;
drivers/mmc/host/davinci_mmc.c:501:			sg = sg_next(sg), slot = host->links[link++]) {
drivers/mmc/host/davinci_mmc.c:506:				? (EDMA_CHAN_SLOT(host->links[link]) << 5)
drivers/mmc/host/davinci_mmc.c:513:		if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE)
drivers/mmc/host/davinci_mmc.c:522:	if (host->version == MMC_CTLR_VERSION_2)
drivers/mmc/host/davinci_mmc.c:534:	host->sg_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/davinci_mmc.c:540:	for (i = 0; i < host->sg_len; i++) {
drivers/mmc/host/davinci_mmc.c:542:			dma_unmap_sg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:551:	host->do_dma = 1;
drivers/mmc/host/davinci_mmc.c:562:	if (!host->use_dma)
drivers/mmc/host/davinci_mmc.c:565:	for (i = 0; i < host->n_link; i++)
drivers/mmc/host/davinci_mmc.c:566:		edma_free_slot(host->links[i]);
drivers/mmc/host/davinci_mmc.c:568:	edma_free_channel(host->txdma);
drivers/mmc/host/davinci_mmc.c:569:	edma_free_channel(host->rxdma);
drivers/mmc/host/davinci_mmc.c:578:	r = edma_alloc_channel(host->txdma, mmc_davinci_dma_cb, host,
drivers/mmc/host/davinci_mmc.c:581:		dev_warn(mmc_dev(host->mmc), "alloc %s channel err %d\n",
drivers/mmc/host/davinci_mmc.c:585:	mmc_davinci_dma_setup(host, true, &host->tx_template);
drivers/mmc/host/davinci_mmc.c:588:	r = edma_alloc_channel(host->rxdma, mmc_davinci_dma_cb, host,
drivers/mmc/host/davinci_mmc.c:591:		dev_warn(mmc_dev(host->mmc), "alloc %s channel err %d\n",
drivers/mmc/host/davinci_mmc.c:595:	mmc_davinci_dma_setup(host, false, &host->rx_template);
drivers/mmc/host/davinci_mmc.c:600:	link_size = min_t(unsigned, host->nr_sg, ARRAY_SIZE(host->links));
drivers/mmc/host/davinci_mmc.c:602:		r = edma_alloc_slot(EDMA_CTLR(host->txdma), EDMA_SLOT_ANY);
drivers/mmc/host/davinci_mmc.c:604:			dev_dbg(mmc_dev(host->mmc), "dma PaRAM alloc --> %d\n",
drivers/mmc/host/davinci_mmc.c:608:		host->links[i] = r;
drivers/mmc/host/davinci_mmc.c:610:	host->n_link = i;
drivers/mmc/host/davinci_mmc.c:615:	edma_free_channel(host->txdma);
drivers/mmc/host/davinci_mmc.c:629:	if (host->version == MMC_CTLR_VERSION_2)
drivers/mmc/host/davinci_mmc.c:632:	host->data = data;
drivers/mmc/host/davinci_mmc.c:634:		host->data_dir = DAVINCI_MMC_DATADIR_NONE;
drivers/mmc/host/davinci_mmc.c:635:		writel(0, host->base + DAVINCI_MMCBLEN);
drivers/mmc/host/davinci_mmc.c:636:		writel(0, host->base + DAVINCI_MMCNBLK);
drivers/mmc/host/davinci_mmc.c:640:	dev_dbg(mmc_dev(host->mmc), "%s %s, %d blocks of %d bytes\n",
drivers/mmc/host/davinci_mmc.c:644:	dev_dbg(mmc_dev(host->mmc), "  DTO %d cycles + %d ns\n",
drivers/mmc/host/davinci_mmc.c:647:		(data->timeout_ns / host->ns_in_one_cycle);
drivers/mmc/host/davinci_mmc.c:651:	writel(timeout, host->base + DAVINCI_MMCTOD);
drivers/mmc/host/davinci_mmc.c:652:	writel(data->blocks, host->base + DAVINCI_MMCNBLK);
drivers/mmc/host/davinci_mmc.c:653:	writel(data->blksz, host->base + DAVINCI_MMCBLEN);
drivers/mmc/host/davinci_mmc.c:658:		host->data_dir = DAVINCI_MMC_DATADIR_WRITE;
drivers/mmc/host/davinci_mmc.c:660:			host->base + DAVINCI_MMCFIFOCTL);
drivers/mmc/host/davinci_mmc.c:662:			host->base + DAVINCI_MMCFIFOCTL);
drivers/mmc/host/davinci_mmc.c:666:		host->data_dir = DAVINCI_MMC_DATADIR_READ;
drivers/mmc/host/davinci_mmc.c:668:			host->base + DAVINCI_MMCFIFOCTL);
drivers/mmc/host/davinci_mmc.c:670:			host->base + DAVINCI_MMCFIFOCTL);
drivers/mmc/host/davinci_mmc.c:674:	host->buffer = NULL;
drivers/mmc/host/davinci_mmc.c:675:	host->bytes_left = data->blocks * data->blksz;
drivers/mmc/host/davinci_mmc.c:685:	if (host->use_dma && (host->bytes_left & (rw_threshold - 1)) == 0
drivers/mmc/host/davinci_mmc.c:688:		host->bytes_left = 0;
drivers/mmc/host/davinci_mmc.c:691:		host->sg_len = data->sg_len;
drivers/mmc/host/davinci_mmc.c:692:		host->sg = host->data->sg;
drivers/mmc/host/davinci_mmc.c:707:		mmcst1  = readl(host->base + DAVINCI_MMCST1);
drivers/mmc/host/davinci_mmc.c:713:		dev_err(mmc_dev(host->mmc), "still BUSY? bad ... \n");
drivers/mmc/host/davinci_mmc.c:719:	host->do_dma = 0;
drivers/mmc/host/davinci_mmc.c:729:	mmc_pclk = host->mmc_input_clk;
drivers/mmc/host/davinci_mmc.c:743:		host->ns_in_one_cycle = (1000000) / (((mmc_pclk
drivers/mmc/host/davinci_mmc.c:746:		host->ns_in_one_cycle = (1000000) / (((mmc_pclk
drivers/mmc/host/davinci_mmc.c:770:		temp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKRT_MASK;
drivers/mmc/host/davinci_mmc.c:772:		writel(temp, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:775:		host->ns_in_one_cycle = (1000000) / (MMCSD_INIT_CLOCK/1000);
drivers/mmc/host/davinci_mmc.c:783:		temp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKEN;
drivers/mmc/host/davinci_mmc.c:784:		writel(temp, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:788:		temp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKRT_MASK;
drivers/mmc/host/davinci_mmc.c:790:		writel(temp, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:792:		writel(temp | MMCCLK_CLKEN, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:802:	dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:809:		dev_dbg(mmc_dev(host->mmc), "Enabling 8 bit mode\n");
drivers/mmc/host/davinci_mmc.c:810:		writel((readl(host->base + DAVINCI_MMCCTL) &
drivers/mmc/host/davinci_mmc.c:812:			host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:815:		dev_dbg(mmc_dev(host->mmc), "Enabling 4 bit mode\n");
drivers/mmc/host/davinci_mmc.c:816:		if (host->version == MMC_CTLR_VERSION_2)
drivers/mmc/host/davinci_mmc.c:817:			writel((readl(host->base + DAVINCI_MMCCTL) &
drivers/mmc/host/davinci_mmc.c:819:				host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:821:			writel(readl(host->base + DAVINCI_MMCCTL) |
drivers/mmc/host/davinci_mmc.c:823:				host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:826:		dev_dbg(mmc_dev(host->mmc), "Enabling 1 bit mode\n");
drivers/mmc/host/davinci_mmc.c:827:		if (host->version == MMC_CTLR_VERSION_2)
drivers/mmc/host/davinci_mmc.c:828:			writel(readl(host->base + DAVINCI_MMCCTL) &
drivers/mmc/host/davinci_mmc.c:830:				host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:832:			writel(readl(host->base + DAVINCI_MMCCTL) &
drivers/mmc/host/davinci_mmc.c:834:				host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:840:	host->bus_mode = ios->bus_mode;
drivers/mmc/host/davinci_mmc.c:846:		writel(0, host->base + DAVINCI_MMCARGHL);
drivers/mmc/host/davinci_mmc.c:847:		writel(MMCCMD_INITCK, host->base + DAVINCI_MMCCMD);
drivers/mmc/host/davinci_mmc.c:849:			u32 tmp = readl(host->base + DAVINCI_MMCST0);
drivers/mmc/host/davinci_mmc.c:858:			dev_warn(mmc_dev(host->mmc), "powerup timeout\n");
drivers/mmc/host/davinci_mmc.c:867:	host->data = NULL;
drivers/mmc/host/davinci_mmc.c:869:	if (host->do_dma) {
drivers/mmc/host/davinci_mmc.c:872:		dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/davinci_mmc.c:876:		host->do_dma = false;
drivers/mmc/host/davinci_mmc.c:878:	host->data_dir = DAVINCI_MMC_DATADIR_NONE;
drivers/mmc/host/davinci_mmc.c:880:	if (!data->stop || (host->cmd && host->cmd->error)) {
drivers/mmc/host/davinci_mmc.c:881:		mmc_request_done(host->mmc, data->mrq);
drivers/mmc/host/davinci_mmc.c:882:		writel(0, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:890:	host->cmd = NULL;
drivers/mmc/host/davinci_mmc.c:895:			cmd->resp[3] = readl(host->base + DAVINCI_MMCRSP01);
drivers/mmc/host/davinci_mmc.c:896:			cmd->resp[2] = readl(host->base + DAVINCI_MMCRSP23);
drivers/mmc/host/davinci_mmc.c:897:			cmd->resp[1] = readl(host->base + DAVINCI_MMCRSP45);
drivers/mmc/host/davinci_mmc.c:898:			cmd->resp[0] = readl(host->base + DAVINCI_MMCRSP67);
drivers/mmc/host/davinci_mmc.c:901:			cmd->resp[0] = readl(host->base + DAVINCI_MMCRSP67);
drivers/mmc/host/davinci_mmc.c:905:	if (host->data == NULL || cmd->error) {
drivers/mmc/host/davinci_mmc.c:908:		mmc_request_done(host->mmc, cmd->mrq);
drivers/mmc/host/davinci_mmc.c:909:		writel(0, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:918:	temp = readl(host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:924:	writel(temp, host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:941:	struct mmc_data *data = host->data;
drivers/mmc/host/davinci_mmc.c:943:	if (host->cmd == NULL && host->data == NULL) {
drivers/mmc/host/davinci_mmc.c:944:		status = readl(host->base + DAVINCI_MMCST0);
drivers/mmc/host/davinci_mmc.c:945:		dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:948:		writel(0, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:952:	status = readl(host->base + DAVINCI_MMCST0);
drivers/mmc/host/davinci_mmc.c:962:	while (host->bytes_left && (status & (MMCST0_DXRDY | MMCST0_DRRDY))) {
drivers/mmc/host/davinci_mmc.c:964:		status = readl(host->base + DAVINCI_MMCST0);
drivers/mmc/host/davinci_mmc.c:973:			if ((host->do_dma == 0) && (host->bytes_left > 0)) {
drivers/mmc/host/davinci_mmc.c:977:				davinci_fifo_data_trans(host, host->bytes_left);
drivers/mmc/host/davinci_mmc.c:982:			dev_err(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:983:					"DATDNE with no host->data\n");
drivers/mmc/host/davinci_mmc.c:992:		dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:1011:			u32 temp = readb(host->base + DAVINCI_MMCDRSP);
drivers/mmc/host/davinci_mmc.c:1016:		dev_dbg(mmc_dev(host->mmc), "data %s %s error\n",
drivers/mmc/host/davinci_mmc.c:1025:		if (host->cmd) {
drivers/mmc/host/davinci_mmc.c:1026:			dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:1028:				host->cmd->opcode, qstatus);
drivers/mmc/host/davinci_mmc.c:1029:			host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/davinci_mmc.c:1040:		dev_dbg(mmc_dev(host->mmc), "Command CRC error\n");
drivers/mmc/host/davinci_mmc.c:1041:		if (host->cmd) {
drivers/mmc/host/davinci_mmc.c:1042:			host->cmd->error = -EILSEQ;
drivers/mmc/host/davinci_mmc.c:1049:		end_command = (int) host->cmd;
drivers/mmc/host/davinci_mmc.c:1053:		mmc_davinci_cmd_done(host, host->cmd);
drivers/mmc/host/davinci_mmc.c:1098:	mmc = host->mmc;
drivers/mmc/host/davinci_mmc.c:1099:	mmc_pclk = clk_get_rate(host->clk);
drivers/mmc/host/davinci_mmc.c:1103:		host->mmc_input_clk = mmc_pclk;
drivers/mmc/host/davinci_mmc.c:1113:	host->freq_transition.notifier_call = mmc_davinci_cpufreq_transition;
drivers/mmc/host/davinci_mmc.c:1115:	return cpufreq_register_notifier(&host->freq_transition,
drivers/mmc/host/davinci_mmc.c:1121:	cpufreq_unregister_notifier(&host->freq_transition,
drivers/mmc/host/davinci_mmc.c:1139:	writel(0, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:1140:	writel(MMCCLK_CLKEN, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:1142:	writel(0x1FFF, host->base + DAVINCI_MMCTOR);
drivers/mmc/host/davinci_mmc.c:1143:	writel(0xFFFF, host->base + DAVINCI_MMCTOD);
drivers/mmc/host/davinci_mmc.c:1177:	host->mmc = mmc;	/* Important */
drivers/mmc/host/davinci_mmc.c:1182:	host->rxdma = r->start;
drivers/mmc/host/davinci_mmc.c:1187:	host->txdma = r->start;
drivers/mmc/host/davinci_mmc.c:1189:	host->mem_res = mem;
drivers/mmc/host/davinci_mmc.c:1190:	host->base = ioremap(mem->start, mem_size);
drivers/mmc/host/davinci_mmc.c:1191:	if (!host->base)
drivers/mmc/host/davinci_mmc.c:1195:	host->clk = clk_get(&pdev->dev, "MMCSDCLK");
drivers/mmc/host/davinci_mmc.c:1196:	if (IS_ERR(host->clk)) {
drivers/mmc/host/davinci_mmc.c:1197:		ret = PTR_ERR(host->clk);
drivers/mmc/host/davinci_mmc.c:1200:	clk_enable(host->clk);
drivers/mmc/host/davinci_mmc.c:1201:	host->mmc_input_clk = clk_get_rate(host->clk);
drivers/mmc/host/davinci_mmc.c:1206:		host->nr_sg = pdata->nr_sg - 1;
drivers/mmc/host/davinci_mmc.c:1208:	if (host->nr_sg > MAX_NR_SG || !host->nr_sg)
drivers/mmc/host/davinci_mmc.c:1209:		host->nr_sg = MAX_NR_SG;
drivers/mmc/host/davinci_mmc.c:1211:	host->use_dma = use_dma;
drivers/mmc/host/davinci_mmc.c:1212:	host->irq = irq;
drivers/mmc/host/davinci_mmc.c:1214:	if (host->use_dma && davinci_acquire_dma_channels(host) != 0)
drivers/mmc/host/davinci_mmc.c:1215:		host->use_dma = 0;
drivers/mmc/host/davinci_mmc.c:1227:	host->version = pdata->version;
drivers/mmc/host/davinci_mmc.c:1242:	mmc->max_hw_segs	= 1 + host->n_link;
drivers/mmc/host/davinci_mmc.c:1253:	dev_dbg(mmc_dev(host->mmc), "max_phys_segs=%d\n", mmc->max_phys_segs);
drivers/mmc/host/davinci_mmc.c:1254:	dev_dbg(mmc_dev(host->mmc), "max_hw_segs=%d\n", mmc->max_hw_segs);
drivers/mmc/host/davinci_mmc.c:1255:	dev_dbg(mmc_dev(host->mmc), "max_blk_size=%d\n", mmc->max_blk_size);
drivers/mmc/host/davinci_mmc.c:1256:	dev_dbg(mmc_dev(host->mmc), "max_req_size=%d\n", mmc->max_req_size);
drivers/mmc/host/davinci_mmc.c:1257:	dev_dbg(mmc_dev(host->mmc), "max_seg_size=%d\n", mmc->max_seg_size);
drivers/mmc/host/davinci_mmc.c:1277:	dev_info(mmc_dev(host->mmc), "Using %s, %d-bit mode\n",
drivers/mmc/host/davinci_mmc.c:1278:		host->use_dma ? "DMA" : "PIO",
drivers/mmc/host/davinci_mmc.c:1289:		if (host->clk) {
drivers/mmc/host/davinci_mmc.c:1290:			clk_disable(host->clk);
drivers/mmc/host/davinci_mmc.c:1291:			clk_put(host->clk);
drivers/mmc/host/davinci_mmc.c:1294:		if (host->base)
drivers/mmc/host/davinci_mmc.c:1295:			iounmap(host->base);
drivers/mmc/host/davinci_mmc.c:1317:		mmc_remove_host(host->mmc);
drivers/mmc/host/davinci_mmc.c:1318:		free_irq(host->irq, host);
drivers/mmc/host/davinci_mmc.c:1322:		clk_disable(host->clk);
drivers/mmc/host/davinci_mmc.c:1323:		clk_put(host->clk);
drivers/mmc/host/davinci_mmc.c:1325:		iounmap(host->base);
drivers/mmc/host/davinci_mmc.c:1327:		release_resource(host->mem_res);
drivers/mmc/host/davinci_mmc.c:1329:		mmc_free_host(host->mmc);
drivers/mmc/host/davinci_mmc.c:1342:	mmc_host_enable(host->mmc);
drivers/mmc/host/davinci_mmc.c:1343:	ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/davinci_mmc.c:1345:		writel(0, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:1347:		mmc_host_disable(host->mmc);
drivers/mmc/host/davinci_mmc.c:1348:		clk_disable(host->clk);
drivers/mmc/host/davinci_mmc.c:1349:		host->suspended = 1;
drivers/mmc/host/davinci_mmc.c:1351:		host->suspended = 0;
drivers/mmc/host/davinci_mmc.c:1352:		mmc_host_disable(host->mmc);
drivers/mmc/host/davinci_mmc.c:1364:	if (!host->suspended)
drivers/mmc/host/davinci_mmc.c:1367:	clk_enable(host->clk);
drivers/mmc/host/davinci_mmc.c:1368:	mmc_host_enable(host->mmc);
drivers/mmc/host/davinci_mmc.c:1371:	ret = mmc_resume_host(host->mmc);
drivers/mmc/host/davinci_mmc.c:1373:		host->suspended = 0;
drivers/mmc/host/s3cmci.c:56:		dev_err(&host->pdev->dev, args);  \
drivers/mmc/host/s3cmci.c:58:		dev_info(&host->pdev->dev, args); \
drivers/mmc/host/s3cmci.c:60:		dev_dbg(&host->pdev->dev, args);  \
drivers/mmc/host/s3cmci.c:78:	con 	= readl(host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:79:	pre 	= readl(host->base + S3C2410_SDIPRE);
drivers/mmc/host/s3cmci.c:80:	cmdarg 	= readl(host->base + S3C2410_SDICMDARG);
drivers/mmc/host/s3cmci.c:81:	cmdcon 	= readl(host->base + S3C2410_SDICMDCON);
drivers/mmc/host/s3cmci.c:82:	cmdsta 	= readl(host->base + S3C2410_SDICMDSTAT);
drivers/mmc/host/s3cmci.c:83:	r0 	= readl(host->base + S3C2410_SDIRSP0);
drivers/mmc/host/s3cmci.c:84:	r1 	= readl(host->base + S3C2410_SDIRSP1);
drivers/mmc/host/s3cmci.c:85:	r2 	= readl(host->base + S3C2410_SDIRSP2);
drivers/mmc/host/s3cmci.c:86:	r3 	= readl(host->base + S3C2410_SDIRSP3);
drivers/mmc/host/s3cmci.c:87:	timer 	= readl(host->base + S3C2410_SDITIMER);
drivers/mmc/host/s3cmci.c:88:	bsize 	= readl(host->base + S3C2410_SDIBSIZE);
drivers/mmc/host/s3cmci.c:89:	datcon 	= readl(host->base + S3C2410_SDIDCON);
drivers/mmc/host/s3cmci.c:90:	datcnt 	= readl(host->base + S3C2410_SDIDCNT);
drivers/mmc/host/s3cmci.c:91:	datsta 	= readl(host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:92:	fsta 	= readl(host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:93:	imask   = readl(host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:113:	snprintf(host->dbgmsg_cmd, 300,
drivers/mmc/host/s3cmci.c:115:		 host->ccnt, (stop ? " (STOP)" : ""),
drivers/mmc/host/s3cmci.c:119:		snprintf(host->dbgmsg_dat, 300,
drivers/mmc/host/s3cmci.c:121:			 host->dcnt, cmd->data->blksz,
drivers/mmc/host/s3cmci.c:125:		host->dbgmsg_dat[0] = '\0';
drivers/mmc/host/s3cmci.c:139:			host->dbgmsg_cmd, cmd->resp[0]);
drivers/mmc/host/s3cmci.c:142:			cmd->error, host->dbgmsg_cmd, host->status);
drivers/mmc/host/s3cmci.c:149:		dbg(host, dbglvl, "DAT[OK] %s\n", host->dbgmsg_dat);
drivers/mmc/host/s3cmci.c:152:			cmd->data->error, host->dbgmsg_dat,
drivers/mmc/host/s3cmci.c:153:			readl(host->base + S3C2410_SDIDCNT));
drivers/mmc/host/s3cmci.c:182:	return host->dodma;
drivers/mmc/host/s3cmci.c:205:	newmask = readl(host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:208:	writel(newmask, host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:217:	newmask = readl(host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:220:	writel(newmask, host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:227:	u32 mask = readl(host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:231:	writel(mask, host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:248:	if (host->sdio_irqen) {
drivers/mmc/host/s3cmci.c:251:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/s3cmci.c:261:	if (host->pio_active == XFER_NONE)
drivers/mmc/host/s3cmci.c:264:	if ((!host->mrq) || (!host->mrq->data))
drivers/mmc/host/s3cmci.c:267:	if (host->pio_sgptr >= host->mrq->data->sg_len) {
drivers/mmc/host/s3cmci.c:269:		      host->pio_sgptr, host->mrq->data->sg_len);
drivers/mmc/host/s3cmci.c:272:	sg = &host->mrq->data->sg[host->pio_sgptr];
drivers/mmc/host/s3cmci.c:277:	host->pio_sgptr++;
drivers/mmc/host/s3cmci.c:280:	    host->pio_sgptr, host->mrq->data->sg_len);
drivers/mmc/host/s3cmci.c:287:	u32 fifostat = readl(host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:295:	u32 fifostat = readl(host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:321:	host->irq_enabled = more;
drivers/mmc/host/s3cmci.c:322:	host->irq_disabled = false;
drivers/mmc/host/s3cmci.c:324:	enable = more | host->sdio_irqen;
drivers/mmc/host/s3cmci.c:326:	if (host->irq_state != enable) {
drivers/mmc/host/s3cmci.c:327:		host->irq_state = enable;
drivers/mmc/host/s3cmci.c:330:			enable_irq(host->irq);
drivers/mmc/host/s3cmci.c:332:			disable_irq(host->irq);
drivers/mmc/host/s3cmci.c:349:	host->irq_disabled = transfer;
drivers/mmc/host/s3cmci.c:351:	if (transfer && host->irq_state) {
drivers/mmc/host/s3cmci.c:352:		host->irq_state = false;
drivers/mmc/host/s3cmci.c:353:		disable_irq(host->irq);
drivers/mmc/host/s3cmci.c:368:	writel(host->prescaler, host->base + S3C2410_SDIPRE);
drivers/mmc/host/s3cmci.c:370:	from_ptr = host->base + host->sdidata;
drivers/mmc/host/s3cmci.c:373:		if (!host->pio_bytes) {
drivers/mmc/host/s3cmci.c:374:			res = get_data_buffer(host, &host->pio_bytes,
drivers/mmc/host/s3cmci.c:375:					      &host->pio_ptr);
drivers/mmc/host/s3cmci.c:377:				host->pio_active = XFER_NONE;
drivers/mmc/host/s3cmci.c:378:				host->complete_what = COMPLETION_FINALIZE;
drivers/mmc/host/s3cmci.c:387:			    host->pio_bytes, host->pio_ptr);
drivers/mmc/host/s3cmci.c:392:		    fifo, host->pio_bytes,
drivers/mmc/host/s3cmci.c:393:		    readl(host->base + S3C2410_SDIDCNT));
drivers/mmc/host/s3cmci.c:400:		if (fifo >= host->pio_bytes)
drivers/mmc/host/s3cmci.c:401:			fifo = host->pio_bytes;
drivers/mmc/host/s3cmci.c:405:		host->pio_bytes -= fifo;
drivers/mmc/host/s3cmci.c:406:		host->pio_count += fifo;
drivers/mmc/host/s3cmci.c:409:		ptr = host->pio_ptr;
drivers/mmc/host/s3cmci.c:412:		host->pio_ptr = ptr;
drivers/mmc/host/s3cmci.c:417:			u8 *p = (u8 *)host->pio_ptr;
drivers/mmc/host/s3cmci.c:426:	if (!host->pio_bytes) {
drivers/mmc/host/s3cmci.c:427:		res = get_data_buffer(host, &host->pio_bytes, &host->pio_ptr);
drivers/mmc/host/s3cmci.c:431:			host->pio_active = XFER_NONE;
drivers/mmc/host/s3cmci.c:432:			host->complete_what = COMPLETION_FINALIZE;
drivers/mmc/host/s3cmci.c:449:	to_ptr = host->base + host->sdidata;
drivers/mmc/host/s3cmci.c:452:		if (!host->pio_bytes) {
drivers/mmc/host/s3cmci.c:453:			res = get_data_buffer(host, &host->pio_bytes,
drivers/mmc/host/s3cmci.c:454:							&host->pio_ptr);
drivers/mmc/host/s3cmci.c:458:				host->pio_active = XFER_NONE;
drivers/mmc/host/s3cmci.c:465:			    host->pio_bytes, host->pio_ptr);
drivers/mmc/host/s3cmci.c:473:		if (fifo >= host->pio_bytes)
drivers/mmc/host/s3cmci.c:474:			fifo = host->pio_bytes;
drivers/mmc/host/s3cmci.c:478:		host->pio_bytes -= fifo;
drivers/mmc/host/s3cmci.c:479:		host->pio_count += fifo;
drivers/mmc/host/s3cmci.c:482:		ptr = host->pio_ptr;
drivers/mmc/host/s3cmci.c:485:		host->pio_ptr = ptr;
drivers/mmc/host/s3cmci.c:497:	if (host->pio_active == XFER_WRITE)
drivers/mmc/host/s3cmci.c:500:	if (host->pio_active == XFER_READ)
drivers/mmc/host/s3cmci.c:503:	if (host->complete_what == COMPLETION_FINALIZE) {
drivers/mmc/host/s3cmci.c:505:		if (host->pio_active != XFER_NONE) {
drivers/mmc/host/s3cmci.c:508:			    (host->pio_active == XFER_READ) ? "read" : "write",
drivers/mmc/host/s3cmci.c:509:			    host->pio_count, host->pio_bytes);
drivers/mmc/host/s3cmci.c:511:			if (host->mrq->data)
drivers/mmc/host/s3cmci.c:512:				host->mrq->data->error = -EINVAL;
drivers/mmc/host/s3cmci.c:524: *   host->mrq 			points to current request
drivers/mmc/host/s3cmci.c:525: *   host->complete_what	Indicates when the request is considered done
drivers/mmc/host/s3cmci.c:530: *   host->complete_request	is the completion-object the driver waits for
drivers/mmc/host/s3cmci.c:532: * 1) Driver sets up host->mrq and host->complete_what
drivers/mmc/host/s3cmci.c:536: * 5) Driver waits for host->complete_rquest
drivers/mmc/host/s3cmci.c:538: * 6) ISR sets host->mrq->cmd->error and host->mrq->data->error
drivers/mmc/host/s3cmci.c:539: * 7) ISR completes host->complete_request
drivers/mmc/host/s3cmci.c:556:	mci_dsta = readl(host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:557:	mci_imsk = readl(host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:562:			writel(mci_dclear, host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:564:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/s3cmci.c:569:	spin_lock_irqsave(&host->complete_lock, iflags);
drivers/mmc/host/s3cmci.c:571:	mci_csta = readl(host->base + S3C2410_SDICMDSTAT);
drivers/mmc/host/s3cmci.c:572:	mci_dcnt = readl(host->base + S3C2410_SDIDCNT);
drivers/mmc/host/s3cmci.c:573:	mci_fsta = readl(host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:576:	if ((host->complete_what == COMPLETION_NONE) ||
drivers/mmc/host/s3cmci.c:577:	    (host->complete_what == COMPLETION_FINALIZE)) {
drivers/mmc/host/s3cmci.c:578:		host->status = "nothing to complete";
drivers/mmc/host/s3cmci.c:583:	if (!host->mrq) {
drivers/mmc/host/s3cmci.c:584:		host->status = "no active mrq";
drivers/mmc/host/s3cmci.c:589:	cmd = host->cmd_is_stop ? host->mrq->stop : host->mrq->cmd;
drivers/mmc/host/s3cmci.c:592:		host->status = "no active cmd";
drivers/mmc/host/s3cmci.c:598:		if ((host->pio_active == XFER_WRITE) &&
drivers/mmc/host/s3cmci.c:602:			tasklet_schedule(&host->pio_tasklet);
drivers/mmc/host/s3cmci.c:603:			host->status = "pio tx";
drivers/mmc/host/s3cmci.c:606:		if ((host->pio_active == XFER_READ) &&
drivers/mmc/host/s3cmci.c:613:			tasklet_schedule(&host->pio_tasklet);
drivers/mmc/host/s3cmci.c:614:			host->status = "pio rx";
drivers/mmc/host/s3cmci.c:621:		host->status = "error: command timeout";
drivers/mmc/host/s3cmci.c:626:		if (host->complete_what == COMPLETION_CMDSENT) {
drivers/mmc/host/s3cmci.c:627:			host->status = "ok: command sent";
drivers/mmc/host/s3cmci.c:636:			if (host->mrq->cmd->flags & MMC_RSP_136) {
drivers/mmc/host/s3cmci.c:645:				 * host->status = "error: bad command crc";
drivers/mmc/host/s3cmci.c:655:		if (host->complete_what == COMPLETION_RSPFIN) {
drivers/mmc/host/s3cmci.c:656:			host->status = "ok: command response received";
drivers/mmc/host/s3cmci.c:660:		if (host->complete_what == COMPLETION_XFERFINISH_RSPFIN)
drivers/mmc/host/s3cmci.c:661:			host->complete_what = COMPLETION_XFERFINISH;
drivers/mmc/host/s3cmci.c:673:	if (host->is2440) {
drivers/mmc/host/s3cmci.c:676:			host->mrq->data->error = -EILSEQ;
drivers/mmc/host/s3cmci.c:677:			host->status = "error: 2440 fifo failure";
drivers/mmc/host/s3cmci.c:684:			host->status = "error:  fifo failure";
drivers/mmc/host/s3cmci.c:692:		host->status = "error: bad data crc (outgoing)";
drivers/mmc/host/s3cmci.c:699:		host->status = "error: bad data crc (incoming)";
drivers/mmc/host/s3cmci.c:706:		host->status = "error: data timeout";
drivers/mmc/host/s3cmci.c:711:		if (host->complete_what == COMPLETION_XFERFINISH) {
drivers/mmc/host/s3cmci.c:712:			host->status = "ok: data transfer completed";
drivers/mmc/host/s3cmci.c:716:		if (host->complete_what == COMPLETION_XFERFINISH_RSPFIN)
drivers/mmc/host/s3cmci.c:717:			host->complete_what = COMPLETION_RSPFIN;
drivers/mmc/host/s3cmci.c:723:	writel(mci_cclear, host->base + S3C2410_SDICMDSTAT);
drivers/mmc/host/s3cmci.c:724:	writel(mci_dclear, host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:729:	host->pio_active = XFER_NONE;
drivers/mmc/host/s3cmci.c:732:	host->complete_what = COMPLETION_FINALIZE;
drivers/mmc/host/s3cmci.c:735:	tasklet_schedule(&host->pio_tasklet);
drivers/mmc/host/s3cmci.c:742:	    mci_csta, mci_dsta, mci_fsta, mci_dcnt, host->status);
drivers/mmc/host/s3cmci.c:744:	spin_unlock_irqrestore(&host->complete_lock, iflags);
drivers/mmc/host/s3cmci.c:759:	mmc_detect_change(host->mmc, msecs_to_jiffies(500));
drivers/mmc/host/s3cmci.c:772:	mci_csta = readl(host->base + S3C2410_SDICMDSTAT);
drivers/mmc/host/s3cmci.c:773:	mci_dsta = readl(host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:774:	mci_fsta = readl(host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:775:	mci_dcnt = readl(host->base + S3C2410_SDIDCNT);
drivers/mmc/host/s3cmci.c:777:	BUG_ON(!host->mrq);
drivers/mmc/host/s3cmci.c:778:	BUG_ON(!host->mrq->data);
drivers/mmc/host/s3cmci.c:779:	BUG_ON(!host->dmatogo);
drivers/mmc/host/s3cmci.c:781:	spin_lock_irqsave(&host->complete_lock, iflags);
drivers/mmc/host/s3cmci.c:787:			mci_dcnt, result, host->dmatogo);
drivers/mmc/host/s3cmci.c:792:	host->dmatogo--;
drivers/mmc/host/s3cmci.c:793:	if (host->dmatogo) {
drivers/mmc/host/s3cmci.c:796:			size, mci_dsta, mci_dcnt, host->dmatogo);
drivers/mmc/host/s3cmci.c:804:	host->dma_complete = 1;
drivers/mmc/host/s3cmci.c:805:	host->complete_what = COMPLETION_FINALIZE;
drivers/mmc/host/s3cmci.c:808:	tasklet_schedule(&host->pio_tasklet);
drivers/mmc/host/s3cmci.c:809:	spin_unlock_irqrestore(&host->complete_lock, iflags);
drivers/mmc/host/s3cmci.c:813:	host->mrq->data->error = -EINVAL;
drivers/mmc/host/s3cmci.c:814:	host->complete_what = COMPLETION_FINALIZE;
drivers/mmc/host/s3cmci.c:822:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/s3cmci.c:826:	if (host->complete_what != COMPLETION_FINALIZE)
drivers/mmc/host/s3cmci.c:831:	cmd = host->cmd_is_stop ? mrq->stop : mrq->cmd;
drivers/mmc/host/s3cmci.c:835:		if (s3cmci_host_usedma(host) && (!host->dma_complete)) {
drivers/mmc/host/s3cmci.c:837:			    host->dma_complete);
drivers/mmc/host/s3cmci.c:843:	cmd->resp[0] = readl(host->base + S3C2410_SDIRSP0);
drivers/mmc/host/s3cmci.c:844:	cmd->resp[1] = readl(host->base + S3C2410_SDIRSP1);
drivers/mmc/host/s3cmci.c:845:	cmd->resp[2] = readl(host->base + S3C2410_SDIRSP2);
drivers/mmc/host/s3cmci.c:846:	cmd->resp[3] = readl(host->base + S3C2410_SDIRSP3);
drivers/mmc/host/s3cmci.c:848:	writel(host->prescaler, host->base + S3C2410_SDIPRE);
drivers/mmc/host/s3cmci.c:859:	writel(0, host->base + S3C2410_SDICMDARG);
drivers/mmc/host/s3cmci.c:860:	writel(S3C2410_SDIDCON_STOP, host->base + S3C2410_SDIDCON);
drivers/mmc/host/s3cmci.c:861:	writel(0, host->base + S3C2410_SDICMDCON);
drivers/mmc/host/s3cmci.c:867:	if (cmd->data && cmd->data->stop && (!host->cmd_is_stop)) {
drivers/mmc/host/s3cmci.c:868:		host->cmd_is_stop = 1;
drivers/mmc/host/s3cmci.c:869:		s3cmci_send_request(host->mmc);
drivers/mmc/host/s3cmci.c:889:			s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);
drivers/mmc/host/s3cmci.c:891:		if (host->is2440) {
drivers/mmc/host/s3cmci.c:895:			       host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:900:			mci_con = readl(host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:903:			writel(mci_con, host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:908:	host->complete_what = COMPLETION_NONE;
drivers/mmc/host/s3cmci.c:909:	host->mrq = NULL;
drivers/mmc/host/s3cmci.c:912:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/s3cmci.c:926:	s3c2410_dma_devconfig(host->dma, source,
drivers/mmc/host/s3cmci.c:927:			      host->mem->start + host->sdidata);
drivers/mmc/host/s3cmci.c:930:		s3c2410_dma_config(host->dma, 4);
drivers/mmc/host/s3cmci.c:931:		s3c2410_dma_set_buffdone_fn(host->dma,
drivers/mmc/host/s3cmci.c:933:		s3c2410_dma_setflags(host->dma, S3C2410_DMAF_AUTOSTART);
drivers/mmc/host/s3cmci.c:950:		host->complete_what = COMPLETION_XFERFINISH_RSPFIN;
drivers/mmc/host/s3cmci.c:952:		host->complete_what = COMPLETION_RSPFIN;
drivers/mmc/host/s3cmci.c:954:		host->complete_what = COMPLETION_CMDSENT;
drivers/mmc/host/s3cmci.c:956:	writel(cmd->arg, host->base + S3C2410_SDICMDARG);
drivers/mmc/host/s3cmci.c:967:	writel(ccon, host->base + S3C2410_SDICMDCON);
drivers/mmc/host/s3cmci.c:977:		writel(0, host->base + S3C2410_SDIDCON);
drivers/mmc/host/s3cmci.c:991:	while (readl(host->base + S3C2410_SDIDSTA) &
drivers/mmc/host/s3cmci.c:997:		writel(S3C2410_SDIDCON_STOP, host->base + S3C2410_SDIDCON);
drivers/mmc/host/s3cmci.c:1011:	if (host->bus_width == MMC_BUS_WIDTH_4)
drivers/mmc/host/s3cmci.c:1027:	if (host->is2440) {
drivers/mmc/host/s3cmci.c:1032:	writel(dcon, host->base + S3C2410_SDIDCON);
drivers/mmc/host/s3cmci.c:1036:	writel(data->blksz, host->base + S3C2410_SDIBSIZE);
drivers/mmc/host/s3cmci.c:1046:	if (host->is2440) {
drivers/mmc/host/s3cmci.c:1047:		writel(0x007FFFFF, host->base + S3C2410_SDITIMER);
drivers/mmc/host/s3cmci.c:1049:		writel(0x0000FFFF, host->base + S3C2410_SDITIMER);
drivers/mmc/host/s3cmci.c:1053:			writel(0xFF, host->base + S3C2410_SDIPRE);
drivers/mmc/host/s3cmci.c:1067:	host->pio_sgptr = 0;
drivers/mmc/host/s3cmci.c:1068:	host->pio_bytes = 0;
drivers/mmc/host/s3cmci.c:1069:	host->pio_count = 0;
drivers/mmc/host/s3cmci.c:1070:	host->pio_active = rw ? XFER_WRITE : XFER_READ;
drivers/mmc/host/s3cmci.c:1091:	s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);
drivers/mmc/host/s3cmci.c:1093:	dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/s3cmci.c:1099:	host->dma_complete = 0;
drivers/mmc/host/s3cmci.c:1100:	host->dmatogo = dma_len;
drivers/mmc/host/s3cmci.c:1109:		res = s3c2410_dma_enqueue(host->dma, host,
drivers/mmc/host/s3cmci.c:1114:			s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);
drivers/mmc/host/s3cmci.c:1119:	s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_START);
drivers/mmc/host/s3cmci.c:1127:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/s3cmci.c:1128:	struct mmc_command *cmd = host->cmd_is_stop ? mrq->stop : mrq->cmd;
drivers/mmc/host/s3cmci.c:1130:	host->ccnt++;
drivers/mmc/host/s3cmci.c:1131:	prepare_dbgmsg(host, cmd, host->cmd_is_stop);
drivers/mmc/host/s3cmci.c:1136:	writel(0xFFFFFFFF, host->base + S3C2410_SDICMDSTAT);
drivers/mmc/host/s3cmci.c:1137:	writel(0xFFFFFFFF, host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:1138:	writel(0xFFFFFFFF, host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:1143:		host->dcnt++;
drivers/mmc/host/s3cmci.c:1179:	struct s3c24xx_mci_pdata *pdata = host->pdata;
drivers/mmc/host/s3cmci.c:1193:	host->status = "mmc request";
drivers/mmc/host/s3cmci.c:1194:	host->cmd_is_stop = 0;
drivers/mmc/host/s3cmci.c:1195:	host->mrq = mrq;
drivers/mmc/host/s3cmci.c:1199:		host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/s3cmci.c:1211:		host->real_rate = host->clk_rate / (host->clk_div*(mci_psc+1));
drivers/mmc/host/s3cmci.c:1213:		if (host->real_rate <= ios->clock)
drivers/mmc/host/s3cmci.c:1220:	host->prescaler = mci_psc;
drivers/mmc/host/s3cmci.c:1221:	writel(host->prescaler, host->base + S3C2410_SDIPRE);
drivers/mmc/host/s3cmci.c:1225:		host->real_rate = 0;
drivers/mmc/host/s3cmci.c:1235:	mci_con = readl(host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:1247:		if (host->pdata->set_power)
drivers/mmc/host/s3cmci.c:1248:			host->pdata->set_power(ios->power_mode, ios->vdd);
drivers/mmc/host/s3cmci.c:1250:		if (!host->is2440)
drivers/mmc/host/s3cmci.c:1259:		if (host->is2440)
drivers/mmc/host/s3cmci.c:1262:		if (host->pdata->set_power)
drivers/mmc/host/s3cmci.c:1263:			host->pdata->set_power(ios->power_mode, ios->vdd);
drivers/mmc/host/s3cmci.c:1276:	writel(mci_con, host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:1281:			host->real_rate/1000, ios->clock/1000);
drivers/mmc/host/s3cmci.c:1286:	host->bus_width = ios->bus_width;
drivers/mmc/host/s3cmci.c:1291:	u32 con = readl(host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:1294:	writel(con, host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:1300:	struct s3c24xx_mci_pdata *pdata = host->pdata;
drivers/mmc/host/s3cmci.c:1320:	con = readl(host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:1321:	host->sdio_irqen = enable;
drivers/mmc/host/s3cmci.c:1323:	if (enable == host->sdio_irqen)
drivers/mmc/host/s3cmci.c:1330:		if (!host->irq_state && !host->irq_disabled) {
drivers/mmc/host/s3cmci.c:1331:			host->irq_state = true;
drivers/mmc/host/s3cmci.c:1332:			enable_irq(host->irq);
drivers/mmc/host/s3cmci.c:1338:		if (!host->irq_enabled && host->irq_state) {
drivers/mmc/host/s3cmci.c:1339:			disable_irq_nosync(host->irq);
drivers/mmc/host/s3cmci.c:1340:			host->irq_state = false;
drivers/mmc/host/s3cmci.c:1344:	writel(con, host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:1361:	/* This is currently here to avoid a number of if (host->pdata)
drivers/mmc/host/s3cmci.c:1378:	newclk = clk_get_rate(host->clk);
drivers/mmc/host/s3cmci.c:1379:	mmc = host->mmc;
drivers/mmc/host/s3cmci.c:1381:	if ((val == CPUFREQ_PRECHANGE && newclk > host->clk_rate) ||
drivers/mmc/host/s3cmci.c:1382:	    (val == CPUFREQ_POSTCHANGE && newclk < host->clk_rate)) {
drivers/mmc/host/s3cmci.c:1385:		host->clk_rate = newclk;
drivers/mmc/host/s3cmci.c:1399:	host->freq_transition.notifier_call = s3cmci_cpufreq_transition;
drivers/mmc/host/s3cmci.c:1401:	return cpufreq_register_notifier(&host->freq_transition,
drivers/mmc/host/s3cmci.c:1407:	cpufreq_unregister_notifier(&host->freq_transition,
drivers/mmc/host/s3cmci.c:1429:	seq_printf(seq, "Register base = 0x%08x\n", (u32)host->base);
drivers/mmc/host/s3cmci.c:1430:	seq_printf(seq, "Clock rate = %ld\n", host->clk_rate);
drivers/mmc/host/s3cmci.c:1431:	seq_printf(seq, "Prescale = %d\n", host->prescaler);
drivers/mmc/host/s3cmci.c:1432:	seq_printf(seq, "is2440 = %d\n", host->is2440);
drivers/mmc/host/s3cmci.c:1433:	seq_printf(seq, "IRQ = %d\n", host->irq);
drivers/mmc/host/s3cmci.c:1434:	seq_printf(seq, "IRQ enabled = %d\n", host->irq_enabled);
drivers/mmc/host/s3cmci.c:1435:	seq_printf(seq, "IRQ disabled = %d\n", host->irq_disabled);
drivers/mmc/host/s3cmci.c:1436:	seq_printf(seq, "IRQ state = %d\n", host->irq_state);
drivers/mmc/host/s3cmci.c:1437:	seq_printf(seq, "CD IRQ = %d\n", host->irq_cd);
drivers/mmc/host/s3cmci.c:1439:	seq_printf(seq, "SDIIMSK at %d\n", host->sdiimsk);
drivers/mmc/host/s3cmci.c:1440:	seq_printf(seq, "SDIDATA at %d\n", host->sdidata);
drivers/mmc/host/s3cmci.c:1489:			   readl(host->base + rptr->addr));
drivers/mmc/host/s3cmci.c:1491:	seq_printf(seq, "SDIIMSK\t=0x%08x\n", readl(host->base + host->sdiimsk));
drivers/mmc/host/s3cmci.c:1511:	struct device *dev = &host->pdev->dev;
drivers/mmc/host/s3cmci.c:1513:	host->debug_root = debugfs_create_dir(dev_name(dev), NULL);
drivers/mmc/host/s3cmci.c:1514:	if (IS_ERR(host->debug_root)) {
drivers/mmc/host/s3cmci.c:1519:	host->debug_state = debugfs_create_file("state", 0444,
drivers/mmc/host/s3cmci.c:1520:						host->debug_root, host,
drivers/mmc/host/s3cmci.c:1523:	if (IS_ERR(host->debug_state))
drivers/mmc/host/s3cmci.c:1526:	host->debug_regs = debugfs_create_file("regs", 0444,
drivers/mmc/host/s3cmci.c:1527:					       host->debug_root, host,
drivers/mmc/host/s3cmci.c:1530:	if (IS_ERR(host->debug_regs))
drivers/mmc/host/s3cmci.c:1536:	debugfs_remove(host->debug_regs);
drivers/mmc/host/s3cmci.c:1537:	debugfs_remove(host->debug_state);
drivers/mmc/host/s3cmci.c:1538:	debugfs_remove(host->debug_root);
drivers/mmc/host/s3cmci.c:1576:	host->mmc 	= mmc;
drivers/mmc/host/s3cmci.c:1577:	host->pdev	= pdev;
drivers/mmc/host/s3cmci.c:1578:	host->is2440	= is2440;
drivers/mmc/host/s3cmci.c:1580:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/s3cmci.c:1581:	if (!host->pdata) {
drivers/mmc/host/s3cmci.c:1583:		host->pdata = &s3cmci_def_pdata;
drivers/mmc/host/s3cmci.c:1586:	spin_lock_init(&host->complete_lock);
drivers/mmc/host/s3cmci.c:1587:	tasklet_init(&host->pio_tasklet, pio_tasklet, (unsigned long) host);
drivers/mmc/host/s3cmci.c:1590:		host->sdiimsk	= S3C2440_SDIIMSK;
drivers/mmc/host/s3cmci.c:1591:		host->sdidata	= S3C2440_SDIDATA;
drivers/mmc/host/s3cmci.c:1592:		host->clk_div	= 1;
drivers/mmc/host/s3cmci.c:1594:		host->sdiimsk	= S3C2410_SDIIMSK;
drivers/mmc/host/s3cmci.c:1595:		host->sdidata	= S3C2410_SDIDATA;
drivers/mmc/host/s3cmci.c:1596:		host->clk_div	= 2;
drivers/mmc/host/s3cmci.c:1599:	host->complete_what 	= COMPLETION_NONE;
drivers/mmc/host/s3cmci.c:1600:	host->pio_active 	= XFER_NONE;
drivers/mmc/host/s3cmci.c:1603:	host->dodma		= host->pdata->dma;
drivers/mmc/host/s3cmci.c:1606:	host->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
drivers/mmc/host/s3cmci.c:1607:	if (!host->mem) {
drivers/mmc/host/s3cmci.c:1615:	host->mem = request_mem_region(host->mem->start,
drivers/mmc/host/s3cmci.c:1616:				       resource_size(host->mem), pdev->name);
drivers/mmc/host/s3cmci.c:1618:	if (!host->mem) {
drivers/mmc/host/s3cmci.c:1624:	host->base = ioremap(host->mem->start, resource_size(host->mem));
drivers/mmc/host/s3cmci.c:1625:	if (!host->base) {
drivers/mmc/host/s3cmci.c:1631:	host->irq = platform_get_irq(pdev, 0);
drivers/mmc/host/s3cmci.c:1632:	if (host->irq == 0) {
drivers/mmc/host/s3cmci.c:1638:	if (request_irq(host->irq, s3cmci_irq, 0, DRIVER_NAME, host)) {
drivers/mmc/host/s3cmci.c:1648:	disable_irq(host->irq);
drivers/mmc/host/s3cmci.c:1649:	host->irq_state = false;
drivers/mmc/host/s3cmci.c:1651:	if (!host->pdata->no_detect) {
drivers/mmc/host/s3cmci.c:1652:		ret = gpio_request(host->pdata->gpio_detect, "s3cmci detect");
drivers/mmc/host/s3cmci.c:1658:		host->irq_cd = gpio_to_irq(host->pdata->gpio_detect);
drivers/mmc/host/s3cmci.c:1660:		if (host->irq_cd >= 0) {
drivers/mmc/host/s3cmci.c:1661:			if (request_irq(host->irq_cd, s3cmci_irq_cd,
drivers/mmc/host/s3cmci.c:1673:			gpio_direction_input(host->pdata->gpio_detect);
drivers/mmc/host/s3cmci.c:1676:		host->irq_cd = -1;
drivers/mmc/host/s3cmci.c:1678:	if (!host->pdata->no_wprotect) {
drivers/mmc/host/s3cmci.c:1679:		ret = gpio_request(host->pdata->gpio_wprotect, "s3cmci wp");
drivers/mmc/host/s3cmci.c:1685:		gpio_direction_input(host->pdata->gpio_wprotect);
drivers/mmc/host/s3cmci.c:1691:		host->dma = s3c2410_dma_request(DMACH_SDI, &s3cmci_dma_client,
drivers/mmc/host/s3cmci.c:1693:		if (host->dma < 0) {
drivers/mmc/host/s3cmci.c:1700:				host->dodma = 0;
drivers/mmc/host/s3cmci.c:1705:	host->clk = clk_get(&pdev->dev, "sdi");
drivers/mmc/host/s3cmci.c:1706:	if (IS_ERR(host->clk)) {
drivers/mmc/host/s3cmci.c:1708:		ret = PTR_ERR(host->clk);
drivers/mmc/host/s3cmci.c:1709:		host->clk = NULL;
drivers/mmc/host/s3cmci.c:1713:	ret = clk_enable(host->clk);
drivers/mmc/host/s3cmci.c:1719:	host->clk_rate = clk_get_rate(host->clk);
drivers/mmc/host/s3cmci.c:1728:	mmc->f_min 	= host->clk_rate / (host->clk_div * 256);
drivers/mmc/host/s3cmci.c:1729:	mmc->f_max 	= host->clk_rate / host->clk_div;
drivers/mmc/host/s3cmci.c:1731:	if (host->pdata->ocr_avail)
drivers/mmc/host/s3cmci.c:1732:		mmc->ocr_avail = host->pdata->ocr_avail;
drivers/mmc/host/s3cmci.c:1744:	    (host->is2440?"2440":""),
drivers/mmc/host/s3cmci.c:1745:	    host->base, host->irq, host->irq_cd, host->dma);
drivers/mmc/host/s3cmci.c:1772:	clk_disable(host->clk);
drivers/mmc/host/s3cmci.c:1775:	clk_put(host->clk);
drivers/mmc/host/s3cmci.c:1779:		s3c2410_dma_free(host->dma, &s3cmci_dma_client);
drivers/mmc/host/s3cmci.c:1782:	if (!host->pdata->no_wprotect)
drivers/mmc/host/s3cmci.c:1783:		gpio_free(host->pdata->gpio_wprotect);
drivers/mmc/host/s3cmci.c:1786:	if (!host->pdata->no_detect)
drivers/mmc/host/s3cmci.c:1787:		gpio_free(host->pdata->gpio_detect);
drivers/mmc/host/s3cmci.c:1790:	if (host->irq_cd >= 0)
drivers/mmc/host/s3cmci.c:1791:		free_irq(host->irq_cd, host);
drivers/mmc/host/s3cmci.c:1794:	free_irq(host->irq, host);
drivers/mmc/host/s3cmci.c:1797:	iounmap(host->base);
drivers/mmc/host/s3cmci.c:1800:	release_mem_region(host->mem->start, resource_size(host->mem));
drivers/mmc/host/s3cmci.c:1819:	if (host->irq_cd >= 0)
drivers/mmc/host/s3cmci.c:1820:		free_irq(host->irq_cd, host);
drivers/mmc/host/s3cmci.c:1825:	clk_disable(host->clk);
drivers/mmc/host/s3cmci.c:1832:	struct s3c24xx_mci_pdata *pd = host->pdata;
drivers/mmc/host/s3cmci.c:1837:	clk_put(host->clk);
drivers/mmc/host/s3cmci.c:1839:	tasklet_disable(&host->pio_tasklet);
drivers/mmc/host/s3cmci.c:1842:		s3c2410_dma_free(host->dma, &s3cmci_dma_client);
drivers/mmc/host/s3cmci.c:1844:	free_irq(host->irq, host);
drivers/mmc/host/s3cmci.c:1856:	iounmap(host->base);
drivers/mmc/host/s3cmci.c:1857:	release_mem_region(host->mem->start, resource_size(host->mem));
drivers/mmc/host/omap.c:180:	if (slot != NULL && slot->host->fclk_enabled && slot->fclk_freq > 0) {
drivers/mmc/host/omap.c:190:	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/host/omap.c:191:	if (host->fclk_enabled != enable) {
drivers/mmc/host/omap.c:192:		host->fclk_enabled = enable;
drivers/mmc/host/omap.c:194:			clk_enable(host->fclk);
drivers/mmc/host/omap.c:196:			clk_disable(host->fclk);
drivers/mmc/host/omap.c:198:	spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/host/omap.c:208:	spin_lock_irqsave(&host->slot_lock, flags);
drivers/mmc/host/omap.c:209:	while (host->mmc != NULL) {
drivers/mmc/host/omap.c:210:		spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:211:		wait_event(host->slot_wq, host->mmc == NULL);
drivers/mmc/host/omap.c:212:		spin_lock_irqsave(&host->slot_lock, flags);
drivers/mmc/host/omap.c:214:	host->mmc = slot->mmc;
drivers/mmc/host/omap.c:215:	spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:217:	del_timer(&host->clk_timer);
drivers/mmc/host/omap.c:218:	if (host->current_slot != slot || !claimed)
drivers/mmc/host/omap.c:219:		mmc_omap_fclk_offdelay(host->current_slot);
drivers/mmc/host/omap.c:221:	if (host->current_slot != slot) {
drivers/mmc/host/omap.c:223:		if (host->pdata->switch_slot != NULL)
drivers/mmc/host/omap.c:224:			host->pdata->switch_slot(mmc_dev(slot->mmc), slot->id);
drivers/mmc/host/omap.c:225:		host->current_slot = slot;
drivers/mmc/host/omap.c:248:	struct mmc_omap_slot *next_slot = host->next_slot;
drivers/mmc/host/omap.c:251:	host->next_slot = NULL;
drivers/mmc/host/omap.c:265:	BUG_ON(slot == NULL || host->mmc == NULL);
drivers/mmc/host/omap.c:269:		mod_timer(&host->clk_timer, jiffies  + HZ/10);
drivers/mmc/host/omap.c:271:		del_timer(&host->clk_timer);
drivers/mmc/host/omap.c:276:	spin_lock_irqsave(&host->slot_lock, flags);
drivers/mmc/host/omap.c:278:	for (i = 0; i < host->nr_slots; i++) {
drivers/mmc/host/omap.c:281:		if (host->slots[i] == NULL || host->slots[i]->mrq == NULL)
drivers/mmc/host/omap.c:284:		BUG_ON(host->next_slot != NULL);
drivers/mmc/host/omap.c:285:		new_slot = host->slots[i];
drivers/mmc/host/omap.c:287:		BUG_ON(new_slot == host->current_slot);
drivers/mmc/host/omap.c:289:		host->next_slot = new_slot;
drivers/mmc/host/omap.c:290:		host->mmc = new_slot->mmc;
drivers/mmc/host/omap.c:291:		spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:292:		schedule_work(&host->slot_release_work);
drivers/mmc/host/omap.c:296:	host->mmc = NULL;
drivers/mmc/host/omap.c:297:	wake_up(&host->slot_wq);
drivers/mmc/host/omap.c:298:	spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:342:	host->cmd = cmd;
drivers/mmc/host/omap.c:363:		dev_err(mmc_dev(host->mmc), "Invalid response type: %04x\n", mmc_resp_type(cmd));
drivers/mmc/host/omap.c:379:	if (host->current_slot->bus_mode == MMC_BUSMODE_OPENDRAIN)
drivers/mmc/host/omap.c:385:	if (host->data && !(host->data->flags & MMC_DATA_WRITE))
drivers/mmc/host/omap.c:388:	mod_timer(&host->cmd_abort_timer, jiffies + HZ/2);
drivers/mmc/host/omap.c:408:	BUG_ON(host->dma_ch < 0);
drivers/mmc/host/omap.c:410:		omap_stop_dma(host->dma_ch);
drivers/mmc/host/omap.c:412:	mod_timer(&host->dma_timer, jiffies + HZ);
drivers/mmc/host/omap.c:417:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_len,
drivers/mmc/host/omap.c:425:	struct mmc_omap_slot *slot = host->current_slot;
drivers/mmc/host/omap.c:426:	struct mmc_data *data = host->stop_data;
drivers/mmc/host/omap.c:438:	if (host->dma_in_use)
drivers/mmc/host/omap.c:441:	host->data = NULL;
drivers/mmc/host/omap.c:442:	host->sg_len = 0;
drivers/mmc/host/omap.c:452:		host->mrq = NULL;
drivers/mmc/host/omap.c:453:		mmc = host->mmc;
drivers/mmc/host/omap.c:454:		mmc_omap_release_slot(host->current_slot, 1);
drivers/mmc/host/omap.c:459:	host->stop_data = data;
drivers/mmc/host/omap.c:460:	schedule_work(&host->send_stop_work);
drivers/mmc/host/omap.c:466:	struct mmc_omap_slot *slot = host->current_slot;
drivers/mmc/host/omap.c:495:	if (host->dma_in_use)
drivers/mmc/host/omap.c:498:	host->data = NULL;
drivers/mmc/host/omap.c:499:	host->sg_len = 0;
drivers/mmc/host/omap.c:510:	if (!host->dma_in_use) {
drivers/mmc/host/omap.c:515:	spin_lock_irqsave(&host->dma_lock, flags);
drivers/mmc/host/omap.c:516:	if (host->dma_done)
drivers/mmc/host/omap.c:519:		host->brs_received = 1;
drivers/mmc/host/omap.c:520:	spin_unlock_irqrestore(&host->dma_lock, flags);
drivers/mmc/host/omap.c:530:	BUG_ON(host->dma_ch < 0);
drivers/mmc/host/omap.c:531:	omap_free_dma(host->dma_ch);
drivers/mmc/host/omap.c:532:	host->dma_ch = -1;
drivers/mmc/host/omap.c:542:	spin_lock_irqsave(&host->dma_lock, flags);
drivers/mmc/host/omap.c:543:	if (host->brs_received)
drivers/mmc/host/omap.c:546:		host->dma_done = 1;
drivers/mmc/host/omap.c:547:	spin_unlock_irqrestore(&host->dma_lock, flags);
drivers/mmc/host/omap.c:555:	host->cmd = NULL;
drivers/mmc/host/omap.c:557:	del_timer(&host->cmd_abort_timer);
drivers/mmc/host/omap.c:582:	if (host->data == NULL || cmd->error) {
drivers/mmc/host/omap.c:585:		if (host->data != NULL)
drivers/mmc/host/omap.c:586:			mmc_omap_abort_xfer(host, host->data);
drivers/mmc/host/omap.c:587:		host->mrq = NULL;
drivers/mmc/host/omap.c:588:		mmc = host->mmc;
drivers/mmc/host/omap.c:589:		mmc_omap_release_slot(host->current_slot, 1);
drivers/mmc/host/omap.c:602:	BUG_ON(!host->cmd);
drivers/mmc/host/omap.c:604:	dev_dbg(mmc_dev(host->mmc), "Aborting stuck command CMD%d\n",
drivers/mmc/host/omap.c:605:		host->cmd->opcode);
drivers/mmc/host/omap.c:607:	if (host->cmd->error == 0)
drivers/mmc/host/omap.c:608:		host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/omap.c:610:	if (host->data == NULL) {
drivers/mmc/host/omap.c:614:		cmd = host->cmd;
drivers/mmc/host/omap.c:615:		host->cmd = NULL;
drivers/mmc/host/omap.c:618:		host->mrq = NULL;
drivers/mmc/host/omap.c:619:		mmc = host->mmc;
drivers/mmc/host/omap.c:620:		mmc_omap_release_slot(host->current_slot, 1);
drivers/mmc/host/omap.c:623:		mmc_omap_cmd_done(host, host->cmd);
drivers/mmc/host/omap.c:625:	host->abort = 0;
drivers/mmc/host/omap.c:626:	enable_irq(host->irq);
drivers/mmc/host/omap.c:635:	spin_lock_irqsave(&host->slot_lock, flags);
drivers/mmc/host/omap.c:636:	if (host->cmd != NULL && !host->abort) {
drivers/mmc/host/omap.c:638:		disable_irq(host->irq);
drivers/mmc/host/omap.c:639:		host->abort = 1;
drivers/mmc/host/omap.c:640:		schedule_work(&host->cmd_abort_work);
drivers/mmc/host/omap.c:642:	spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:651:	sg = host->data->sg + host->sg_idx;
drivers/mmc/host/omap.c:652:	host->buffer_bytes_left = sg->length;
drivers/mmc/host/omap.c:653:	host->buffer = sg_virt(sg);
drivers/mmc/host/omap.c:654:	if (host->buffer_bytes_left > host->total_bytes_left)
drivers/mmc/host/omap.c:655:		host->buffer_bytes_left = host->total_bytes_left;
drivers/mmc/host/omap.c:672:	if (host->buffer_bytes_left == 0) {
drivers/mmc/host/omap.c:673:		host->sg_idx++;
drivers/mmc/host/omap.c:674:		BUG_ON(host->sg_idx == host->sg_len);
drivers/mmc/host/omap.c:678:	if (n > host->buffer_bytes_left)
drivers/mmc/host/omap.c:679:		n = host->buffer_bytes_left;
drivers/mmc/host/omap.c:680:	host->buffer_bytes_left -= n;
drivers/mmc/host/omap.c:681:	host->total_bytes_left -= n;
drivers/mmc/host/omap.c:682:	host->data->bytes_xfered += n;
drivers/mmc/host/omap.c:685:		__raw_writesw(host->virt_base + OMAP_MMC_REG(host, DATA), host->buffer, n);
drivers/mmc/host/omap.c:687:		__raw_readsw(host->virt_base + OMAP_MMC_REG(host, DATA), host->buffer, n);
drivers/mmc/host/omap.c:716:	if (host->cmd == NULL && host->data == NULL) {
drivers/mmc/host/omap.c:718:		dev_info(mmc_dev(host->slots[0]->mmc),
drivers/mmc/host/omap.c:736:		if (host->cmd != NULL)
drivers/mmc/host/omap.c:737:			cmd = host->cmd->opcode;
drivers/mmc/host/omap.c:741:		dev_dbg(mmc_dev(host->mmc), "MMC IRQ %04x (CMD %d): ",
drivers/mmc/host/omap.c:746:		if (host->total_bytes_left) {
drivers/mmc/host/omap.c:758:			dev_dbg(mmc_dev(host->mmc), "data timeout (CMD%d)\n",
drivers/mmc/host/omap.c:760:			if (host->data) {
drivers/mmc/host/omap.c:761:				host->data->error = -ETIMEDOUT;
drivers/mmc/host/omap.c:767:			if (host->data) {
drivers/mmc/host/omap.c:768:				host->data->error = -EILSEQ;
drivers/mmc/host/omap.c:769:				dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:771:					host->total_bytes_left);
drivers/mmc/host/omap.c:774:				dev_dbg(mmc_dev(host->mmc), "data CRC error\n");
drivers/mmc/host/omap.c:780:			if (host->cmd) {
drivers/mmc/host/omap.c:782:					host->current_slot;
drivers/mmc/host/omap.c:785:					dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:788:				host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/omap.c:795:			if (host->cmd) {
drivers/mmc/host/omap.c:796:				dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:798:					cmd, host->cmd->arg);
drivers/mmc/host/omap.c:799:				host->cmd->error = -EILSEQ;
drivers/mmc/host/omap.c:803:				dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:808:			dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:824:	if (cmd_error && host->data) {
drivers/mmc/host/omap.c:825:		del_timer(&host->cmd_abort_timer);
drivers/mmc/host/omap.c:826:		host->abort = 1;
drivers/mmc/host/omap.c:828:		disable_irq_nosync(host->irq);
drivers/mmc/host/omap.c:829:		schedule_work(&host->cmd_abort_work);
drivers/mmc/host/omap.c:834:		mmc_omap_cmd_done(host, host->cmd);
drivers/mmc/host/omap.c:835:	if (host->data != NULL) {
drivers/mmc/host/omap.c:837:			mmc_omap_xfer_done(host, host->data);
drivers/mmc/host/omap.c:839:			mmc_omap_end_of_data(host, host->data);
drivers/mmc/host/omap.c:849:	struct mmc_omap_slot *slot = host->slots[num];
drivers/mmc/host/omap.c:851:	BUG_ON(num >= host->nr_slots);
drivers/mmc/host/omap.c:854:	if (host->nr_slots == 0 || !host->slots[num])
drivers/mmc/host/omap.c:896:	int dma_ch = host->dma_ch;
drivers/mmc/host/omap.c:900:	struct scatterlist *sg = &data->sg[host->sg_idx];
drivers/mmc/host/omap.c:905:	data_addr = host->phys_base + OMAP_MMC_REG(host, DATA);
drivers/mmc/host/omap.c:912:	host->dma_len = count;
drivers/mmc/host/omap.c:976:	struct mmc_data *mmcdat = host->data;
drivers/mmc/host/omap.c:978:	if (unlikely(host->dma_ch < 0)) {
drivers/mmc/host/omap.c:979:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:985:		dev_err(mmc_dev(host->mmc),"DMA timeout\n");
drivers/mmc/host/omap.c:989:		dev_err(mmc_dev(host->mmc), "DMA sync error\n");
drivers/mmc/host/omap.c:995:	mmcdat->bytes_xfered += host->dma_len;
drivers/mmc/host/omap.c:996:	host->sg_idx++;
drivers/mmc/host/omap.c:997:	if (host->sg_idx < host->sg_len) {
drivers/mmc/host/omap.c:998:		mmc_omap_prepare_dma(host, host->data);
drivers/mmc/host/omap.c:999:		omap_start_dma(host->dma_ch);
drivers/mmc/host/omap.c:1001:		mmc_omap_dma_done(host, host->data);
drivers/mmc/host/omap.c:1010:	del_timer_sync(&host->dma_timer);
drivers/mmc/host/omap.c:1011:	if (host->dma_ch >= 0) {
drivers/mmc/host/omap.c:1012:		if (is_read == host->dma_is_read)
drivers/mmc/host/omap.c:1014:		omap_free_dma(host->dma_ch);
drivers/mmc/host/omap.c:1015:		host->dma_ch = -1;
drivers/mmc/host/omap.c:1019:		if (host->id == 0) {
drivers/mmc/host/omap.c:1027:		if (host->id == 0) {
drivers/mmc/host/omap.c:1038:		dev_dbg(mmc_dev(host->mmc), "omap_request_dma() failed with %d\n", r);
drivers/mmc/host/omap.c:1041:	host->dma_ch = dma_ch;
drivers/mmc/host/omap.c:1042:	host->dma_is_read = is_read;
drivers/mmc/host/omap.c:1063:	cycle_ns = 1000000000 / host->current_slot->fclk_freq;
drivers/mmc/host/omap.c:1085:	host->data = data;
drivers/mmc/host/omap.c:1090:		host->dma_in_use = 0;
drivers/mmc/host/omap.c:1107:	use_dma = host->use_dma;
drivers/mmc/host/omap.c:1117:	host->sg_idx = 0;
drivers/mmc/host/omap.c:1127:			host->sg_len = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/omap.c:1129:			host->total_bytes_left = 0;
drivers/mmc/host/omap.c:1131:			host->brs_received = 0;
drivers/mmc/host/omap.c:1132:			host->dma_done = 0;
drivers/mmc/host/omap.c:1133:			host->dma_in_use = 1;
drivers/mmc/host/omap.c:1141:		host->total_bytes_left = data->blocks * block_size;
drivers/mmc/host/omap.c:1142:		host->sg_len = sg_len;
drivers/mmc/host/omap.c:1144:		host->dma_in_use = 0;
drivers/mmc/host/omap.c:1151:	BUG_ON(host->mrq != NULL);
drivers/mmc/host/omap.c:1153:	host->mrq = req;
drivers/mmc/host/omap.c:1158:	if (host->dma_in_use)
drivers/mmc/host/omap.c:1159:		omap_start_dma(host->dma_ch);
drivers/mmc/host/omap.c:1168:	spin_lock_irqsave(&host->slot_lock, flags);
drivers/mmc/host/omap.c:1169:	if (host->mmc != NULL) {
drivers/mmc/host/omap.c:1172:		spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:1175:		host->mmc = mmc;
drivers/mmc/host/omap.c:1176:	spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:1209:	int func_clk_rate = clk_get_rate(host->fclk);
drivers/mmc/host/omap.c:1307:	mmc = mmc_alloc_host(sizeof(struct mmc_omap_slot), host->dev);
drivers/mmc/host/omap.c:1315:	slot->pdata = &host->pdata->slots[id];
drivers/mmc/host/omap.c:1317:	host->slots[id] = slot;
drivers/mmc/host/omap.c:1320:	if (host->pdata->slots[id].wires >= 4)
drivers/mmc/host/omap.c:1330:	if (host->pdata->max_freq)
drivers/mmc/host/omap.c:1331:		mmc->f_max = min(host->pdata->max_freq, mmc->f_max);
drivers/mmc/host/omap.c:1430:	INIT_WORK(&host->slot_release_work, mmc_omap_slot_release_work);
drivers/mmc/host/omap.c:1431:	INIT_WORK(&host->send_stop_work, mmc_omap_send_stop_work);
drivers/mmc/host/omap.c:1433:	INIT_WORK(&host->cmd_abort_work, mmc_omap_abort_command);
drivers/mmc/host/omap.c:1434:	setup_timer(&host->cmd_abort_timer, mmc_omap_cmd_timer,
drivers/mmc/host/omap.c:1437:	spin_lock_init(&host->clk_lock);
drivers/mmc/host/omap.c:1438:	setup_timer(&host->clk_timer, mmc_omap_clk_timer, (unsigned long) host);
drivers/mmc/host/omap.c:1440:	spin_lock_init(&host->dma_lock);
drivers/mmc/host/omap.c:1441:	setup_timer(&host->dma_timer, mmc_omap_dma_timer, (unsigned long) host);
drivers/mmc/host/omap.c:1442:	spin_lock_init(&host->slot_lock);
drivers/mmc/host/omap.c:1443:	init_waitqueue_head(&host->slot_wq);
drivers/mmc/host/omap.c:1445:	host->pdata = pdata;
drivers/mmc/host/omap.c:1446:	host->dev = &pdev->dev;
drivers/mmc/host/omap.c:1449:	host->id = pdev->id;
drivers/mmc/host/omap.c:1450:	host->mem_res = res;
drivers/mmc/host/omap.c:1451:	host->irq = irq;
drivers/mmc/host/omap.c:1453:	host->use_dma = 1;
drivers/mmc/host/omap.c:1454:	host->dev->dma_mask = &pdata->dma_mask;
drivers/mmc/host/omap.c:1455:	host->dma_ch = -1;
drivers/mmc/host/omap.c:1457:	host->irq = irq;
drivers/mmc/host/omap.c:1458:	host->phys_base = host->mem_res->start;
drivers/mmc/host/omap.c:1459:	host->virt_base = ioremap(res->start, res->end - res->start + 1);
drivers/mmc/host/omap.c:1460:	if (!host->virt_base)
drivers/mmc/host/omap.c:1463:	host->iclk = clk_get(&pdev->dev, "ick");
drivers/mmc/host/omap.c:1464:	if (IS_ERR(host->iclk)) {
drivers/mmc/host/omap.c:1465:		ret = PTR_ERR(host->iclk);
drivers/mmc/host/omap.c:1468:	clk_enable(host->iclk);
drivers/mmc/host/omap.c:1470:	host->fclk = clk_get(&pdev->dev, "fck");
drivers/mmc/host/omap.c:1471:	if (IS_ERR(host->fclk)) {
drivers/mmc/host/omap.c:1472:		ret = PTR_ERR(host->fclk);
drivers/mmc/host/omap.c:1476:	ret = request_irq(host->irq, mmc_omap_irq, 0, DRIVER_NAME, host);
drivers/mmc/host/omap.c:1486:	host->nr_slots = pdata->nr_slots;
drivers/mmc/host/omap.c:1491:				mmc_omap_remove_slot(host->slots[i]);
drivers/mmc/host/omap.c:1497:	host->reg_shift = (cpu_is_omap7xx() ? 1 : 2);
drivers/mmc/host/omap.c:1505:	free_irq(host->irq, host);
drivers/mmc/host/omap.c:1507:	clk_put(host->fclk);
drivers/mmc/host/omap.c:1509:	clk_disable(host->iclk);
drivers/mmc/host/omap.c:1510:	clk_put(host->iclk);
drivers/mmc/host/omap.c:1512:	iounmap(host->virt_base);
drivers/mmc/host/omap.c:1529:	for (i = 0; i < host->nr_slots; i++)
drivers/mmc/host/omap.c:1530:		mmc_omap_remove_slot(host->slots[i]);
drivers/mmc/host/omap.c:1532:	if (host->pdata->cleanup)
drivers/mmc/host/omap.c:1533:		host->pdata->cleanup(&pdev->dev);
drivers/mmc/host/omap.c:1536:	free_irq(host->irq, host);
drivers/mmc/host/omap.c:1537:	clk_put(host->fclk);
drivers/mmc/host/omap.c:1538:	clk_disable(host->iclk);
drivers/mmc/host/omap.c:1539:	clk_put(host->iclk);
drivers/mmc/host/omap.c:1541:	iounmap(host->virt_base);
drivers/mmc/host/omap.c:1556:	if (host == NULL || host->suspended)
drivers/mmc/host/omap.c:1559:	for (i = 0; i < host->nr_slots; i++) {
drivers/mmc/host/omap.c:1562:		slot = host->slots[i];
drivers/mmc/host/omap.c:1566:				slot = host->slots[i];
drivers/mmc/host/omap.c:1572:	host->suspended = 1;
drivers/mmc/host/omap.c:1581:	if (host == NULL || !host->suspended)
drivers/mmc/host/omap.c:1584:	for (i = 0; i < host->nr_slots; i++) {
drivers/mmc/host/omap.c:1586:		slot = host->slots[i];
drivers/mmc/host/omap.c:1591:		host->suspended = 0;
drivers/mmc/host/sdhci-pltfm.c:78:	host->hw_name = "platform";
drivers/mmc/host/sdhci-pltfm.c:80:		host->ops = pdata->ops;
drivers/mmc/host/sdhci-pltfm.c:82:		host->ops = &sdhci_pltfm_ops;
drivers/mmc/host/sdhci-pltfm.c:84:		host->quirks = pdata->quirks;
drivers/mmc/host/sdhci-pltfm.c:85:	host->irq = platform_get_irq(pdev, 0);
drivers/mmc/host/sdhci-pltfm.c:88:		mmc_hostname(host->mmc))) {
drivers/mmc/host/sdhci-pltfm.c:94:	host->ioaddr = ioremap(iomem->start, resource_size(iomem));
drivers/mmc/host/sdhci-pltfm.c:95:	if (!host->ioaddr) {
drivers/mmc/host/sdhci-pltfm.c:119:	iounmap(host->ioaddr);
drivers/mmc/host/sdhci-pltfm.c:138:	scratch = readl(host->ioaddr + SDHCI_INT_STATUS);
drivers/mmc/host/sdhci-pltfm.c:145:	iounmap(host->ioaddr);
drivers/mmc/host/at91_mci.c:191:	if (host->request) {
drivers/mmc/host/at91_mci.c:192:		dev_err(host->mmc->parent, "Timeout waiting end of packet\n");
drivers/mmc/host/at91_mci.c:194:		if (host->cmd && host->cmd->data) {
drivers/mmc/host/at91_mci.c:195:			host->cmd->data->error = -ETIMEDOUT;
drivers/mmc/host/at91_mci.c:197:			if (host->cmd)
drivers/mmc/host/at91_mci.c:198:				host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/at91_mci.c:200:				host->request->cmd->error = -ETIMEDOUT;
drivers/mmc/host/at91_mci.c:204:		mmc_request_done(host->mmc, host->request);
drivers/mmc/host/at91_mci.c:214:	unsigned *dmabuf = host->buffer;
drivers/mmc/host/at91_mci.c:221:		if (host->total_length == 12)
drivers/mmc/host/at91_mci.c:273:	unsigned *dmabuf = host->buffer;
drivers/mmc/host/at91_mci.c:277:	cmd = host->cmd;
drivers/mmc/host/at91_mci.c:343:	cmd = host->cmd;
drivers/mmc/host/at91_mci.c:365:	if (host->request->cmd && host->request->cmd->error != 0)
drivers/mmc/host/at91_mci.c:368:	if (host->request->data) {
drivers/mmc/host/at91_mci.c:369:		data = host->request->data;
drivers/mmc/host/at91_mci.c:373:				data->bytes_xfered, host->total_length);
drivers/mmc/host/at91_mci.c:383:	if (!host->cmd)
drivers/mmc/host/at91_mci.c:385:	else if (!host->cmd->data) {
drivers/mmc/host/at91_mci.c:386:		if (host->flags & FL_SENT_STOP) {
drivers/mmc/host/at91_mci.c:390:	} else if (host->cmd->data->flags & MMC_DATA_WRITE) {
drivers/mmc/host/at91_mci.c:419:	at91_mci_write(host, AT91_MCI_SDCR, host->board->slot_b);
drivers/mmc/host/at91_mci.c:442:	host->cmd = cmd;
drivers/mmc/host/at91_mci.c:475:				mmc_request_done(host->mmc, host->request);
drivers/mmc/host/at91_mci.c:481:				mmc_request_done(host->mmc, host->request);
drivers/mmc/host/at91_mci.c:505:	if (host->flags & FL_SENT_STOP)
drivers/mmc/host/at91_mci.c:508:	if (host->bus_mode == MMC_BUSMODE_OPENDRAIN)
drivers/mmc/host/at91_mci.c:548:			host->transfer_index = 0;
drivers/mmc/host/at91_mci.c:549:			host->in_use_index = 0;
drivers/mmc/host/at91_mci.c:554:				host->total_length = 0;
drivers/mmc/host/at91_mci.c:556:				at91_mci_write(host, ATMEL_PDC_RPR, host->physical_address);
drivers/mmc/host/at91_mci.c:568:				host->total_length = block_length * blocks;
drivers/mmc/host/at91_mci.c:574:					if (host->total_length < 12)
drivers/mmc/host/at91_mci.c:575:						host->total_length = 12;
drivers/mmc/host/at91_mci.c:579:				pr_debug("Transmitting %d bytes\n", host->total_length);
drivers/mmc/host/at91_mci.c:581:				at91_mci_write(host, ATMEL_PDC_TPR, host->physical_address);
drivers/mmc/host/at91_mci.c:583:						host->total_length : host->total_length / 4);
drivers/mmc/host/at91_mci.c:612:	if (!(host->flags & FL_SENT_COMMAND)) {
drivers/mmc/host/at91_mci.c:613:		host->flags |= FL_SENT_COMMAND;
drivers/mmc/host/at91_mci.c:614:		at91_mci_send_command(host, host->request->cmd);
drivers/mmc/host/at91_mci.c:616:	else if ((!(host->flags & FL_SENT_STOP)) && host->request->stop) {
drivers/mmc/host/at91_mci.c:617:		host->flags |= FL_SENT_STOP;
drivers/mmc/host/at91_mci.c:618:		at91_mci_send_command(host, host->request->stop);
drivers/mmc/host/at91_mci.c:620:		del_timer(&host->timer);
drivers/mmc/host/at91_mci.c:626:		mmc_request_done(host->mmc, host->request);
drivers/mmc/host/at91_mci.c:635:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/at91_mci.c:687:	host->request = mrq;
drivers/mmc/host/at91_mci.c:688:	host->flags = 0;
drivers/mmc/host/at91_mci.c:691:	mod_timer(&host->timer, jiffies +  msecs_to_jiffies(2000));
drivers/mmc/host/at91_mci.c:703:	unsigned long at91_master_clock = clk_get_rate(host->mci_clk);
drivers/mmc/host/at91_mci.c:705:	host->bus_mode = ios->bus_mode;
drivers/mmc/host/at91_mci.c:724:	if (ios->bus_width == MMC_BUS_WIDTH_4 && host->board->wire4) {
drivers/mmc/host/at91_mci.c:737:	if (host->board->vcc_pin) {
drivers/mmc/host/at91_mci.c:740:				gpio_set_value(host->board->vcc_pin, 0);
drivers/mmc/host/at91_mci.c:743:				gpio_set_value(host->board->vcc_pin, 1);
drivers/mmc/host/at91_mci.c:825:			if (host->request->data && host->request->data->blocks > 1) {
drivers/mmc/host/at91_mci.c:835:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/at91_mci.c:838:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/at91_mci.c:871:	if (present != host->present) {
drivers/mmc/host/at91_mci.c:872:		host->present = present;
drivers/mmc/host/at91_mci.c:873:		pr_debug("%s: card %s\n", mmc_hostname(host->mmc),
drivers/mmc/host/at91_mci.c:880:		mmc_detect_change(host->mmc, msecs_to_jiffies(500));
drivers/mmc/host/at91_mci.c:889:	if (host->board->wp_pin)
drivers/mmc/host/at91_mci.c:890:		return !!gpio_get_value(host->board->wp_pin);
drivers/mmc/host/at91_mci.c:902:	pr_debug("%s: sdio_irq %c : %s\n", mmc_hostname(host->mmc),
drivers/mmc/host/at91_mci.c:903:		host->board->slot_b ? 'B':'A', enable ? "enable" : "disable");
drivers/mmc/host/at91_mci.c:905:		host->board->slot_b ? AT91_MCI_SDIOIRQB : AT91_MCI_SDIOIRQA);
drivers/mmc/host/at91_mci.c:954:	host->mmc = mmc;
drivers/mmc/host/at91_mci.c:955:	host->bus_mode = 0;
drivers/mmc/host/at91_mci.c:956:	host->board = pdev->dev.platform_data;
drivers/mmc/host/at91_mci.c:957:	if (host->board->wire4) {
drivers/mmc/host/at91_mci.c:965:	host->buffer = dma_alloc_coherent(&pdev->dev, MCI_BUFSIZE,
drivers/mmc/host/at91_mci.c:966:					&host->physical_address, GFP_KERNEL);
drivers/mmc/host/at91_mci.c:967:	if (!host->buffer) {
drivers/mmc/host/at91_mci.c:976:		if (host->board->wire4 || !host->board->slot_b)
drivers/mmc/host/at91_mci.c:984:	if (host->board->det_pin) {
drivers/mmc/host/at91_mci.c:985:		ret = gpio_request(host->board->det_pin, "mmc_detect");
drivers/mmc/host/at91_mci.c:991:	if (host->board->wp_pin) {
drivers/mmc/host/at91_mci.c:992:		ret = gpio_request(host->board->wp_pin, "mmc_wp");
drivers/mmc/host/at91_mci.c:998:	if (host->board->vcc_pin) {
drivers/mmc/host/at91_mci.c:999:		ret = gpio_request(host->board->vcc_pin, "mmc_vcc");
drivers/mmc/host/at91_mci.c:1009:	host->mci_clk = clk_get(&pdev->dev, "mci_clk");
drivers/mmc/host/at91_mci.c:1010:	if (IS_ERR(host->mci_clk)) {
drivers/mmc/host/at91_mci.c:1019:	host->baseaddr = ioremap(res->start, res->end - res->start + 1);
drivers/mmc/host/at91_mci.c:1020:	if (!host->baseaddr) {
drivers/mmc/host/at91_mci.c:1028:	clk_enable(host->mci_clk);		/* Enable the peripheral clock */
drivers/mmc/host/at91_mci.c:1035:	host->irq = platform_get_irq(pdev, 0);
drivers/mmc/host/at91_mci.c:1036:	ret = request_irq(host->irq, at91_mci_irq, IRQF_SHARED,
drivers/mmc/host/at91_mci.c:1043:	setup_timer(&host->timer, at91_timeout_timer, (unsigned long)host);
drivers/mmc/host/at91_mci.c:1050:	if (host->board->det_pin) {
drivers/mmc/host/at91_mci.c:1051:		host->present = !gpio_get_value(host->board->det_pin);
drivers/mmc/host/at91_mci.c:1054:		host->present = -1;
drivers/mmc/host/at91_mci.c:1061:	if (host->board->det_pin) {
drivers/mmc/host/at91_mci.c:1062:		ret = request_irq(gpio_to_irq(host->board->det_pin),
drivers/mmc/host/at91_mci.c:1075:	clk_disable(host->mci_clk);
drivers/mmc/host/at91_mci.c:1076:	iounmap(host->baseaddr);
drivers/mmc/host/at91_mci.c:1078:	clk_put(host->mci_clk);
drivers/mmc/host/at91_mci.c:1080:	if (host->board->vcc_pin)
drivers/mmc/host/at91_mci.c:1081:		gpio_free(host->board->vcc_pin);
drivers/mmc/host/at91_mci.c:1083:	if (host->board->wp_pin)
drivers/mmc/host/at91_mci.c:1084:		gpio_free(host->board->wp_pin);
drivers/mmc/host/at91_mci.c:1086:	if (host->board->det_pin)
drivers/mmc/host/at91_mci.c:1087:		gpio_free(host->board->det_pin);
drivers/mmc/host/at91_mci.c:1089:	if (host->buffer)
drivers/mmc/host/at91_mci.c:1091:				host->buffer, host->physical_address);
drivers/mmc/host/at91_mci.c:1114:	if (host->buffer)
drivers/mmc/host/at91_mci.c:1116:				host->buffer, host->physical_address);
drivers/mmc/host/at91_mci.c:1118:	if (host->board->det_pin) {
drivers/mmc/host/at91_mci.c:1120:			free_irq(gpio_to_irq(host->board->det_pin), host);
drivers/mmc/host/at91_mci.c:1122:		gpio_free(host->board->det_pin);
drivers/mmc/host/at91_mci.c:1126:	del_timer_sync(&host->timer);
drivers/mmc/host/at91_mci.c:1128:	free_irq(host->irq, host);
drivers/mmc/host/at91_mci.c:1130:	clk_disable(host->mci_clk);			/* Disable the peripheral clock */
drivers/mmc/host/at91_mci.c:1131:	clk_put(host->mci_clk);
drivers/mmc/host/at91_mci.c:1133:	if (host->board->vcc_pin)
drivers/mmc/host/at91_mci.c:1134:		gpio_free(host->board->vcc_pin);
drivers/mmc/host/at91_mci.c:1135:	if (host->board->wp_pin)
drivers/mmc/host/at91_mci.c:1136:		gpio_free(host->board->wp_pin);
drivers/mmc/host/at91_mci.c:1138:	iounmap(host->baseaddr);
drivers/mmc/host/at91_mci.c:1156:	if (host->board->det_pin && device_may_wakeup(&pdev->dev))
drivers/mmc/host/at91_mci.c:1157:		enable_irq_wake(host->board->det_pin);
drivers/mmc/host/at91_mci.c:1171:	if (host->board->det_pin && device_may_wakeup(&pdev->dev))
drivers/mmc/host/at91_mci.c:1172:		disable_irq_wake(host->board->det_pin);
drivers/mmc/host/mxcmmc.c:149:	return host->do_dma;
drivers/mmc/host/mxcmmc.c:156:	dev_dbg(mmc_dev(host->mmc), "mxcmci_softreset\n");
drivers/mmc/host/mxcmmc.c:159:	writew(STR_STP_CLK_RESET, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/mxcmmc.c:161:			host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/mxcmmc.c:164:		writew(STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/mxcmmc.c:166:	writew(0xff, host->base + MMC_REG_RES_TO);
drivers/mmc/host/mxcmmc.c:182:	host->data = data;
drivers/mmc/host/mxcmmc.c:185:	writew(nob, host->base + MMC_REG_NOB);
drivers/mmc/host/mxcmmc.c:186:	writew(blksz, host->base + MMC_REG_BLK_LEN);
drivers/mmc/host/mxcmmc.c:187:	host->datasize = datasize;
drivers/mmc/host/mxcmmc.c:192:			host->do_dma = 0;
drivers/mmc/host/mxcmmc.c:198:		host->dma_dir = DMA_FROM_DEVICE;
drivers/mmc/host/mxcmmc.c:199:		host->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/mxcmmc.c:200:					     data->sg_len,  host->dma_dir);
drivers/mmc/host/mxcmmc.c:202:		ret = imx_dma_setup_sg(host->dma, data->sg, host->dma_nents,
drivers/mmc/host/mxcmmc.c:204:				host->res->start + MMC_REG_BUFFER_ACCESS,
drivers/mmc/host/mxcmmc.c:207:		host->dma_dir = DMA_TO_DEVICE;
drivers/mmc/host/mxcmmc.c:208:		host->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/mxcmmc.c:209:					     data->sg_len,  host->dma_dir);
drivers/mmc/host/mxcmmc.c:211:		ret = imx_dma_setup_sg(host->dma, data->sg, host->dma_nents,
drivers/mmc/host/mxcmmc.c:213:				host->res->start + MMC_REG_BUFFER_ACCESS,
drivers/mmc/host/mxcmmc.c:218:		dev_err(mmc_dev(host->mmc), "failed to setup DMA : %d\n", ret);
drivers/mmc/host/mxcmmc.c:223:	imx_dma_enable(host->dma);
drivers/mmc/host/mxcmmc.c:234:	WARN_ON(host->cmd != NULL);
drivers/mmc/host/mxcmmc.c:235:	host->cmd = cmd;
drivers/mmc/host/mxcmmc.c:251:		dev_err(mmc_dev(host->mmc), "unhandled response type 0x%x\n",
drivers/mmc/host/mxcmmc.c:262:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:263:	if (host->use_sdio)
drivers/mmc/host/mxcmmc.c:265:	writel(int_cntr, host->base + MMC_REG_INT_CNTR);
drivers/mmc/host/mxcmmc.c:266:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:268:	writew(cmd->opcode, host->base + MMC_REG_CMD);
drivers/mmc/host/mxcmmc.c:269:	writel(cmd->arg, host->base + MMC_REG_ARG);
drivers/mmc/host/mxcmmc.c:270:	writew(cmdat, host->base + MMC_REG_CMD_DAT_CONT);
drivers/mmc/host/mxcmmc.c:281:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:282:	if (host->use_sdio)
drivers/mmc/host/mxcmmc.c:284:	writel(int_cntr, host->base + MMC_REG_INT_CNTR);
drivers/mmc/host/mxcmmc.c:285:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:287:	host->req = NULL;
drivers/mmc/host/mxcmmc.c:288:	host->cmd = NULL;
drivers/mmc/host/mxcmmc.c:289:	host->data = NULL;
drivers/mmc/host/mxcmmc.c:291:	mmc_request_done(host->mmc, req);
drivers/mmc/host/mxcmmc.c:296:	struct mmc_data *data = host->data;
drivers/mmc/host/mxcmmc.c:301:		imx_dma_disable(host->dma);
drivers/mmc/host/mxcmmc.c:302:		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_nents,
drivers/mmc/host/mxcmmc.c:303:				host->dma_dir);
drivers/mmc/host/mxcmmc.c:308:		dev_dbg(mmc_dev(host->mmc), "request failed. status: 0x%08x\n",
drivers/mmc/host/mxcmmc.c:311:			dev_err(mmc_dev(host->mmc), "%s: -EILSEQ\n", __func__);
drivers/mmc/host/mxcmmc.c:316:				dev_err(mmc_dev(host->mmc),
drivers/mmc/host/mxcmmc.c:320:				dev_err(mmc_dev(host->mmc),
drivers/mmc/host/mxcmmc.c:325:			dev_err(mmc_dev(host->mmc),
drivers/mmc/host/mxcmmc.c:329:			dev_err(mmc_dev(host->mmc), "%s: -EIO\n", __func__);
drivers/mmc/host/mxcmmc.c:333:		data->bytes_xfered = host->datasize;
drivers/mmc/host/mxcmmc.c:338:	host->data = NULL;
drivers/mmc/host/mxcmmc.c:345:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/mxcmmc.c:353:		dev_dbg(mmc_dev(host->mmc), "CMD TIMEOUT\n");
drivers/mmc/host/mxcmmc.c:356:		dev_dbg(mmc_dev(host->mmc), "cmd crc error\n");
drivers/mmc/host/mxcmmc.c:363:				a = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/mxcmmc.c:364:				b = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/mxcmmc.c:368:			a = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/mxcmmc.c:369:			b = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/mxcmmc.c:370:			c = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/mxcmmc.c:382:		stat = readl(host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:387:			mxcmci_set_clk_rate(host, host->clock);
drivers/mmc/host/mxcmmc.c:406:		*buf++ = readl(host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/mxcmmc.c:418:		tmp = readl(host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/mxcmmc.c:434:		writel(*buf++, host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/mxcmmc.c:447:		writel(tmp, host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/mxcmmc.c:459:	struct mmc_data *data = host->req->data;
drivers/mmc/host/mxcmmc.c:463:	host->data = data;
drivers/mmc/host/mxcmmc.c:464:	host->datasize = 0;
drivers/mmc/host/mxcmmc.c:471:			host->datasize += sg->length;
drivers/mmc/host/mxcmmc.c:478:			host->datasize += sg->length;
drivers/mmc/host/mxcmmc.c:494:		host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:497:	if (host->req->stop) {
drivers/mmc/host/mxcmmc.c:498:		if (mxcmci_start_cmd(host, host->req->stop, 0)) {
drivers/mmc/host/mxcmmc.c:499:			mxcmci_finish_request(host, host->req);
drivers/mmc/host/mxcmmc.c:503:		mxcmci_finish_request(host, host->req);
drivers/mmc/host/mxcmmc.c:510:	struct mmc_data *data = host->data;
drivers/mmc/host/mxcmmc.c:519:	host->cmd = NULL;
drivers/mmc/host/mxcmmc.c:521:	if (host->req->stop) {
drivers/mmc/host/mxcmmc.c:522:		if (mxcmci_start_cmd(host, host->req->stop, 0)) {
drivers/mmc/host/mxcmmc.c:523:			mxcmci_finish_request(host, host->req);
drivers/mmc/host/mxcmmc.c:527:		mxcmci_finish_request(host, host->req);
drivers/mmc/host/mxcmmc.c:535:	host->cmd = NULL;
drivers/mmc/host/mxcmmc.c:537:	if (!host->data && host->req) {
drivers/mmc/host/mxcmmc.c:538:		mxcmci_finish_request(host, host->req);
drivers/mmc/host/mxcmmc.c:546:	if (!mxcmci_use_dma(host) && host->data)
drivers/mmc/host/mxcmmc.c:547:		schedule_work(&host->datawork);
drivers/mmc/host/mxcmmc.c:558:	stat = readl(host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:560:			STATUS_WRITE_OP_DONE), host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:562:	dev_dbg(mmc_dev(host->mmc), "%s: 0x%08x\n", __func__, stat);
drivers/mmc/host/mxcmmc.c:564:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:565:	sdio_irq = (stat & STATUS_SDIO_INT_ACTIVE) && host->use_sdio;
drivers/mmc/host/mxcmmc.c:566:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:572:			host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:576:		writel(STATUS_SDIO_INT_ACTIVE, host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:577:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/mxcmmc.c:594:	unsigned int cmdat = host->cmdat;
drivers/mmc/host/mxcmmc.c:597:	WARN_ON(host->req != NULL);
drivers/mmc/host/mxcmmc.c:599:	host->req = req;
drivers/mmc/host/mxcmmc.c:600:	host->cmdat &= ~CMD_DAT_CONT_INIT;
drivers/mmc/host/mxcmmc.c:602:	host->do_dma = 1;
drivers/mmc/host/mxcmmc.c:628:	unsigned int clk_in = clk_get_rate(host->clk);
drivers/mmc/host/mxcmmc.c:651:	writew((prescaler << 4) | divider, host->base + MMC_REG_CLK_RATE);
drivers/mmc/host/mxcmmc.c:653:	dev_dbg(mmc_dev(host->mmc), "scaler: %d divider: %d in: %d out: %d\n",
drivers/mmc/host/mxcmmc.c:671:	imx_dma_config_burstlen(host->dma, blen);
drivers/mmc/host/mxcmmc.c:674:		host->cmdat |= CMD_DAT_CONT_BUS_WIDTH_4;
drivers/mmc/host/mxcmmc.c:676:		host->cmdat &= ~CMD_DAT_CONT_BUS_WIDTH_4;
drivers/mmc/host/mxcmmc.c:678:	if (host->power_mode != ios->power_mode) {
drivers/mmc/host/mxcmmc.c:679:		if (host->pdata && host->pdata->setpower)
drivers/mmc/host/mxcmmc.c:680:			host->pdata->setpower(mmc_dev(mmc), ios->vdd);
drivers/mmc/host/mxcmmc.c:681:		host->power_mode = ios->power_mode;
drivers/mmc/host/mxcmmc.c:683:			host->cmdat |= CMD_DAT_CONT_INIT;
drivers/mmc/host/mxcmmc.c:688:		writew(STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/mxcmmc.c:690:		writew(STR_STP_CLK_STOP_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/mxcmmc.c:693:	host->clock = ios->clock;
drivers/mmc/host/mxcmmc.c:710:	if (host->pdata && host->pdata->get_ro)
drivers/mmc/host/mxcmmc.c:711:		return !!host->pdata->get_ro(mmc_dev(mmc));
drivers/mmc/host/mxcmmc.c:725:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:726:	host->use_sdio = enable;
drivers/mmc/host/mxcmmc.c:727:	int_cntr = readl(host->base + MMC_REG_INT_CNTR);
drivers/mmc/host/mxcmmc.c:734:	writel(int_cntr, host->base + MMC_REG_INT_CNTR);
drivers/mmc/host/mxcmmc.c:735:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:748:		host->caps &= ~MMC_CAP_4_BIT_DATA;
drivers/mmc/host/mxcmmc.c:750:		host->caps |= MMC_CAP_4_BIT_DATA;
drivers/mmc/host/mxcmmc.c:797:	host->base = ioremap(r->start, resource_size(r));
drivers/mmc/host/mxcmmc.c:798:	if (!host->base) {
drivers/mmc/host/mxcmmc.c:803:	host->mmc = mmc;
drivers/mmc/host/mxcmmc.c:804:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/mxcmmc.c:805:	spin_lock_init(&host->lock);
drivers/mmc/host/mxcmmc.c:807:	if (host->pdata && host->pdata->ocr_avail)
drivers/mmc/host/mxcmmc.c:808:		mmc->ocr_avail = host->pdata->ocr_avail;
drivers/mmc/host/mxcmmc.c:812:	host->res = r;
drivers/mmc/host/mxcmmc.c:813:	host->irq = irq;
drivers/mmc/host/mxcmmc.c:815:	host->clk = clk_get(&pdev->dev, NULL);
drivers/mmc/host/mxcmmc.c:816:	if (IS_ERR(host->clk)) {
drivers/mmc/host/mxcmmc.c:817:		ret = PTR_ERR(host->clk);
drivers/mmc/host/mxcmmc.c:820:	clk_enable(host->clk);
drivers/mmc/host/mxcmmc.c:824:	host->rev_no = readw(host->base + MMC_REG_REV_NO);
drivers/mmc/host/mxcmmc.c:825:	if (host->rev_no != 0x400) {
drivers/mmc/host/mxcmmc.c:827:		dev_err(mmc_dev(host->mmc), "wrong rev.no. 0x%08x. aborting.\n",
drivers/mmc/host/mxcmmc.c:828:			host->rev_no);
drivers/mmc/host/mxcmmc.c:832:	mmc->f_min = clk_get_rate(host->clk) >> 16;
drivers/mmc/host/mxcmmc.c:833:	mmc->f_max = clk_get_rate(host->clk) >> 1;
drivers/mmc/host/mxcmmc.c:836:	writew(0x2db4, host->base + MMC_REG_READ_TO);
drivers/mmc/host/mxcmmc.c:838:	writel(0, host->base + MMC_REG_INT_CNTR);
drivers/mmc/host/mxcmmc.c:841:	host->dma = imx_dma_request_by_prio(DRIVER_NAME, DMA_PRIO_LOW);
drivers/mmc/host/mxcmmc.c:842:	if (host->dma < 0) {
drivers/mmc/host/mxcmmc.c:843:		dev_err(mmc_dev(host->mmc), "imx_dma_request_by_prio failed\n");
drivers/mmc/host/mxcmmc.c:854:	ret = imx_dma_config_channel(host->dma,
drivers/mmc/host/mxcmmc.c:859:		dev_err(mmc_dev(host->mmc), "failed to config DMA channel\n");
drivers/mmc/host/mxcmmc.c:863:	INIT_WORK(&host->datawork, mxcmci_datawork);
drivers/mmc/host/mxcmmc.c:865:	ret = request_irq(host->irq, mxcmci_irq, 0, DRIVER_NAME, host);
drivers/mmc/host/mxcmmc.c:871:	if (host->pdata && host->pdata->init) {
drivers/mmc/host/mxcmmc.c:872:		ret = host->pdata->init(&pdev->dev, mxcmci_detect_irq,
drivers/mmc/host/mxcmmc.c:873:				host->mmc);
drivers/mmc/host/mxcmmc.c:883:	free_irq(host->irq, host);
drivers/mmc/host/mxcmmc.c:886:	imx_dma_free(host->dma);
drivers/mmc/host/mxcmmc.c:889:	clk_disable(host->clk);
drivers/mmc/host/mxcmmc.c:890:	clk_put(host->clk);
drivers/mmc/host/mxcmmc.c:892:	iounmap(host->base);
drivers/mmc/host/mxcmmc.c:909:	if (host->pdata && host->pdata->exit)
drivers/mmc/host/mxcmmc.c:910:		host->pdata->exit(&pdev->dev, mmc);
drivers/mmc/host/mxcmmc.c:912:	free_irq(host->irq, host);
drivers/mmc/host/mxcmmc.c:913:	iounmap(host->base);
drivers/mmc/host/mxcmmc.c:915:	imx_dma_free(host->dma);
drivers/mmc/host/mxcmmc.c:917:	clk_disable(host->clk);
drivers/mmc/host/mxcmmc.c:918:	clk_put(host->clk);
drivers/mmc/host/mxcmmc.c:920:	release_mem_region(host->res->start, resource_size(host->res));
drivers/mmc/host/mxcmmc.c:921:	release_resource(host->res);
drivers/mmc/host/tifm_sd.c:116:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:121:	if (host->cmd_flags & DATA_CARRY) {
drivers/mmc/host/tifm_sd.c:122:		buf[pos++] = host->bounce_buf_data[0];
drivers/mmc/host/tifm_sd.c:123:		host->cmd_flags &= ~DATA_CARRY;
drivers/mmc/host/tifm_sd.c:130:			host->bounce_buf_data[0] = (val >> 8) & 0xff;
drivers/mmc/host/tifm_sd.c:131:			host->cmd_flags |= DATA_CARRY;
drivers/mmc/host/tifm_sd.c:142:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:147:	if (host->cmd_flags & DATA_CARRY) {
drivers/mmc/host/tifm_sd.c:148:		val = host->bounce_buf_data[0] | ((buf[pos++] << 8) & 0xff00);
drivers/mmc/host/tifm_sd.c:150:		host->cmd_flags &= ~DATA_CARRY;
drivers/mmc/host/tifm_sd.c:156:			host->bounce_buf_data[0] = val & 0xff;
drivers/mmc/host/tifm_sd.c:157:			host->cmd_flags |= DATA_CARRY;
drivers/mmc/host/tifm_sd.c:168:	struct mmc_data *r_data = host->req->cmd->data;
drivers/mmc/host/tifm_sd.c:174:	if (host->sg_pos == host->sg_len)
drivers/mmc/host/tifm_sd.c:177:		cnt = sg[host->sg_pos].length - host->block_pos;
drivers/mmc/host/tifm_sd.c:179:			host->block_pos = 0;
drivers/mmc/host/tifm_sd.c:180:			host->sg_pos++;
drivers/mmc/host/tifm_sd.c:181:			if (host->sg_pos == host->sg_len) {
drivers/mmc/host/tifm_sd.c:183:				    && (host->cmd_flags & DATA_CARRY))
drivers/mmc/host/tifm_sd.c:184:					writel(host->bounce_buf_data[0],
drivers/mmc/host/tifm_sd.c:185:					       host->dev->addr
drivers/mmc/host/tifm_sd.c:190:			cnt = sg[host->sg_pos].length;
drivers/mmc/host/tifm_sd.c:192:		off = sg[host->sg_pos].offset + host->block_pos;
drivers/mmc/host/tifm_sd.c:194:		pg = nth_page(sg_page(&sg[host->sg_pos]), off >> PAGE_SHIFT);
drivers/mmc/host/tifm_sd.c:206:		host->block_pos += p_cnt;
drivers/mmc/host/tifm_sd.c:231:	dev_dbg(&host->dev->dev, "bouncing block\n");
drivers/mmc/host/tifm_sd.c:233:		cnt = sg[host->sg_pos].length - host->block_pos;
drivers/mmc/host/tifm_sd.c:235:			host->block_pos = 0;
drivers/mmc/host/tifm_sd.c:236:			host->sg_pos++;
drivers/mmc/host/tifm_sd.c:237:			if (host->sg_pos == host->sg_len)
drivers/mmc/host/tifm_sd.c:239:			cnt = sg[host->sg_pos].length;
drivers/mmc/host/tifm_sd.c:241:		off = sg[host->sg_pos].offset + host->block_pos;
drivers/mmc/host/tifm_sd.c:243:		pg = nth_page(sg_page(&sg[host->sg_pos]), off >> PAGE_SHIFT);
drivers/mmc/host/tifm_sd.c:250:			tifm_sd_copy_page(sg_page(&host->bounce_buf),
drivers/mmc/host/tifm_sd.c:254:			tifm_sd_copy_page(pg, p_off, sg_page(&host->bounce_buf),
drivers/mmc/host/tifm_sd.c:258:		host->block_pos += p_cnt;
drivers/mmc/host/tifm_sd.c:264:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:270:	if (host->sg_pos == host->sg_len)
drivers/mmc/host/tifm_sd.c:273:	if (host->cmd_flags & DATA_CARRY) {
drivers/mmc/host/tifm_sd.c:274:		host->cmd_flags &= ~DATA_CARRY;
drivers/mmc/host/tifm_sd.c:278:		if (host->sg_pos == host->sg_len)
drivers/mmc/host/tifm_sd.c:282:	dma_len = sg_dma_len(&r_data->sg[host->sg_pos]) - host->block_pos;
drivers/mmc/host/tifm_sd.c:284:		host->block_pos = 0;
drivers/mmc/host/tifm_sd.c:285:		host->sg_pos++;
drivers/mmc/host/tifm_sd.c:286:		if (host->sg_pos == host->sg_len)
drivers/mmc/host/tifm_sd.c:288:		dma_len = sg_dma_len(&r_data->sg[host->sg_pos]);
drivers/mmc/host/tifm_sd.c:293:		dma_off = host->block_pos;
drivers/mmc/host/tifm_sd.c:294:		host->block_pos += dma_blk_cnt * r_data->blksz;
drivers/mmc/host/tifm_sd.c:297:		dma_off = host->block_pos;
drivers/mmc/host/tifm_sd.c:298:		host->block_pos += t_size;
drivers/mmc/host/tifm_sd.c:302:		sg = &r_data->sg[host->sg_pos];
drivers/mmc/host/tifm_sd.c:309:			host->cmd_flags |= DATA_CARRY;
drivers/mmc/host/tifm_sd.c:311:		sg = &host->bounce_buf;
drivers/mmc/host/tifm_sd.c:373:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:376:	if (host->open_drain)
drivers/mmc/host/tifm_sd.c:404:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:405:	struct mmc_command *cmd = host->req->cmd;
drivers/mmc/host/tifm_sd.c:410:	if (!(host->cmd_flags & CMD_READY))
drivers/mmc/host/tifm_sd.c:415:			if ((host->cmd_flags & SCMD_ACTIVE)
drivers/mmc/host/tifm_sd.c:416:			    && !(host->cmd_flags & SCMD_READY))
drivers/mmc/host/tifm_sd.c:422:		if (!(host->cmd_flags & BRS_READY))
drivers/mmc/host/tifm_sd.c:425:		if (!(host->no_dma || (host->cmd_flags & FIFO_READY)))
drivers/mmc/host/tifm_sd.c:429:			if (host->req->stop) {
drivers/mmc/host/tifm_sd.c:430:				if (!(host->cmd_flags & SCMD_ACTIVE)) {
drivers/mmc/host/tifm_sd.c:431:					host->cmd_flags |= SCMD_ACTIVE;
drivers/mmc/host/tifm_sd.c:437:					tifm_sd_exec(host, host->req->stop);
drivers/mmc/host/tifm_sd.c:440:					if (!(host->cmd_flags & SCMD_READY)
drivers/mmc/host/tifm_sd.c:441:					    || (host->cmd_flags & CARD_BUSY))
drivers/mmc/host/tifm_sd.c:450:				if (host->cmd_flags & CARD_BUSY)
drivers/mmc/host/tifm_sd.c:458:			if (host->req->stop) {
drivers/mmc/host/tifm_sd.c:459:				if (!(host->cmd_flags & SCMD_ACTIVE)) {
drivers/mmc/host/tifm_sd.c:460:					host->cmd_flags |= SCMD_ACTIVE;
drivers/mmc/host/tifm_sd.c:461:					tifm_sd_exec(host, host->req->stop);
drivers/mmc/host/tifm_sd.c:464:					if (!(host->cmd_flags & SCMD_READY))
drivers/mmc/host/tifm_sd.c:471:	tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/tifm_sd.c:485:		fifo_status, host->cmd_flags);
drivers/mmc/host/tifm_sd.c:487:	if (host->req) {
drivers/mmc/host/tifm_sd.c:488:		r_data = host->req->cmd->data;
drivers/mmc/host/tifm_sd.c:492:				host->cmd_flags |= FIFO_READY;
drivers/mmc/host/tifm_sd.c:515:		host_status, host->cmd_flags);
drivers/mmc/host/tifm_sd.c:517:	if (host->req) {
drivers/mmc/host/tifm_sd.c:518:		cmd = host->req->cmd;
drivers/mmc/host/tifm_sd.c:539:			if (host->req->stop) {
drivers/mmc/host/tifm_sd.c:540:				if (host->cmd_flags & SCMD_ACTIVE) {
drivers/mmc/host/tifm_sd.c:541:					host->req->stop->error = cmd_error;
drivers/mmc/host/tifm_sd.c:542:					host->cmd_flags |= SCMD_READY;
drivers/mmc/host/tifm_sd.c:545:					host->cmd_flags |= SCMD_ACTIVE;
drivers/mmc/host/tifm_sd.c:546:					tifm_sd_exec(host, host->req->stop);
drivers/mmc/host/tifm_sd.c:553:				if (!(host->cmd_flags & CMD_READY)) {
drivers/mmc/host/tifm_sd.c:554:					host->cmd_flags |= CMD_READY;
drivers/mmc/host/tifm_sd.c:556:				} else if (host->cmd_flags & SCMD_ACTIVE) {
drivers/mmc/host/tifm_sd.c:557:					host->cmd_flags |= SCMD_READY;
drivers/mmc/host/tifm_sd.c:558:					tifm_sd_fetch_resp(host->req->stop,
drivers/mmc/host/tifm_sd.c:563:				host->cmd_flags |= BRS_READY;
drivers/mmc/host/tifm_sd.c:566:		if (host->no_dma && cmd->data) {
drivers/mmc/host/tifm_sd.c:581:			host->cmd_flags &= ~CARD_BUSY;
drivers/mmc/host/tifm_sd.c:583:			host->cmd_flags |= CARD_BUSY;
drivers/mmc/host/tifm_sd.c:595:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:602:			((1000000000UL / host->clk_freq) * host->clk_div);
drivers/mmc/host/tifm_sd.c:623:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:628:	if (host->eject) {
drivers/mmc/host/tifm_sd.c:633:	if (host->req) {
drivers/mmc/host/tifm_sd.c:640:	host->cmd_flags = 0;
drivers/mmc/host/tifm_sd.c:641:	host->block_pos = 0;
drivers/mmc/host/tifm_sd.c:642:	host->sg_pos = 0;
drivers/mmc/host/tifm_sd.c:645:		host->no_dma = 1;
drivers/mmc/host/tifm_sd.c:647:		host->no_dma = no_dma ? 1 : 0;
drivers/mmc/host/tifm_sd.c:657:		if (host->no_dma) {
drivers/mmc/host/tifm_sd.c:665:			host->sg_len = r_data->sg_len;
drivers/mmc/host/tifm_sd.c:667:			sg_init_one(&host->bounce_buf, host->bounce_buf_data,
drivers/mmc/host/tifm_sd.c:670:			if(1 != tifm_map_sg(sock, &host->bounce_buf, 1,
drivers/mmc/host/tifm_sd.c:679:			host->sg_len = tifm_map_sg(sock, r_data->sg,
drivers/mmc/host/tifm_sd.c:685:			if (host->sg_len < 1) {
drivers/mmc/host/tifm_sd.c:688:				tifm_unmap_sg(sock, &host->bounce_buf, 1,
drivers/mmc/host/tifm_sd.c:721:	host->req = mrq;
drivers/mmc/host/tifm_sd.c:722:	mod_timer(&host->timer, jiffies + host->timeout_jiffies);
drivers/mmc/host/tifm_sd.c:737:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:745:	del_timer(&host->timer);
drivers/mmc/host/tifm_sd.c:746:	mrq = host->req;
drivers/mmc/host/tifm_sd.c:747:	host->req = NULL;
drivers/mmc/host/tifm_sd.c:758:		if (host->no_dma) {
drivers/mmc/host/tifm_sd.c:763:			tifm_unmap_sg(sock, &host->bounce_buf, 1,
drivers/mmc/host/tifm_sd.c:792:	       dev_name(&host->dev->dev), host->req->cmd->opcode, host->cmd_flags);
drivers/mmc/host/tifm_sd.c:794:	tifm_eject(host->dev);
drivers/mmc/host/tifm_sd.c:800:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:834:			host->clk_freq = 20000000;
drivers/mmc/host/tifm_sd.c:835:			host->clk_div = clk_div1;
drivers/mmc/host/tifm_sd.c:840:			host->clk_freq = 24000000;
drivers/mmc/host/tifm_sd.c:841:			host->clk_div = clk_div2;
drivers/mmc/host/tifm_sd.c:847:		host->clk_div = 0;
drivers/mmc/host/tifm_sd.c:849:	host->clk_div &= TIFM_MMCSD_CLKMASK;
drivers/mmc/host/tifm_sd.c:850:	writel(host->clk_div
drivers/mmc/host/tifm_sd.c:855:	host->open_drain = (ios->bus_mode == MMC_BUSMODE_OPENDRAIN);
drivers/mmc/host/tifm_sd.c:868:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:888:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:892:	host->clk_div = 61;
drivers/mmc/host/tifm_sd.c:893:	host->clk_freq = 20000000;
drivers/mmc/host/tifm_sd.c:895:	writel(host->clk_div | TIFM_MMCSD_POWER,
drivers/mmc/host/tifm_sd.c:914:	writel(host->clk_div | TIFM_MMCSD_POWER,
drivers/mmc/host/tifm_sd.c:967:	host->dev = sock;
drivers/mmc/host/tifm_sd.c:968:	host->timeout_jiffies = msecs_to_jiffies(1000);
drivers/mmc/host/tifm_sd.c:970:	tasklet_init(&host->finish_tasklet, tifm_sd_end_cmd,
drivers/mmc/host/tifm_sd.c:972:	setup_timer(&host->timer, tifm_sd_abort, (unsigned long)host);
drivers/mmc/host/tifm_sd.c:1007:	host->eject = 1;
drivers/mmc/host/tifm_sd.c:1012:	tasklet_kill(&host->finish_tasklet);
drivers/mmc/host/tifm_sd.c:1015:	if (host->req) {
drivers/mmc/host/tifm_sd.c:1019:		host->req->cmd->error = -ENOMEDIUM;
drivers/mmc/host/tifm_sd.c:1020:		if (host->req->stop)
drivers/mmc/host/tifm_sd.c:1021:			host->req->stop->error = -ENOMEDIUM;
drivers/mmc/host/tifm_sd.c:1022:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/tifm_sd.c:1048:		host->eject = 1;
drivers/mmc/host/pxamci.c:83:	host->vcc = regulator_get(mmc_dev(host->mmc), "vmmc");
drivers/mmc/host/pxamci.c:85:	if (IS_ERR(host->vcc))
drivers/mmc/host/pxamci.c:86:		host->vcc = NULL;
drivers/mmc/host/pxamci.c:88:		host->mmc->ocr_avail = mmc_regulator_get_ocrmask(host->vcc);
drivers/mmc/host/pxamci.c:89:		if (host->pdata && host->pdata->ocr_mask)
drivers/mmc/host/pxamci.c:90:			dev_warn(mmc_dev(host->mmc),
drivers/mmc/host/pxamci.c:94:	if (host->vcc == NULL) {
drivers/mmc/host/pxamci.c:96:		host->mmc->ocr_avail = host->pdata ?
drivers/mmc/host/pxamci.c:97:			host->pdata->ocr_mask :
drivers/mmc/host/pxamci.c:107:	if (host->vcc)
drivers/mmc/host/pxamci.c:108:		mmc_regulator_set_ocr(host->vcc, vdd);
drivers/mmc/host/pxamci.c:110:	if (!host->vcc && host->pdata &&
drivers/mmc/host/pxamci.c:111:	    gpio_is_valid(host->pdata->gpio_power)) {
drivers/mmc/host/pxamci.c:112:		on = ((1 << vdd) & host->pdata->ocr_mask);
drivers/mmc/host/pxamci.c:113:		gpio_set_value(host->pdata->gpio_power,
drivers/mmc/host/pxamci.c:114:			       !!on ^ host->pdata->gpio_power_invert);
drivers/mmc/host/pxamci.c:116:	if (!host->vcc && host->pdata && host->pdata->setpower)
drivers/mmc/host/pxamci.c:117:		host->pdata->setpower(mmc_dev(host->mmc), vdd);
drivers/mmc/host/pxamci.c:122:	if (readl(host->base + MMC_STAT) & STAT_CLK_EN) {
drivers/mmc/host/pxamci.c:126:		writel(STOP_CLOCK, host->base + MMC_STRPCL);
drivers/mmc/host/pxamci.c:129:			v = readl(host->base + MMC_STAT);
drivers/mmc/host/pxamci.c:136:			dev_err(mmc_dev(host->mmc), "unable to stop clock\n");
drivers/mmc/host/pxamci.c:144:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/pxamci.c:145:	host->imask &= ~mask;
drivers/mmc/host/pxamci.c:146:	writel(host->imask, host->base + MMC_I_MASK);
drivers/mmc/host/pxamci.c:147:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/pxamci.c:154:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/pxamci.c:155:	host->imask |= mask;
drivers/mmc/host/pxamci.c:156:	writel(host->imask, host->base + MMC_I_MASK);
drivers/mmc/host/pxamci.c:157:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/pxamci.c:169:	host->data = data;
drivers/mmc/host/pxamci.c:174:	writel(nob, host->base + MMC_NOB);
drivers/mmc/host/pxamci.c:175:	writel(data->blksz, host->base + MMC_BLKLEN);
drivers/mmc/host/pxamci.c:177:	clks = (unsigned long long)data->timeout_ns * host->clkrate;
drivers/mmc/host/pxamci.c:179:	timeout = (unsigned int)clks + (data->timeout_clks << host->clkrt);
drivers/mmc/host/pxamci.c:180:	writel((timeout + 255) / 256, host->base + MMC_RDTO);
drivers/mmc/host/pxamci.c:183:		host->dma_dir = DMA_FROM_DEVICE;
drivers/mmc/host/pxamci.c:185:		DRCMR(host->dma_drcmrtx) = 0;
drivers/mmc/host/pxamci.c:186:		DRCMR(host->dma_drcmrrx) = host->dma | DRCMR_MAPVLD;
drivers/mmc/host/pxamci.c:188:		host->dma_dir = DMA_TO_DEVICE;
drivers/mmc/host/pxamci.c:190:		DRCMR(host->dma_drcmrrx) = 0;
drivers/mmc/host/pxamci.c:191:		DRCMR(host->dma_drcmrtx) = host->dma | DRCMR_MAPVLD;
drivers/mmc/host/pxamci.c:196:	host->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/pxamci.c:197:				   host->dma_dir);
drivers/mmc/host/pxamci.c:199:	for (i = 0; i < host->dma_len; i++) {
drivers/mmc/host/pxamci.c:201:		host->sg_cpu[i].dcmd = dcmd | length;
drivers/mmc/host/pxamci.c:203:			host->sg_cpu[i].dcmd |= DCMD_ENDIRQEN;
drivers/mmc/host/pxamci.c:208:			host->sg_cpu[i].dsadr = host->res->start + MMC_RXFIFO;
drivers/mmc/host/pxamci.c:209:			host->sg_cpu[i].dtadr = sg_dma_address(&data->sg[i]);
drivers/mmc/host/pxamci.c:211:			host->sg_cpu[i].dsadr = sg_dma_address(&data->sg[i]);
drivers/mmc/host/pxamci.c:212:			host->sg_cpu[i].dtadr = host->res->start + MMC_TXFIFO;
drivers/mmc/host/pxamci.c:214:		host->sg_cpu[i].ddadr = host->sg_dma + (i + 1) *
drivers/mmc/host/pxamci.c:217:	host->sg_cpu[host->dma_len - 1].ddadr = DDADR_STOP;
drivers/mmc/host/pxamci.c:226:		DALGN |= (1 << host->dma);
drivers/mmc/host/pxamci.c:228:		DALGN &= ~(1 << host->dma);
drivers/mmc/host/pxamci.c:229:	DDADR(host->dma) = host->sg_dma;
drivers/mmc/host/pxamci.c:238:		DCSR(host->dma) = DCSR_RUN;
drivers/mmc/host/pxamci.c:243:	WARN_ON(host->cmd != NULL);
drivers/mmc/host/pxamci.c:244:	host->cmd = cmd;
drivers/mmc/host/pxamci.c:264:	writel(cmd->opcode, host->base + MMC_CMD);
drivers/mmc/host/pxamci.c:265:	writel(cmd->arg >> 16, host->base + MMC_ARGH);
drivers/mmc/host/pxamci.c:266:	writel(cmd->arg & 0xffff, host->base + MMC_ARGL);
drivers/mmc/host/pxamci.c:267:	writel(cmdat, host->base + MMC_CMDAT);
drivers/mmc/host/pxamci.c:268:	writel(host->clkrt, host->base + MMC_CLKRT);
drivers/mmc/host/pxamci.c:270:	writel(START_CLOCK, host->base + MMC_STRPCL);
drivers/mmc/host/pxamci.c:277:	host->mrq = NULL;
drivers/mmc/host/pxamci.c:278:	host->cmd = NULL;
drivers/mmc/host/pxamci.c:279:	host->data = NULL;
drivers/mmc/host/pxamci.c:280:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/pxamci.c:285:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/pxamci.c:292:	host->cmd = NULL;
drivers/mmc/host/pxamci.c:298:	v = readl(host->base + MMC_RES) & 0xffff;
drivers/mmc/host/pxamci.c:300:		u32 w1 = readl(host->base + MMC_RES) & 0xffff;
drivers/mmc/host/pxamci.c:301:		u32 w2 = readl(host->base + MMC_RES) & 0xffff;
drivers/mmc/host/pxamci.c:323:	if (host->data && !cmd->error) {
drivers/mmc/host/pxamci.c:329:		if (cpu_is_pxa27x() && host->data->flags & MMC_DATA_WRITE)
drivers/mmc/host/pxamci.c:330:			DCSR(host->dma) = DCSR_RUN;
drivers/mmc/host/pxamci.c:332:		pxamci_finish_request(host, host->mrq);
drivers/mmc/host/pxamci.c:340:	struct mmc_data *data = host->data;
drivers/mmc/host/pxamci.c:345:	DCSR(host->dma) = 0;
drivers/mmc/host/pxamci.c:346:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/pxamci.c:347:		     host->dma_dir);
drivers/mmc/host/pxamci.c:367:	host->data = NULL;
drivers/mmc/host/pxamci.c:368:	if (host->mrq->stop) {
drivers/mmc/host/pxamci.c:370:		pxamci_start_cmd(host, host->mrq->stop, host->cmdat);
drivers/mmc/host/pxamci.c:372:		pxamci_finish_request(host, host->mrq);
drivers/mmc/host/pxamci.c:384:	ireg = readl(host->base + MMC_I_REG) & ~readl(host->base + MMC_I_MASK);
drivers/mmc/host/pxamci.c:387:		unsigned stat = readl(host->base + MMC_STAT);
drivers/mmc/host/pxamci.c:396:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/pxamci.c:409:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/pxamci.c:411:	host->mrq = mrq;
drivers/mmc/host/pxamci.c:415:	cmdat = host->cmdat;
drivers/mmc/host/pxamci.c:416:	host->cmdat &= ~CMDAT_INIT;
drivers/mmc/host/pxamci.c:437:	if (host->pdata && gpio_is_valid(host->pdata->gpio_card_ro)) {
drivers/mmc/host/pxamci.c:438:		if (host->pdata->gpio_card_ro_invert)
drivers/mmc/host/pxamci.c:439:			return !gpio_get_value(host->pdata->gpio_card_ro);
drivers/mmc/host/pxamci.c:441:			return gpio_get_value(host->pdata->gpio_card_ro);
drivers/mmc/host/pxamci.c:443:	if (host->pdata && host->pdata->get_ro)
drivers/mmc/host/pxamci.c:444:		return !!host->pdata->get_ro(mmc_dev(mmc));
drivers/mmc/host/pxamci.c:457:		unsigned long rate = host->clkrate;
drivers/mmc/host/pxamci.c:460:		if (host->clkrt == CLKRT_OFF)
drivers/mmc/host/pxamci.c:461:			clk_enable(host->clk);
drivers/mmc/host/pxamci.c:465:			host->clkrt = 7;
drivers/mmc/host/pxamci.c:478:			host->clkrt = fls(clk) - 1;
drivers/mmc/host/pxamci.c:486:		if (host->clkrt != CLKRT_OFF) {
drivers/mmc/host/pxamci.c:487:			host->clkrt = CLKRT_OFF;
drivers/mmc/host/pxamci.c:488:			clk_disable(host->clk);
drivers/mmc/host/pxamci.c:492:	if (host->power_mode != ios->power_mode) {
drivers/mmc/host/pxamci.c:493:		host->power_mode = ios->power_mode;
drivers/mmc/host/pxamci.c:498:			host->cmdat |= CMDAT_INIT;
drivers/mmc/host/pxamci.c:502:		host->cmdat |= CMDAT_SD_4DAT;
drivers/mmc/host/pxamci.c:504:		host->cmdat &= ~CMDAT_SD_4DAT;
drivers/mmc/host/pxamci.c:507:		 host->clkrt, host->cmdat);
drivers/mmc/host/pxamci.c:534:		writel(BUF_PART_FULL, host->base + MMC_PRTBUF);
drivers/mmc/host/pxamci.c:537:		       mmc_hostname(host->mmc), dma, dcsr);
drivers/mmc/host/pxamci.c:538:		host->data->error = -EIO;
drivers/mmc/host/pxamci.c:547:	mmc_detect_change(devid, msecs_to_jiffies(host->pdata->detect_delay_ms));
drivers/mmc/host/pxamci.c:597:	host->mmc = mmc;
drivers/mmc/host/pxamci.c:598:	host->dma = -1;
drivers/mmc/host/pxamci.c:599:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/pxamci.c:600:	host->clkrt = CLKRT_OFF;
drivers/mmc/host/pxamci.c:602:	host->clk = clk_get(&pdev->dev, NULL);
drivers/mmc/host/pxamci.c:603:	if (IS_ERR(host->clk)) {
drivers/mmc/host/pxamci.c:604:		ret = PTR_ERR(host->clk);
drivers/mmc/host/pxamci.c:605:		host->clk = NULL;
drivers/mmc/host/pxamci.c:609:	host->clkrate = clk_get_rate(host->clk);
drivers/mmc/host/pxamci.c:614:	mmc->f_min = (host->clkrate + 63) / 64;
drivers/mmc/host/pxamci.c:615:	mmc->f_max = (mmc_has_26MHz()) ? 26000000 : host->clkrate;
drivers/mmc/host/pxamci.c:620:	host->cmdat = 0;
drivers/mmc/host/pxamci.c:623:		host->cmdat |= CMDAT_SDIO_INT_EN;
drivers/mmc/host/pxamci.c:629:	host->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);
drivers/mmc/host/pxamci.c:630:	if (!host->sg_cpu) {
drivers/mmc/host/pxamci.c:635:	spin_lock_init(&host->lock);
drivers/mmc/host/pxamci.c:636:	host->res = r;
drivers/mmc/host/pxamci.c:637:	host->irq = irq;
drivers/mmc/host/pxamci.c:638:	host->imask = MMC_I_MASK_ALL;
drivers/mmc/host/pxamci.c:640:	host->base = ioremap(r->start, SZ_4K);
drivers/mmc/host/pxamci.c:641:	if (!host->base) {
drivers/mmc/host/pxamci.c:651:	writel(0, host->base + MMC_SPI);
drivers/mmc/host/pxamci.c:652:	writel(64, host->base + MMC_RESTO);
drivers/mmc/host/pxamci.c:653:	writel(host->imask, host->base + MMC_I_MASK);
drivers/mmc/host/pxamci.c:655:	host->dma = pxa_request_dma(DRIVER_NAME, DMA_PRIO_LOW,
drivers/mmc/host/pxamci.c:657:	if (host->dma < 0) {
drivers/mmc/host/pxamci.c:662:	ret = request_irq(host->irq, pxamci_irq, 0, DRIVER_NAME, host);
drivers/mmc/host/pxamci.c:673:	host->dma_drcmrrx = dmarx->start;
drivers/mmc/host/pxamci.c:680:	host->dma_drcmrtx = dmatx->start;
drivers/mmc/host/pxamci.c:682:	if (host->pdata) {
drivers/mmc/host/pxamci.c:683:		gpio_cd = host->pdata->gpio_card_detect;
drivers/mmc/host/pxamci.c:684:		gpio_ro = host->pdata->gpio_card_ro;
drivers/mmc/host/pxamci.c:685:		gpio_power = host->pdata->gpio_power;
drivers/mmc/host/pxamci.c:694:				      host->pdata->gpio_power_invert);
drivers/mmc/host/pxamci.c:721:	if (host->pdata && host->pdata->init)
drivers/mmc/host/pxamci.c:722:		host->pdata->init(&pdev->dev, pxamci_detect_irq, mmc);
drivers/mmc/host/pxamci.c:724:	if (gpio_is_valid(gpio_power) && host->pdata->setpower)
drivers/mmc/host/pxamci.c:726:	if (gpio_is_valid(gpio_ro) && host->pdata->get_ro)
drivers/mmc/host/pxamci.c:741:		if (host->dma >= 0)
drivers/mmc/host/pxamci.c:742:			pxa_free_dma(host->dma);
drivers/mmc/host/pxamci.c:743:		if (host->base)
drivers/mmc/host/pxamci.c:744:			iounmap(host->base);
drivers/mmc/host/pxamci.c:745:		if (host->sg_cpu)
drivers/mmc/host/pxamci.c:746:			dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/pxamci.c:747:		if (host->clk)
drivers/mmc/host/pxamci.c:748:			clk_put(host->clk);
drivers/mmc/host/pxamci.c:768:		if (host->pdata) {
drivers/mmc/host/pxamci.c:769:			gpio_cd = host->pdata->gpio_card_detect;
drivers/mmc/host/pxamci.c:770:			gpio_ro = host->pdata->gpio_card_ro;
drivers/mmc/host/pxamci.c:771:			gpio_power = host->pdata->gpio_power;
drivers/mmc/host/pxamci.c:781:		if (host->vcc)
drivers/mmc/host/pxamci.c:782:			regulator_put(host->vcc);
drivers/mmc/host/pxamci.c:784:		if (host->pdata && host->pdata->exit)
drivers/mmc/host/pxamci.c:785:			host->pdata->exit(&pdev->dev, mmc);
drivers/mmc/host/pxamci.c:790:		       host->base + MMC_I_MASK);
drivers/mmc/host/pxamci.c:792:		DRCMR(host->dma_drcmrrx) = 0;
drivers/mmc/host/pxamci.c:793:		DRCMR(host->dma_drcmrtx) = 0;
drivers/mmc/host/pxamci.c:795:		free_irq(host->irq, host);
drivers/mmc/host/pxamci.c:796:		pxa_free_dma(host->dma);
drivers/mmc/host/pxamci.c:797:		iounmap(host->base);
drivers/mmc/host/pxamci.c:798:		dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/pxamci.c:800:		clk_put(host->clk);
drivers/mmc/host/pxamci.c:802:		release_resource(host->res);
drivers/mmc/host/sh_mmcif.c:195:	writel(val | readl(host->addr + reg), host->addr + reg);
drivers/mmc/host/sh_mmcif.c:201:	writel(~val & readl(host->addr + reg), host->addr + reg);
drivers/mmc/host/sh_mmcif.c:207:	struct sh_mmcif_plat_data *p = host->pd->dev.platform_data;
drivers/mmc/host/sh_mmcif.c:214:	if (p->sup_pclk && clk == host->clk)
drivers/mmc/host/sh_mmcif.c:218:			(ilog2(__rounddown_pow_of_two(host->clk / clk)) << 16));
drivers/mmc/host/sh_mmcif.c:227:	tmp = 0x010f0000 & sh_mmcif_readl(host->addr, MMCIF_CE_CLK_CTRL);
drivers/mmc/host/sh_mmcif.c:229:	sh_mmcif_writel(host->addr, MMCIF_CE_VERSION, SOFT_RST_ON);
drivers/mmc/host/sh_mmcif.c:230:	sh_mmcif_writel(host->addr, MMCIF_CE_VERSION, SOFT_RST_OFF);
drivers/mmc/host/sh_mmcif.c:242:	host->sd_error = 0;
drivers/mmc/host/sh_mmcif.c:243:	host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:245:	state1 = sh_mmcif_readl(host->addr, MMCIF_CE_HOST_STS1);
drivers/mmc/host/sh_mmcif.c:246:	state2 = sh_mmcif_readl(host->addr, MMCIF_CE_HOST_STS2);
drivers/mmc/host/sh_mmcif.c:260:			if (!(sh_mmcif_readl(host->addr, MMCIF_CE_HOST_STS1)
drivers/mmc/host/sh_mmcif.c:290:	host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:294:	time = wait_event_interruptible_timeout(host->intr_wait,
drivers/mmc/host/sh_mmcif.c:295:			host->wait_int == 1 ||
drivers/mmc/host/sh_mmcif.c:296:			host->sd_error == 1, host->timeout);
drivers/mmc/host/sh_mmcif.c:297:	if (host->wait_int != 1 && (time == 0 || host->sd_error != 0))
drivers/mmc/host/sh_mmcif.c:300:	host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:302:			sh_mmcif_readl(host->addr, MMCIF_CE_BLOCK_SET)) + 3;
drivers/mmc/host/sh_mmcif.c:304:		*p++ = sh_mmcif_readl(host->addr, MMCIF_CE_DATA);
drivers/mmc/host/sh_mmcif.c:308:	time = wait_event_interruptible_timeout(host->intr_wait,
drivers/mmc/host/sh_mmcif.c:309:			host->wait_int == 1 ||
drivers/mmc/host/sh_mmcif.c:310:			host->sd_error == 1, host->timeout);
drivers/mmc/host/sh_mmcif.c:311:	if (host->wait_int != 1 && (time == 0 || host->sd_error != 0))
drivers/mmc/host/sh_mmcif.c:314:	host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:325:	blocksize = BLOCK_SIZE_MASK & sh_mmcif_readl(host->addr,
drivers/mmc/host/sh_mmcif.c:329:		host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:333:			time = wait_event_interruptible_timeout(host->intr_wait,
drivers/mmc/host/sh_mmcif.c:334:				host->wait_int == 1 ||
drivers/mmc/host/sh_mmcif.c:335:				host->sd_error == 1, host->timeout);
drivers/mmc/host/sh_mmcif.c:337:			if (host->wait_int != 1 &&
drivers/mmc/host/sh_mmcif.c:338:			    (time == 0 || host->sd_error != 0))
drivers/mmc/host/sh_mmcif.c:341:			host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:343:				*p++ = sh_mmcif_readl(host->addr,
drivers/mmc/host/sh_mmcif.c:359:	host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:363:	time = wait_event_interruptible_timeout(host->intr_wait,
drivers/mmc/host/sh_mmcif.c:364:			host->wait_int == 1 ||
drivers/mmc/host/sh_mmcif.c:365:			host->sd_error == 1, host->timeout);
drivers/mmc/host/sh_mmcif.c:366:	if (host->wait_int != 1 && (time == 0 || host->sd_error != 0))
drivers/mmc/host/sh_mmcif.c:369:	host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:371:			sh_mmcif_readl(host->addr, MMCIF_CE_BLOCK_SET)) + 3;
drivers/mmc/host/sh_mmcif.c:373:		sh_mmcif_writel(host->addr, MMCIF_CE_DATA, *p++);
drivers/mmc/host/sh_mmcif.c:378:	time = wait_event_interruptible_timeout(host->intr_wait,
drivers/mmc/host/sh_mmcif.c:379:			host->wait_int == 1 ||
drivers/mmc/host/sh_mmcif.c:380:			host->sd_error == 1, host->timeout);
drivers/mmc/host/sh_mmcif.c:381:	if (host->wait_int != 1 && (time == 0 || host->sd_error != 0))
drivers/mmc/host/sh_mmcif.c:384:	host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:395:	blocksize = BLOCK_SIZE_MASK & sh_mmcif_readl(host->addr,
drivers/mmc/host/sh_mmcif.c:400:		host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:404:			time = wait_event_interruptible_timeout(host->intr_wait,
drivers/mmc/host/sh_mmcif.c:405:				host->wait_int == 1 ||
drivers/mmc/host/sh_mmcif.c:406:				host->sd_error == 1, host->timeout);
drivers/mmc/host/sh_mmcif.c:408:			if (host->wait_int != 1 &&
drivers/mmc/host/sh_mmcif.c:409:			    (time == 0 || host->sd_error != 0))
drivers/mmc/host/sh_mmcif.c:412:			host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:414:				sh_mmcif_writel(host->addr,
drivers/mmc/host/sh_mmcif.c:427:		cmd->resp[0] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP3);
drivers/mmc/host/sh_mmcif.c:428:		cmd->resp[1] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP2);
drivers/mmc/host/sh_mmcif.c:429:		cmd->resp[2] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP1);
drivers/mmc/host/sh_mmcif.c:430:		cmd->resp[3] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP0);
drivers/mmc/host/sh_mmcif.c:432:		cmd->resp[0] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP0);
drivers/mmc/host/sh_mmcif.c:438:	cmd->resp[0] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP_CMD12);
drivers/mmc/host/sh_mmcif.c:475:	if (host->data) {
drivers/mmc/host/sh_mmcif.c:477:		switch (host->bus_width) {
drivers/mmc/host/sh_mmcif.c:550:	host->cmd = cmd;
drivers/mmc/host/sh_mmcif.c:571:	if (host->data) {
drivers/mmc/host/sh_mmcif.c:572:		sh_mmcif_writel(host->addr, MMCIF_CE_BLOCK_SET, 0);
drivers/mmc/host/sh_mmcif.c:573:		sh_mmcif_writel(host->addr, MMCIF_CE_BLOCK_SET,
drivers/mmc/host/sh_mmcif.c:578:	sh_mmcif_writel(host->addr, MMCIF_CE_INT, 0xD80430C0);
drivers/mmc/host/sh_mmcif.c:579:	sh_mmcif_writel(host->addr, MMCIF_CE_INT_MASK, mask);
drivers/mmc/host/sh_mmcif.c:581:	sh_mmcif_writel(host->addr, MMCIF_CE_ARG, cmd->arg);
drivers/mmc/host/sh_mmcif.c:582:	host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:584:	sh_mmcif_writel(host->addr, MMCIF_CE_CMD_SET, opc);
drivers/mmc/host/sh_mmcif.c:586:	time = wait_event_interruptible_timeout(host->intr_wait,
drivers/mmc/host/sh_mmcif.c:587:		host->wait_int == 1 || host->sd_error == 1, host->timeout);
drivers/mmc/host/sh_mmcif.c:588:	if (host->wait_int != 1 && time == 0) {
drivers/mmc/host/sh_mmcif.c:592:	if (host->sd_error) {
drivers/mmc/host/sh_mmcif.c:605:		host->sd_error = 0;
drivers/mmc/host/sh_mmcif.c:606:		host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:611:		host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:614:	if (host->wait_int == 1) {
drivers/mmc/host/sh_mmcif.c:616:		host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:618:	if (host->data) {
drivers/mmc/host/sh_mmcif.c:644:	time = wait_event_interruptible_timeout(host->intr_wait,
drivers/mmc/host/sh_mmcif.c:645:			host->wait_int == 1 ||
drivers/mmc/host/sh_mmcif.c:646:			host->sd_error == 1, host->timeout);
drivers/mmc/host/sh_mmcif.c:647:	if (host->wait_int != 1 && (time == 0 || host->sd_error != 0)) {
drivers/mmc/host/sh_mmcif.c:652:	host->wait_int = 0;
drivers/mmc/host/sh_mmcif.c:678:	host->data = mrq->data;
drivers/mmc/host/sh_mmcif.c:680:	host->data = NULL;
drivers/mmc/host/sh_mmcif.c:694:	struct sh_mmcif_plat_data *p = host->pd->dev.platform_data;
drivers/mmc/host/sh_mmcif.c:700:			p->down_pwr(host->pd);
drivers/mmc/host/sh_mmcif.c:704:			p->set_pwr(host->pd, ios->power_mode);
drivers/mmc/host/sh_mmcif.c:710:	host->bus_width = ios->bus_width;
drivers/mmc/host/sh_mmcif.c:729:	state = sh_mmcif_readl(host->addr, MMCIF_CE_INT);
drivers/mmc/host/sh_mmcif.c:732:		sh_mmcif_writel(host->addr, MMCIF_CE_INT,
drivers/mmc/host/sh_mmcif.c:736:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~INT_CRSPE);
drivers/mmc/host/sh_mmcif.c:739:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~INT_BUFREN);
drivers/mmc/host/sh_mmcif.c:742:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~INT_BUFWEN);
drivers/mmc/host/sh_mmcif.c:745:		sh_mmcif_writel(host->addr, MMCIF_CE_INT,
drivers/mmc/host/sh_mmcif.c:750:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~INT_BUFRE);
drivers/mmc/host/sh_mmcif.c:753:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~INT_DTRANE);
drivers/mmc/host/sh_mmcif.c:756:		sh_mmcif_writel(host->addr, MMCIF_CE_INT,
drivers/mmc/host/sh_mmcif.c:761:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~state);
drivers/mmc/host/sh_mmcif.c:766:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~state);
drivers/mmc/host/sh_mmcif.c:771:		host->sd_error = 1;
drivers/mmc/host/sh_mmcif.c:774:	host->wait_int = 1;
drivers/mmc/host/sh_mmcif.c:775:	wake_up(&host->intr_wait);
drivers/mmc/host/sh_mmcif.c:818:	host->mmc	= mmc;
drivers/mmc/host/sh_mmcif.c:819:	host->addr	= reg;
drivers/mmc/host/sh_mmcif.c:820:	host->timeout	= 1000;
drivers/mmc/host/sh_mmcif.c:823:	host->hclk = clk_get(&pdev->dev, clk_name);
drivers/mmc/host/sh_mmcif.c:824:	if (IS_ERR(host->hclk)) {
drivers/mmc/host/sh_mmcif.c:826:		ret = PTR_ERR(host->hclk);
drivers/mmc/host/sh_mmcif.c:829:	clk_enable(host->hclk);
drivers/mmc/host/sh_mmcif.c:830:	host->clk = clk_get_rate(host->hclk);
drivers/mmc/host/sh_mmcif.c:831:	host->pd = pdev;
drivers/mmc/host/sh_mmcif.c:833:	init_waitqueue_head(&host->intr_wait);
drivers/mmc/host/sh_mmcif.c:836:	mmc->f_max = host->clk;
drivers/mmc/host/sh_mmcif.c:872:	sh_mmcif_writel(host->addr, MMCIF_CE_INT_MASK, MASK_ALL);
drivers/mmc/host/sh_mmcif.c:873:	sh_mmcif_detect(host->mmc);
drivers/mmc/host/sh_mmcif.c:877:		sh_mmcif_readl(host->addr, MMCIF_CE_VERSION) & 0x0000ffff);
drivers/mmc/host/sh_mmcif.c:881:	clk_disable(host->hclk);
drivers/mmc/host/sh_mmcif.c:895:	sh_mmcif_writel(host->addr, MMCIF_CE_INT_MASK, MASK_ALL);
drivers/mmc/host/sh_mmcif.c:900:	if (host->addr)
drivers/mmc/host/sh_mmcif.c:901:		iounmap(host->addr);
drivers/mmc/host/sh_mmcif.c:904:	mmc_remove_host(host->mmc);
drivers/mmc/host/sh_mmcif.c:909:	clk_disable(host->hclk);
drivers/mmc/host/sh_mmcif.c:910:	mmc_free_host(host->mmc);
drivers/mmc/host/via-sdmmc.c:334:	void __iomem *addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:353:	void __iomem *addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:370:	pm_pcictrl_reg = &(host->pm_pcictrl_reg);
drivers/mmc/host/via-sdmmc.c:371:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:389:	pm_pcictrl_reg = &(host->pm_pcictrl_reg);
drivers/mmc/host/via-sdmmc.c:390:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:406:	pm_sdhc_reg = &(host->pm_sdhc_reg);
drivers/mmc/host/via-sdmmc.c:407:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:426:	pm_sdhc_reg = &(host->pm_sdhc_reg);
drivers/mmc/host/via-sdmmc.c:427:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:443:	if (sdhost->quirks & VIA_CRDR_QUIRK_300MS_PWRDELAY)
drivers/mmc/host/via-sdmmc.c:461:	addrbase = host->ddma_mmiobase;
drivers/mmc/host/via-sdmmc.c:470:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:472:		dev_info(host->mmc->parent, "forcing card speed to 8MHz\n");
drivers/mmc/host/via-sdmmc.c:484:	WARN_ON(host->data);
drivers/mmc/host/via-sdmmc.c:487:	BUG_ON(data->blksz > host->mmc->max_blk_size);
drivers/mmc/host/via-sdmmc.c:488:	BUG_ON(data->blocks > host->mmc->max_blk_count);
drivers/mmc/host/via-sdmmc.c:490:	host->data = data;
drivers/mmc/host/via-sdmmc.c:492:	count = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/via-sdmmc.c:500:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:512:	void __iomem *addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:558:	WARN_ON(host->cmd);
drivers/mmc/host/via-sdmmc.c:561:	mod_timer(&host->timer, jiffies + HZ);
drivers/mmc/host/via-sdmmc.c:562:	host->cmd = cmd;
drivers/mmc/host/via-sdmmc.c:585:		pr_err("%s: cmd->flag is not valid\n", mmc_hostname(host->mmc));
drivers/mmc/host/via-sdmmc.c:612:	if (cmd == host->mrq->stop)
drivers/mmc/host/via-sdmmc.c:617:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:626:	BUG_ON(!host->data);
drivers/mmc/host/via-sdmmc.c:628:	data = host->data;
drivers/mmc/host/via-sdmmc.c:629:	host->data = NULL;
drivers/mmc/host/via-sdmmc.c:636:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/via-sdmmc.c:643:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:648:	via_sdc_get_response(host, host->cmd);
drivers/mmc/host/via-sdmmc.c:650:	host->cmd->error = 0;
drivers/mmc/host/via-sdmmc.c:652:	if (!host->cmd->data)
drivers/mmc/host/via-sdmmc.c:653:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:655:	host->cmd = NULL;
drivers/mmc/host/via-sdmmc.c:667:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:669:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:672:	status = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);
drivers/mmc/host/via-sdmmc.c:674:	writew(status, host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);
drivers/mmc/host/via-sdmmc.c:676:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/via-sdmmc.c:677:	host->mrq = mrq;
drivers/mmc/host/via-sdmmc.c:679:	status = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);
drivers/mmc/host/via-sdmmc.c:680:	if (!(status & VIA_CRDR_SDSTS_SLOTG) || host->reject) {
drivers/mmc/host/via-sdmmc.c:681:		host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/via-sdmmc.c:682:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:688:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:697:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:699:	host->power = (1 << power);
drivers/mmc/host/via-sdmmc.c:701:	gatt = readb(host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:702:	if (host->power == MMC_VDD_165_195)
drivers/mmc/host/via-sdmmc.c:710:	writeb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:713:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:728:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:730:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:767:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:772:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:788:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:790:	status = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);
drivers/mmc/host/via-sdmmc.c:792:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:809:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:811:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:816:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:819:	if (host->power == MMC_VDD_165_195)
drivers/mmc/host/via-sdmmc.c:823:	writeb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:826:	writeb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:829:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:835:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:842:	if (!host->cmd) {
drivers/mmc/host/via-sdmmc.c:845:		       mmc_hostname(host->mmc), intmask);
drivers/mmc/host/via-sdmmc.c:850:		host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/via-sdmmc.c:852:		host->cmd->error = -EILSEQ;
drivers/mmc/host/via-sdmmc.c:854:	if (host->cmd->error)
drivers/mmc/host/via-sdmmc.c:855:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:865:		host->data->error = -ETIMEDOUT;
drivers/mmc/host/via-sdmmc.c:867:		host->data->error = -EILSEQ;
drivers/mmc/host/via-sdmmc.c:883:	spin_lock(&sdhost->lock);
drivers/mmc/host/via-sdmmc.c:885:	addrbase = sdhost->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:892:	addrbase = sdhost->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:905:		schedule_work(&sdhost->carddet_work);
drivers/mmc/host/via-sdmmc.c:923:		       mmc_hostname(sdhost->mmc), sd_status);
drivers/mmc/host/via-sdmmc.c:931:	spin_unlock(&sdhost->lock);
drivers/mmc/host/via-sdmmc.c:943:	spin_lock_irqsave(&sdhost->lock, flags);
drivers/mmc/host/via-sdmmc.c:945:	if (sdhost->mrq) {
drivers/mmc/host/via-sdmmc.c:947:		       "cmd:0x%x\n", mmc_hostname(sdhost->mmc),
drivers/mmc/host/via-sdmmc.c:948:		       sdhost->mrq->cmd->opcode);
drivers/mmc/host/via-sdmmc.c:950:		if (sdhost->data) {
drivers/mmc/host/via-sdmmc.c:952:				sdhost->ddma_mmiobase + VIA_CRDR_DMACTRL);
drivers/mmc/host/via-sdmmc.c:953:			sdhost->data->error = -ETIMEDOUT;
drivers/mmc/host/via-sdmmc.c:956:			if (sdhost->cmd)
drivers/mmc/host/via-sdmmc.c:957:				sdhost->cmd->error = -ETIMEDOUT;
drivers/mmc/host/via-sdmmc.c:959:				sdhost->mrq->cmd->error = -ETIMEDOUT;
drivers/mmc/host/via-sdmmc.c:960:			tasklet_schedule(&sdhost->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:965:	spin_unlock_irqrestore(&sdhost->lock, flags);
drivers/mmc/host/via-sdmmc.c:976:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:978:	del_timer(&host->timer);
drivers/mmc/host/via-sdmmc.c:979:	mrq = host->mrq;
drivers/mmc/host/via-sdmmc.c:980:	host->mrq = NULL;
drivers/mmc/host/via-sdmmc.c:981:	host->cmd = NULL;
drivers/mmc/host/via-sdmmc.c:982:	host->data = NULL;
drivers/mmc/host/via-sdmmc.c:984:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:986:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/via-sdmmc.c:998:	addrbase = host->ddma_mmiobase;
drivers/mmc/host/via-sdmmc.c:1001:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:1003:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:1006:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:1009:		if (host->mrq) {
drivers/mmc/host/via-sdmmc.c:1011:			       mmc_hostname(host->mmc));
drivers/mmc/host/via-sdmmc.c:1012:			host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/via-sdmmc.c:1013:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:1017:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:1021:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:1025:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:1030:	mmc_detect_change(host->mmc, msecs_to_jiffies(500));
drivers/mmc/host/via-sdmmc.c:1035:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/via-sdmmc.c:1040:	init_timer(&host->timer);
drivers/mmc/host/via-sdmmc.c:1041:	host->timer.data = (unsigned long)host;
drivers/mmc/host/via-sdmmc.c:1042:	host->timer.function = via_sdc_timeout;
drivers/mmc/host/via-sdmmc.c:1044:	spin_lock_init(&host->lock);
drivers/mmc/host/via-sdmmc.c:1062:	INIT_WORK(&host->carddet_work, via_sdc_card_detect);
drivers/mmc/host/via-sdmmc.c:1064:	tasklet_init(&host->finish_tasklet, via_sdc_tasklet_finish,
drivers/mmc/host/via-sdmmc.c:1067:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:1121:	sdhost->mmc = mmc;
drivers/mmc/host/via-sdmmc.c:1126:	sdhost->mmiobase = ioremap_nocache(base, len);
drivers/mmc/host/via-sdmmc.c:1127:	if (!sdhost->mmiobase) {
drivers/mmc/host/via-sdmmc.c:1132:	sdhost->sdhc_mmiobase =
drivers/mmc/host/via-sdmmc.c:1133:		sdhost->mmiobase + VIA_CRDR_SDC_OFF;
drivers/mmc/host/via-sdmmc.c:1134:	sdhost->ddma_mmiobase =
drivers/mmc/host/via-sdmmc.c:1135:		sdhost->mmiobase + VIA_CRDR_DDMA_OFF;
drivers/mmc/host/via-sdmmc.c:1136:	sdhost->pcictrl_mmiobase =
drivers/mmc/host/via-sdmmc.c:1137:		sdhost->mmiobase + VIA_CRDR_PCICTRL_OFF;
drivers/mmc/host/via-sdmmc.c:1139:	sdhost->power = MMC_VDD_165_195;
drivers/mmc/host/via-sdmmc.c:1142:	writeb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:1145:	writeb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:1157:	       sdhost->pcictrl_mmiobase + VIA_CRDR_PCIINTCTRL);
drivers/mmc/host/via-sdmmc.c:1159:	       sdhost->pcictrl_mmiobase + VIA_CRDR_PCITMOCTRL);
drivers/mmc/host/via-sdmmc.c:1164:		sdhost->quirks = VIA_CRDR_QUIRK_300MS_PWRDELAY;
drivers/mmc/host/via-sdmmc.c:1171:	iounmap(sdhost->mmiobase);
drivers/mmc/host/via-sdmmc.c:1189:	spin_lock_irqsave(&sdhost->lock, flags);
drivers/mmc/host/via-sdmmc.c:1192:	sdhost->reject = 1;
drivers/mmc/host/via-sdmmc.c:1195:	writeb(0x0, sdhost->pcictrl_mmiobase + VIA_CRDR_PCIINTCTRL);
drivers/mmc/host/via-sdmmc.c:1198:	if (sdhost->mrq) {
drivers/mmc/host/via-sdmmc.c:1200:			"transfer\n", mmc_hostname(sdhost->mmc));
drivers/mmc/host/via-sdmmc.c:1204:			sdhost->ddma_mmiobase + VIA_CRDR_DMACTRL);
drivers/mmc/host/via-sdmmc.c:1206:		sdhost->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/via-sdmmc.c:1207:		if (sdhost->mrq->stop)
drivers/mmc/host/via-sdmmc.c:1208:			sdhost->mrq->stop->error = -ENOMEDIUM;
drivers/mmc/host/via-sdmmc.c:1209:		tasklet_schedule(&sdhost->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:1211:	spin_unlock_irqrestore(&sdhost->lock, flags);
drivers/mmc/host/via-sdmmc.c:1213:	mmc_remove_host(sdhost->mmc);
drivers/mmc/host/via-sdmmc.c:1217:	del_timer_sync(&sdhost->timer);
drivers/mmc/host/via-sdmmc.c:1219:	tasklet_kill(&sdhost->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:1222:	gatt = readb(sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:1224:	writeb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:1226:	iounmap(sdhost->mmiobase);
drivers/mmc/host/via-sdmmc.c:1228:	mmc_free_host(sdhost->mmc);
drivers/mmc/host/via-sdmmc.c:1246:	pm_sdhcreg = &(host->pm_sdhc_reg);
drivers/mmc/host/via-sdmmc.c:1247:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:1283:	ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/via-sdmmc.c:1302:	if (sdhost->power == MMC_VDD_165_195)
drivers/mmc/host/via-sdmmc.c:1306:	writeb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:1309:	writeb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:1323:	ret = mmc_resume_host(sdhost->mmc);
drivers/mmc/host/mmci.c:41: * This must be called with host->lock held
drivers/mmc/host/mmci.c:48:		if (desired >= host->mclk) {
drivers/mmc/host/mmci.c:50:			host->cclk = host->mclk;
drivers/mmc/host/mmci.c:52:			clk = host->mclk / (2 * desired) - 1;
drivers/mmc/host/mmci.c:55:			host->cclk = host->mclk / (2 * (clk + 1));
drivers/mmc/host/mmci.c:57:		if (host->hw_designer == AMBA_VENDOR_ST)
drivers/mmc/host/mmci.c:64:	if (host->mmc->ios.bus_width == MMC_BUS_WIDTH_4)
drivers/mmc/host/mmci.c:66:	if (host->mmc->ios.bus_width == MMC_BUS_WIDTH_8)
drivers/mmc/host/mmci.c:69:	writel(clk, host->base + MMCICLOCK);
drivers/mmc/host/mmci.c:75:	writel(0, host->base + MMCICOMMAND);
drivers/mmc/host/mmci.c:77:	BUG_ON(host->data);
drivers/mmc/host/mmci.c:79:	host->mrq = NULL;
drivers/mmc/host/mmci.c:80:	host->cmd = NULL;
drivers/mmc/host/mmci.c:83:		mrq->data->bytes_xfered = host->data_xfered;
drivers/mmc/host/mmci.c:89:	spin_unlock(&host->lock);
drivers/mmc/host/mmci.c:90:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mmci.c:91:	spin_lock(&host->lock);
drivers/mmc/host/mmci.c:96:	writel(0, host->base + MMCIDATACTRL);
drivers/mmc/host/mmci.c:97:	writel(0, host->base + MMCIMASK1);
drivers/mmc/host/mmci.c:98:	host->data = NULL;
drivers/mmc/host/mmci.c:108:	dev_dbg(mmc_dev(host->mmc), "blksz %04x blks %04x flags %08x\n",
drivers/mmc/host/mmci.c:111:	host->data = data;
drivers/mmc/host/mmci.c:112:	host->size = data->blksz;
drivers/mmc/host/mmci.c:113:	host->data_xfered = 0;
drivers/mmc/host/mmci.c:117:	clks = (unsigned long long)data->timeout_ns * host->cclk;
drivers/mmc/host/mmci.c:122:	base = host->base;
drivers/mmc/host/mmci.c:124:	writel(host->size, base + MMCIDATALENGTH);
drivers/mmc/host/mmci.c:138:		if (host->size < MCI_FIFOSIZE)
drivers/mmc/host/mmci.c:156:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:158:	dev_dbg(mmc_dev(host->mmc), "op %02x arg %08x flags %08x\n",
drivers/mmc/host/mmci.c:175:	host->cmd = cmd;
drivers/mmc/host/mmci.c:186:		host->data_xfered += data->blksz;
drivers/mmc/host/mmci.c:200:		dev_dbg(mmc_dev(host->mmc), "MCI ERROR IRQ (status %08x)\n", status);
drivers/mmc/host/mmci.c:213:		if (host->sg_len && data->flags & MMC_DATA_READ)
drivers/mmc/host/mmci.c:214:			flush_dcache_page(sg_page(host->sg_ptr));
drivers/mmc/host/mmci.c:231:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:233:	host->cmd = NULL;
drivers/mmc/host/mmci.c:247:		if (host->data)
drivers/mmc/host/mmci.c:257:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:260:	int host_remain = host->size;
drivers/mmc/host/mmci.c:288:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:317:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:322:	dev_dbg(mmc_dev(host->mmc), "irq1 (pio) %08x\n", status);
drivers/mmc/host/mmci.c:342:		buffer = mmci_kmap_atomic(host, &flags) + host->sg_off;
drivers/mmc/host/mmci.c:343:		remain = host->sg_ptr->length - host->sg_off;
drivers/mmc/host/mmci.c:356:		host->sg_off += len;
drivers/mmc/host/mmci.c:357:		host->size -= len;
drivers/mmc/host/mmci.c:368:			flush_dcache_page(sg_page(host->sg_ptr));
drivers/mmc/host/mmci.c:380:	if (status & MCI_RXACTIVE && host->size < MCI_FIFOSIZE)
drivers/mmc/host/mmci.c:389:	if (host->size == 0) {
drivers/mmc/host/mmci.c:406:	spin_lock(&host->lock);
drivers/mmc/host/mmci.c:412:		status = readl(host->base + MMCISTATUS);
drivers/mmc/host/mmci.c:413:		status &= readl(host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:414:		writel(status, host->base + MMCICLEAR);
drivers/mmc/host/mmci.c:416:		dev_dbg(mmc_dev(host->mmc), "irq0 (data+cmd) %08x\n", status);
drivers/mmc/host/mmci.c:418:		data = host->data;
drivers/mmc/host/mmci.c:423:		cmd = host->cmd;
drivers/mmc/host/mmci.c:430:	spin_unlock(&host->lock);
drivers/mmc/host/mmci.c:440:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/mmci.c:450:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mmci.c:452:	host->mrq = mrq;
drivers/mmc/host/mmci.c:459:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mmci.c:470:		if(host->vcc &&
drivers/mmc/host/mmci.c:471:		   regulator_is_enabled(host->vcc))
drivers/mmc/host/mmci.c:472:			regulator_disable(host->vcc);
drivers/mmc/host/mmci.c:476:		if (host->vcc)
drivers/mmc/host/mmci.c:478:			mmc_regulator_set_ocr(host->vcc, ios->vdd);
drivers/mmc/host/mmci.c:488:		if (!host->vcc && host->plat->translate_vdd)
drivers/mmc/host/mmci.c:489:			pwr |= host->plat->translate_vdd(mmc_dev(mmc), ios->vdd);
drivers/mmc/host/mmci.c:491:		if (host->hw_designer != AMBA_VENDOR_ST) {
drivers/mmc/host/mmci.c:501:		if (host->hw_designer != AMBA_VENDOR_ST)
drivers/mmc/host/mmci.c:512:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mmci.c:516:	if (host->pwr != pwr) {
drivers/mmc/host/mmci.c:517:		host->pwr = pwr;
drivers/mmc/host/mmci.c:518:		writel(pwr, host->base + MMCIPOWER);
drivers/mmc/host/mmci.c:521:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mmci.c:528:	if (host->gpio_wp == -ENOSYS)
drivers/mmc/host/mmci.c:531:	return gpio_get_value(host->gpio_wp);
drivers/mmc/host/mmci.c:539:	if (host->gpio_cd == -ENOSYS)
drivers/mmc/host/mmci.c:540:		status = host->plat->status(mmc_dev(host->mmc));
drivers/mmc/host/mmci.c:542:		status = !gpio_get_value(host->gpio_cd);
drivers/mmc/host/mmci.c:561:	unsigned int status = mmci_get_cd(host->mmc);
drivers/mmc/host/mmci.c:563:	if (status ^ host->oldstat)
drivers/mmc/host/mmci.c:564:		mmc_detect_change(host->mmc, 0);
drivers/mmc/host/mmci.c:566:	host->oldstat = status;
drivers/mmc/host/mmci.c:567:	mod_timer(&host->timer, jiffies + HZ);
drivers/mmc/host/mmci.c:594:	host->mmc = mmc;
drivers/mmc/host/mmci.c:596:	host->gpio_wp = -ENOSYS;
drivers/mmc/host/mmci.c:597:	host->gpio_cd = -ENOSYS;
drivers/mmc/host/mmci.c:599:	host->hw_designer = amba_manf(dev);
drivers/mmc/host/mmci.c:600:	host->hw_revision = amba_rev(dev);
drivers/mmc/host/mmci.c:601:	dev_dbg(mmc_dev(mmc), "designer ID = 0x%02x\n", host->hw_designer);
drivers/mmc/host/mmci.c:602:	dev_dbg(mmc_dev(mmc), "revision = 0x%01x\n", host->hw_revision);
drivers/mmc/host/mmci.c:604:	host->clk = clk_get(&dev->dev, NULL);
drivers/mmc/host/mmci.c:605:	if (IS_ERR(host->clk)) {
drivers/mmc/host/mmci.c:606:		ret = PTR_ERR(host->clk);
drivers/mmc/host/mmci.c:607:		host->clk = NULL;
drivers/mmc/host/mmci.c:611:	ret = clk_enable(host->clk);
drivers/mmc/host/mmci.c:615:	host->plat = plat;
drivers/mmc/host/mmci.c:616:	host->mclk = clk_get_rate(host->clk);
drivers/mmc/host/mmci.c:622:	if (host->mclk > 100000000) {
drivers/mmc/host/mmci.c:623:		ret = clk_set_rate(host->clk, 100000000);
drivers/mmc/host/mmci.c:626:		host->mclk = clk_get_rate(host->clk);
drivers/mmc/host/mmci.c:628:			host->mclk);
drivers/mmc/host/mmci.c:630:	host->base = ioremap(dev->res.start, resource_size(&dev->res));
drivers/mmc/host/mmci.c:631:	if (!host->base) {
drivers/mmc/host/mmci.c:637:	mmc->f_min = (host->mclk + 511) / 512;
drivers/mmc/host/mmci.c:647:		mmc->f_max = min(host->mclk, plat->f_max);
drivers/mmc/host/mmci.c:649:		mmc->f_max = min(host->mclk, fmax);
drivers/mmc/host/mmci.c:654:	host->vcc = regulator_get(&dev->dev, "vmmc");
drivers/mmc/host/mmci.c:655:	if (IS_ERR(host->vcc))
drivers/mmc/host/mmci.c:656:		host->vcc = NULL;
drivers/mmc/host/mmci.c:658:		int mask = mmc_regulator_get_ocrmask(host->vcc);
drivers/mmc/host/mmci.c:664:			host->mmc->ocr_avail = (u32) mask;
drivers/mmc/host/mmci.c:673:	if (host->vcc == NULL)
drivers/mmc/host/mmci.c:705:	spin_lock_init(&host->lock);
drivers/mmc/host/mmci.c:707:	writel(0, host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:708:	writel(0, host->base + MMCIMASK1);
drivers/mmc/host/mmci.c:709:	writel(0xfff, host->base + MMCICLEAR);
drivers/mmc/host/mmci.c:716:			host->gpio_cd = plat->gpio_cd;
drivers/mmc/host/mmci.c:725:			host->gpio_wp = plat->gpio_wp;
drivers/mmc/host/mmci.c:738:	writel(MCI_IRQENABLE, host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:741:	host->oldstat = mmci_get_cd(host->mmc);
drivers/mmc/host/mmci.c:749:	init_timer(&host->timer);
drivers/mmc/host/mmci.c:750:	host->timer.data = (unsigned long)host;
drivers/mmc/host/mmci.c:751:	host->timer.function = mmci_check_status;
drivers/mmc/host/mmci.c:752:	host->timer.expires = jiffies + HZ;
drivers/mmc/host/mmci.c:753:	add_timer(&host->timer);
drivers/mmc/host/mmci.c:760:	if (host->gpio_wp != -ENOSYS)
drivers/mmc/host/mmci.c:761:		gpio_free(host->gpio_wp);
drivers/mmc/host/mmci.c:763:	if (host->gpio_cd != -ENOSYS)
drivers/mmc/host/mmci.c:764:		gpio_free(host->gpio_cd);
drivers/mmc/host/mmci.c:766:	iounmap(host->base);
drivers/mmc/host/mmci.c:768:	clk_disable(host->clk);
drivers/mmc/host/mmci.c:770:	clk_put(host->clk);
drivers/mmc/host/mmci.c:788:		del_timer_sync(&host->timer);
drivers/mmc/host/mmci.c:792:		writel(0, host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:793:		writel(0, host->base + MMCIMASK1);
drivers/mmc/host/mmci.c:795:		writel(0, host->base + MMCICOMMAND);
drivers/mmc/host/mmci.c:796:		writel(0, host->base + MMCIDATACTRL);
drivers/mmc/host/mmci.c:801:		if (host->gpio_wp != -ENOSYS)
drivers/mmc/host/mmci.c:802:			gpio_free(host->gpio_wp);
drivers/mmc/host/mmci.c:803:		if (host->gpio_cd != -ENOSYS)
drivers/mmc/host/mmci.c:804:			gpio_free(host->gpio_cd);
drivers/mmc/host/mmci.c:806:		iounmap(host->base);
drivers/mmc/host/mmci.c:807:		clk_disable(host->clk);
drivers/mmc/host/mmci.c:808:		clk_put(host->clk);
drivers/mmc/host/mmci.c:810:		if (regulator_is_enabled(host->vcc))
drivers/mmc/host/mmci.c:811:			regulator_disable(host->vcc);
drivers/mmc/host/mmci.c:812:		regulator_put(host->vcc);
drivers/mmc/host/mmci.c:833:			writel(0, host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:847:		writel(MCI_IRQENABLE, host->base + MMCIMASK0);
drivers/mmc/host/sdhci.h:332:	if (unlikely(host->ops->write_l))
drivers/mmc/host/sdhci.h:333:		host->ops->write_l(host, val, reg);
drivers/mmc/host/sdhci.h:335:		writel(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:340:	if (unlikely(host->ops->write_w))
drivers/mmc/host/sdhci.h:341:		host->ops->write_w(host, val, reg);
drivers/mmc/host/sdhci.h:343:		writew(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:348:	if (unlikely(host->ops->write_b))
drivers/mmc/host/sdhci.h:349:		host->ops->write_b(host, val, reg);
drivers/mmc/host/sdhci.h:351:		writeb(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:356:	if (unlikely(host->ops->read_l))
drivers/mmc/host/sdhci.h:357:		return host->ops->read_l(host, reg);
drivers/mmc/host/sdhci.h:359:		return readl(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:364:	if (unlikely(host->ops->read_w))
drivers/mmc/host/sdhci.h:365:		return host->ops->read_w(host, reg);
drivers/mmc/host/sdhci.h:367:		return readw(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:372:	if (unlikely(host->ops->read_b))
drivers/mmc/host/sdhci.h:373:		return host->ops->read_b(host, reg);
drivers/mmc/host/sdhci.h:375:		return readb(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:382:	writel(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:387:	writew(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:392:	writeb(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:397:	return readl(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:402:	return readw(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:407:	return readb(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:418:	return (void *)host->private;
drivers/mmc/host/tmio_mmc.c:44:		for (clock = host->mmc->f_min, clk = 0x80000080;
drivers/mmc/host/tmio_mmc.c:50:	if (host->set_clk_div)
drivers/mmc/host/tmio_mmc.c:51:		host->set_clk_div(host->pdev, (clk>>22) & 1);
drivers/mmc/host/tmio_mmc.c:88:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/tmio_mmc.c:90:	host->mrq = NULL;
drivers/mmc/host/tmio_mmc.c:91:	host->cmd = NULL;
drivers/mmc/host/tmio_mmc.c:92:	host->data = NULL;
drivers/mmc/host/tmio_mmc.c:94:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/tmio_mmc.c:113:	struct mmc_data *data = host->data;
drivers/mmc/host/tmio_mmc.c:133:	host->cmd = cmd;
drivers/mmc/host/tmio_mmc.c:166:	struct mmc_data *data = host->data;
drivers/mmc/host/tmio_mmc.c:177:	sg_virt = tmio_mmc_kmap_atomic(host->sg_ptr, &flags);
drivers/mmc/host/tmio_mmc.c:178:	buf = (unsigned short *)(sg_virt + host->sg_off);
drivers/mmc/host/tmio_mmc.c:180:	count = host->sg_ptr->length - host->sg_off;
drivers/mmc/host/tmio_mmc.c:185:		 count, host->sg_off, data->flags);
drivers/mmc/host/tmio_mmc.c:193:	host->sg_off += count;
drivers/mmc/host/tmio_mmc.c:197:	if (host->sg_off == host->sg_ptr->length)
drivers/mmc/host/tmio_mmc.c:205:	struct mmc_data *data = host->data;
drivers/mmc/host/tmio_mmc.c:208:	host->data = NULL;
drivers/mmc/host/tmio_mmc.c:211:		dev_warn(&host->pdev->dev, "Spurious data end IRQ\n");
drivers/mmc/host/tmio_mmc.c:234:		if (!host->chan_rx)
drivers/mmc/host/tmio_mmc.c:236:		dev_dbg(&host->pdev->dev, "Complete Rx request %p\n",
drivers/mmc/host/tmio_mmc.c:237:			host->mrq);
drivers/mmc/host/tmio_mmc.c:239:		if (!host->chan_tx)
drivers/mmc/host/tmio_mmc.c:241:		dev_dbg(&host->pdev->dev, "Complete Tx request %p\n",
drivers/mmc/host/tmio_mmc.c:242:			host->mrq);
drivers/mmc/host/tmio_mmc.c:257:	struct mmc_data *data = host->data;
drivers/mmc/host/tmio_mmc.c:262:	if (host->chan_tx && (data->flags & MMC_DATA_WRITE)) {
drivers/mmc/host/tmio_mmc.c:273:			tasklet_schedule(&host->dma_complete);
drivers/mmc/host/tmio_mmc.c:275:	} else if (host->chan_rx && (data->flags & MMC_DATA_READ)) {
drivers/mmc/host/tmio_mmc.c:277:		tasklet_schedule(&host->dma_complete);
drivers/mmc/host/tmio_mmc.c:286:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/tmio_mmc.c:289:	if (!host->cmd) {
drivers/mmc/host/tmio_mmc.c:294:	host->cmd = NULL;
drivers/mmc/host/tmio_mmc.c:322:	if (host->data && !cmd->error) {
drivers/mmc/host/tmio_mmc.c:323:		if (host->data->flags & MMC_DATA_READ) {
drivers/mmc/host/tmio_mmc.c:324:			if (!host->chan_rx)
drivers/mmc/host/tmio_mmc.c:327:			struct dma_chan *chan = host->chan_tx;
drivers/mmc/host/tmio_mmc.c:331:				tasklet_schedule(&host->dma_issue);
drivers/mmc/host/tmio_mmc.c:369:			mmc_detect_change(host->mmc, msecs_to_jiffies(100));
drivers/mmc/host/tmio_mmc.c:422:	dev_dbg(&host->pdev->dev, "Command completed\n");
drivers/mmc/host/tmio_mmc.c:424:	if (!host->data)
drivers/mmc/host/tmio_mmc.c:425:		dev_warn(&host->pdev->dev, "NULL data in DMA completion!\n");
drivers/mmc/host/tmio_mmc.c:432:	struct scatterlist *sg = host->sg_ptr;
drivers/mmc/host/tmio_mmc.c:434:	struct dma_chan *chan = host->chan_rx;
drivers/mmc/host/tmio_mmc.c:437:	ret = dma_map_sg(&host->pdev->dev, sg, host->sg_len, DMA_FROM_DEVICE);
drivers/mmc/host/tmio_mmc.c:439:		host->dma_sglen = ret;
drivers/mmc/host/tmio_mmc.c:445:		host->desc = desc;
drivers/mmc/host/tmio_mmc.c:448:		host->cookie = desc->tx_submit(desc);
drivers/mmc/host/tmio_mmc.c:449:		if (host->cookie < 0) {
drivers/mmc/host/tmio_mmc.c:450:			host->desc = NULL;
drivers/mmc/host/tmio_mmc.c:451:			ret = host->cookie;
drivers/mmc/host/tmio_mmc.c:456:	dev_dbg(&host->pdev->dev, "%s(): mapped %d -> %d, cookie %d, rq %p\n",
drivers/mmc/host/tmio_mmc.c:457:		__func__, host->sg_len, ret, host->cookie, host->mrq);
drivers/mmc/host/tmio_mmc.c:459:	if (!host->desc) {
drivers/mmc/host/tmio_mmc.c:463:		host->chan_rx = NULL;
drivers/mmc/host/tmio_mmc.c:466:		chan = host->chan_tx;
drivers/mmc/host/tmio_mmc.c:468:			host->chan_tx = NULL;
drivers/mmc/host/tmio_mmc.c:471:		dev_warn(&host->pdev->dev,
drivers/mmc/host/tmio_mmc.c:476:		host->mrq->cmd->error = ret;
drivers/mmc/host/tmio_mmc.c:480:	dev_dbg(&host->pdev->dev, "%s(): desc %p, cookie %d, sg[%d]\n", __func__,
drivers/mmc/host/tmio_mmc.c:481:		desc, host->cookie, host->sg_len);
drivers/mmc/host/tmio_mmc.c:488:	struct scatterlist *sg = host->sg_ptr;
drivers/mmc/host/tmio_mmc.c:490:	struct dma_chan *chan = host->chan_tx;
drivers/mmc/host/tmio_mmc.c:493:	ret = dma_map_sg(&host->pdev->dev, sg, host->sg_len, DMA_TO_DEVICE);
drivers/mmc/host/tmio_mmc.c:495:		host->dma_sglen = ret;
drivers/mmc/host/tmio_mmc.c:501:		host->desc = desc;
drivers/mmc/host/tmio_mmc.c:504:		host->cookie = desc->tx_submit(desc);
drivers/mmc/host/tmio_mmc.c:505:		if (host->cookie < 0) {
drivers/mmc/host/tmio_mmc.c:506:			host->desc = NULL;
drivers/mmc/host/tmio_mmc.c:507:			ret = host->cookie;
drivers/mmc/host/tmio_mmc.c:510:	dev_dbg(&host->pdev->dev, "%s(): mapped %d -> %d, cookie %d, rq %p\n",
drivers/mmc/host/tmio_mmc.c:511:		__func__, host->sg_len, ret, host->cookie, host->mrq);
drivers/mmc/host/tmio_mmc.c:513:	if (!host->desc) {
drivers/mmc/host/tmio_mmc.c:517:		host->chan_tx = NULL;
drivers/mmc/host/tmio_mmc.c:520:		chan = host->chan_rx;
drivers/mmc/host/tmio_mmc.c:522:			host->chan_rx = NULL;
drivers/mmc/host/tmio_mmc.c:525:		dev_warn(&host->pdev->dev,
drivers/mmc/host/tmio_mmc.c:530:		host->mrq->cmd->error = ret;
drivers/mmc/host/tmio_mmc.c:534:	dev_dbg(&host->pdev->dev, "%s(): desc %p, cookie %d\n", __func__,
drivers/mmc/host/tmio_mmc.c:535:		desc, host->cookie);
drivers/mmc/host/tmio_mmc.c:544:		if (host->chan_rx)
drivers/mmc/host/tmio_mmc.c:547:		if (host->chan_tx)
drivers/mmc/host/tmio_mmc.c:557:	struct dma_chan *chan = host->chan_tx;
drivers/mmc/host/tmio_mmc.c:566:	if (host->data->flags & MMC_DATA_READ)
drivers/mmc/host/tmio_mmc.c:567:		dma_unmap_sg(&host->pdev->dev, host->sg_ptr, host->dma_sglen,
drivers/mmc/host/tmio_mmc.c:570:		dma_unmap_sg(&host->pdev->dev, host->sg_ptr, host->dma_sglen,
drivers/mmc/host/tmio_mmc.c:587:	host->cookie = -EINVAL;
drivers/mmc/host/tmio_mmc.c:588:	host->desc = NULL;
drivers/mmc/host/tmio_mmc.c:597:		host->chan_tx = dma_request_channel(mask, tmio_mmc_filter,
drivers/mmc/host/tmio_mmc.c:599:		dev_dbg(&host->pdev->dev, "%s: TX: got channel %p\n", __func__,
drivers/mmc/host/tmio_mmc.c:600:			host->chan_tx);
drivers/mmc/host/tmio_mmc.c:602:		if (!host->chan_tx)
drivers/mmc/host/tmio_mmc.c:605:		host->chan_rx = dma_request_channel(mask, tmio_mmc_filter,
drivers/mmc/host/tmio_mmc.c:607:		dev_dbg(&host->pdev->dev, "%s: RX: got channel %p\n", __func__,
drivers/mmc/host/tmio_mmc.c:608:			host->chan_rx);
drivers/mmc/host/tmio_mmc.c:610:		if (!host->chan_rx) {
drivers/mmc/host/tmio_mmc.c:611:			dma_release_channel(host->chan_tx);
drivers/mmc/host/tmio_mmc.c:612:			host->chan_tx = NULL;
drivers/mmc/host/tmio_mmc.c:616:		tasklet_init(&host->dma_complete, tmio_tasklet_fn, (unsigned long)host);
drivers/mmc/host/tmio_mmc.c:617:		tasklet_init(&host->dma_issue, tmio_issue_tasklet_fn, (unsigned long)host);
drivers/mmc/host/tmio_mmc.c:625:	if (host->chan_tx) {
drivers/mmc/host/tmio_mmc.c:626:		struct dma_chan *chan = host->chan_tx;
drivers/mmc/host/tmio_mmc.c:627:		host->chan_tx = NULL;
drivers/mmc/host/tmio_mmc.c:630:	if (host->chan_rx) {
drivers/mmc/host/tmio_mmc.c:631:		struct dma_chan *chan = host->chan_rx;
drivers/mmc/host/tmio_mmc.c:632:		host->chan_rx = NULL;
drivers/mmc/host/tmio_mmc.c:636:	host->cookie = -EINVAL;
drivers/mmc/host/tmio_mmc.c:637:	host->desc = NULL;
drivers/mmc/host/tmio_mmc.c:649:	host->chan_tx = NULL;
drivers/mmc/host/tmio_mmc.c:650:	host->chan_rx = NULL;
drivers/mmc/host/tmio_mmc.c:665:	if (data->blksz < 4 && host->mmc->ios.bus_width == MMC_BUS_WIDTH_4) {
drivers/mmc/host/tmio_mmc.c:667:		       mmc_hostname(host->mmc), data->blksz);
drivers/mmc/host/tmio_mmc.c:672:	host->data = data;
drivers/mmc/host/tmio_mmc.c:687:	if (host->mrq)
drivers/mmc/host/tmio_mmc.c:690:	host->mrq = mrq;
drivers/mmc/host/tmio_mmc.c:723:		if (host->set_pwr)
drivers/mmc/host/tmio_mmc.c:724:			host->set_pwr(host->pdev, 0);
drivers/mmc/host/tmio_mmc.c:728:		if (host->set_pwr)
drivers/mmc/host/tmio_mmc.c:729:			host->set_pwr(host->pdev, 1);
drivers/mmc/host/tmio_mmc.c:752:	struct mfd_cell	*cell = host->pdev->dev.platform_data;
drivers/mmc/host/tmio_mmc.c:832:	host->mmc = mmc;
drivers/mmc/host/tmio_mmc.c:833:	host->pdev = dev;
drivers/mmc/host/tmio_mmc.c:836:	host->set_pwr = pdata->set_pwr;
drivers/mmc/host/tmio_mmc.c:837:	host->set_clk_div = pdata->set_clk_div;
drivers/mmc/host/tmio_mmc.c:840:	host->bus_shift = resource_size(res_ctl) >> 10;
drivers/mmc/host/tmio_mmc.c:842:	host->ctl = ioremap(res_ctl->start, resource_size(res_ctl));
drivers/mmc/host/tmio_mmc.c:843:	if (!host->ctl)
drivers/mmc/host/tmio_mmc.c:868:		host->irq = ret;
drivers/mmc/host/tmio_mmc.c:874:	ret = request_irq(host->irq, tmio_mmc_irq, IRQF_DISABLED |
drivers/mmc/host/tmio_mmc.c:884:	pr_info("%s at 0x%08lx irq %d\n", mmc_hostname(host->mmc),
drivers/mmc/host/tmio_mmc.c:885:		(unsigned long)host->ctl, host->irq);
drivers/mmc/host/tmio_mmc.c:888:	if (!host->chan_rx)
drivers/mmc/host/tmio_mmc.c:890:	if (!host->chan_tx)
drivers/mmc/host/tmio_mmc.c:900:	iounmap(host->ctl);
drivers/mmc/host/tmio_mmc.c:918:		free_irq(host->irq, host);
drivers/mmc/host/tmio_mmc.c:921:		iounmap(host->ctl);
drivers/mmc/host/wbsd.c:89:	BUG_ON(host->config == 0);
drivers/mmc/host/wbsd.c:91:	outb(host->unlock_code, host->config);
drivers/mmc/host/wbsd.c:92:	outb(host->unlock_code, host->config);
drivers/mmc/host/wbsd.c:97:	BUG_ON(host->config == 0);
drivers/mmc/host/wbsd.c:99:	outb(LOCK_CODE, host->config);
drivers/mmc/host/wbsd.c:104:	BUG_ON(host->config == 0);
drivers/mmc/host/wbsd.c:106:	outb(reg, host->config);
drivers/mmc/host/wbsd.c:107:	outb(value, host->config + 1);
drivers/mmc/host/wbsd.c:112:	BUG_ON(host->config == 0);
drivers/mmc/host/wbsd.c:114:	outb(reg, host->config);
drivers/mmc/host/wbsd.c:115:	return inb(host->config + 1);
drivers/mmc/host/wbsd.c:120:	outb(index, host->base + WBSD_IDXR);
drivers/mmc/host/wbsd.c:121:	outb(value, host->base + WBSD_DATAR);
drivers/mmc/host/wbsd.c:126:	outb(index, host->base + WBSD_IDXR);
drivers/mmc/host/wbsd.c:127:	return inb(host->base + WBSD_DATAR);
drivers/mmc/host/wbsd.c:150:	host->flags &= ~WBSD_FIGNORE_DETECT;
drivers/mmc/host/wbsd.c:155:	host->clk = wbsd_read_index(host, WBSD_IDX_CLK);
drivers/mmc/host/wbsd.c:160:	outb(WBSD_POWER_N, host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:170:	if (inb(host->base + WBSD_CSR) & WBSD_CARDPRESENT)
drivers/mmc/host/wbsd.c:171:		host->flags |= WBSD_FCARD_PRESENT;
drivers/mmc/host/wbsd.c:173:		host->flags &= ~WBSD_FCARD_PRESENT;
drivers/mmc/host/wbsd.c:185:	outb(ier, host->base + WBSD_EIR);
drivers/mmc/host/wbsd.c:190:	inb(host->base + WBSD_ISR);
drivers/mmc/host/wbsd.c:197:	printk(KERN_ERR "%s: Resetting chip\n", mmc_hostname(host->mmc));
drivers/mmc/host/wbsd.c:211:	if (host->dma >= 0) {
drivers/mmc/host/wbsd.c:216:		disable_dma(host->dma);
drivers/mmc/host/wbsd.c:217:		clear_dma_ff(host->dma);
drivers/mmc/host/wbsd.c:226:	host->mrq = NULL;
drivers/mmc/host/wbsd.c:231:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:232:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/wbsd.c:233:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:245:	host->cur_sg = data->sg;
drivers/mmc/host/wbsd.c:246:	host->num_sg = data->sg_len;
drivers/mmc/host/wbsd.c:248:	host->offset = 0;
drivers/mmc/host/wbsd.c:249:	host->remain = host->cur_sg->length;
drivers/mmc/host/wbsd.c:257:	host->cur_sg++;
drivers/mmc/host/wbsd.c:258:	host->num_sg--;
drivers/mmc/host/wbsd.c:263:	if (host->num_sg > 0) {
drivers/mmc/host/wbsd.c:264:		host->offset = 0;
drivers/mmc/host/wbsd.c:265:		host->remain = host->cur_sg->length;
drivers/mmc/host/wbsd.c:268:	return host->num_sg;
drivers/mmc/host/wbsd.c:273:	return sg_virt(host->cur_sg);
drivers/mmc/host/wbsd.c:280:	char *dmabuf = host->dma_buffer;
drivers/mmc/host/wbsd.c:297:	char *dmabuf = host->dma_buffer;
drivers/mmc/host/wbsd.c:367:	host->isr = 0;
drivers/mmc/host/wbsd.c:372:	outb(cmd->opcode, host->base + WBSD_CMDR);
drivers/mmc/host/wbsd.c:374:		outb((cmd->arg >> (i * 8)) & 0xff, host->base + WBSD_CMDR);
drivers/mmc/host/wbsd.c:392:		isr = host->isr;
drivers/mmc/host/wbsd.c:419:	struct mmc_data *data = host->mrq->cmd->data;
drivers/mmc/host/wbsd.c:426:	if (host->num_sg == 0)
drivers/mmc/host/wbsd.c:429:	buffer = wbsd_sg_to_buffer(host) + host->offset;
drivers/mmc/host/wbsd.c:435:	while (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_EMPTY)) {
drivers/mmc/host/wbsd.c:448:			*buffer = inb(host->base + WBSD_DFR);
drivers/mmc/host/wbsd.c:450:			host->offset++;
drivers/mmc/host/wbsd.c:451:			host->remain--;
drivers/mmc/host/wbsd.c:458:			if (host->remain == 0) {
drivers/mmc/host/wbsd.c:476:		tasklet_schedule(&host->fifo_tasklet);
drivers/mmc/host/wbsd.c:481:	struct mmc_data *data = host->mrq->cmd->data;
drivers/mmc/host/wbsd.c:489:	if (host->num_sg == 0)
drivers/mmc/host/wbsd.c:492:	buffer = wbsd_sg_to_buffer(host) + host->offset;
drivers/mmc/host/wbsd.c:498:	while (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_FULL)) {
drivers/mmc/host/wbsd.c:511:			outb(*buffer, host->base + WBSD_DFR);
drivers/mmc/host/wbsd.c:513:			host->offset++;
drivers/mmc/host/wbsd.c:514:			host->remain--;
drivers/mmc/host/wbsd.c:521:			if (host->remain == 0) {
drivers/mmc/host/wbsd.c:538:	tasklet_schedule(&host->fifo_tasklet);
drivers/mmc/host/wbsd.c:577:	if (host->bus_width == MMC_BUS_WIDTH_1) {
drivers/mmc/host/wbsd.c:582:	} else if (host->bus_width == MMC_BUS_WIDTH_4) {
drivers/mmc/host/wbsd.c:605:	if (host->dma >= 0) {
drivers/mmc/host/wbsd.c:626:		disable_dma(host->dma);
drivers/mmc/host/wbsd.c:627:		clear_dma_ff(host->dma);
drivers/mmc/host/wbsd.c:629:			set_dma_mode(host->dma, DMA_MODE_READ & ~0x40);
drivers/mmc/host/wbsd.c:631:			set_dma_mode(host->dma, DMA_MODE_WRITE & ~0x40);
drivers/mmc/host/wbsd.c:632:		set_dma_addr(host->dma, host->dma_addr);
drivers/mmc/host/wbsd.c:633:		set_dma_count(host->dma, size);
drivers/mmc/host/wbsd.c:635:		enable_dma(host->dma);
drivers/mmc/host/wbsd.c:647:		host->firsterr = 1;
drivers/mmc/host/wbsd.c:682:	WARN_ON(host->mrq == NULL);
drivers/mmc/host/wbsd.c:701:	if (host->dma >= 0) {
drivers/mmc/host/wbsd.c:711:		disable_dma(host->dma);
drivers/mmc/host/wbsd.c:712:		clear_dma_ff(host->dma);
drivers/mmc/host/wbsd.c:713:		count = get_dma_residue(host->dma);
drivers/mmc/host/wbsd.c:716:		data->bytes_xfered = host->mrq->data->blocks *
drivers/mmc/host/wbsd.c:717:			host->mrq->data->blksz - count;
drivers/mmc/host/wbsd.c:726:				mmc_hostname(host->mmc), count);
drivers/mmc/host/wbsd.c:745:	wbsd_request_end(host, host->mrq);
drivers/mmc/host/wbsd.c:762:	spin_lock_bh(&host->lock);
drivers/mmc/host/wbsd.c:764:	BUG_ON(host->mrq != NULL);
drivers/mmc/host/wbsd.c:768:	host->mrq = mrq;
drivers/mmc/host/wbsd.c:773:	if (!(host->flags & WBSD_FCARD_PRESENT)) {
drivers/mmc/host/wbsd.c:808:				mmc_hostname(host->mmc), cmd->opcode);
drivers/mmc/host/wbsd.c:837:		if (host->dma == -1)
drivers/mmc/host/wbsd.c:838:			tasklet_schedule(&host->fifo_tasklet);
drivers/mmc/host/wbsd.c:840:		spin_unlock_bh(&host->lock);
drivers/mmc/host/wbsd.c:848:	spin_unlock_bh(&host->lock);
drivers/mmc/host/wbsd.c:856:	spin_lock_bh(&host->lock);
drivers/mmc/host/wbsd.c:878:	if (clk != host->clk) {
drivers/mmc/host/wbsd.c:880:		host->clk = clk;
drivers/mmc/host/wbsd.c:887:		pwr = inb(host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:889:		outb(pwr, host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:901:		host->flags |= WBSD_FIGNORE_DETECT;
drivers/mmc/host/wbsd.c:910:			mod_timer(&host->ignore_timer, jiffies + HZ / 100);
drivers/mmc/host/wbsd.c:919:	host->bus_width = ios->bus_width;
drivers/mmc/host/wbsd.c:921:	spin_unlock_bh(&host->lock);
drivers/mmc/host/wbsd.c:929:	spin_lock_bh(&host->lock);
drivers/mmc/host/wbsd.c:931:	csr = inb(host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:933:	outb(csr, host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:937:	csr = inb(host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:939:	outb(csr, host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:941:	spin_unlock_bh(&host->lock);
drivers/mmc/host/wbsd.c:970:	spin_lock_bh(&host->lock);
drivers/mmc/host/wbsd.c:972:	host->flags &= ~WBSD_FIGNORE_DETECT;
drivers/mmc/host/wbsd.c:978:	tasklet_schedule(&host->card_tasklet);
drivers/mmc/host/wbsd.c:980:	spin_unlock_bh(&host->lock);
drivers/mmc/host/wbsd.c:989:	WARN_ON(!host->mrq);
drivers/mmc/host/wbsd.c:990:	if (!host->mrq)
drivers/mmc/host/wbsd.c:993:	WARN_ON(!host->mrq->cmd);
drivers/mmc/host/wbsd.c:994:	if (!host->mrq->cmd)
drivers/mmc/host/wbsd.c:997:	WARN_ON(!host->mrq->cmd->data);
drivers/mmc/host/wbsd.c:998:	if (!host->mrq->cmd->data)
drivers/mmc/host/wbsd.c:1001:	return host->mrq->cmd->data;
drivers/mmc/host/wbsd.c:1010:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:1012:	if (host->flags & WBSD_FIGNORE_DETECT) {
drivers/mmc/host/wbsd.c:1013:		spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:1017:	csr = inb(host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:1021:		if (!(host->flags & WBSD_FCARD_PRESENT)) {
drivers/mmc/host/wbsd.c:1023:			host->flags |= WBSD_FCARD_PRESENT;
drivers/mmc/host/wbsd.c:1027:	} else if (host->flags & WBSD_FCARD_PRESENT) {
drivers/mmc/host/wbsd.c:1029:		host->flags &= ~WBSD_FCARD_PRESENT;
drivers/mmc/host/wbsd.c:1031:		if (host->mrq) {
drivers/mmc/host/wbsd.c:1033:				mmc_hostname(host->mmc));
drivers/mmc/host/wbsd.c:1036:			host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/wbsd.c:1037:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:1047:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:1050:		mmc_detect_change(host->mmc, msecs_to_jiffies(delay));
drivers/mmc/host/wbsd.c:1058:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:1060:	if (!host->mrq)
drivers/mmc/host/wbsd.c:1075:	if (host->num_sg == 0) {
drivers/mmc/host/wbsd.c:1077:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:1081:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:1089:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:1091:	if (!host->mrq)
drivers/mmc/host/wbsd.c:1102:	tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:1105:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:1113:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:1115:	if (!host->mrq)
drivers/mmc/host/wbsd.c:1126:	tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:1129:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:1137:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:1139:	WARN_ON(!host->mrq);
drivers/mmc/host/wbsd.c:1140:	if (!host->mrq)
drivers/mmc/host/wbsd.c:1150:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:1162:	isr = inb(host->base + WBSD_ISR);
drivers/mmc/host/wbsd.c:1170:	host->isr |= isr;
drivers/mmc/host/wbsd.c:1176:		tasklet_schedule(&host->card_tasklet);
drivers/mmc/host/wbsd.c:1178:		tasklet_schedule(&host->fifo_tasklet);
drivers/mmc/host/wbsd.c:1180:		tasklet_hi_schedule(&host->crc_tasklet);
drivers/mmc/host/wbsd.c:1182:		tasklet_hi_schedule(&host->timeout_tasklet);
drivers/mmc/host/wbsd.c:1184:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:1212:	host->mmc = mmc;
drivers/mmc/host/wbsd.c:1214:	host->dma = -1;
drivers/mmc/host/wbsd.c:1225:	spin_lock_init(&host->lock);
drivers/mmc/host/wbsd.c:1230:	init_timer(&host->ignore_timer);
drivers/mmc/host/wbsd.c:1231:	host->ignore_timer.data = (unsigned long)host;
drivers/mmc/host/wbsd.c:1232:	host->ignore_timer.function = wbsd_reset_ignore;
drivers/mmc/host/wbsd.c:1281:	del_timer_sync(&host->ignore_timer);
drivers/mmc/host/wbsd.c:1308:			host->config = config_ports[i];
drivers/mmc/host/wbsd.c:1309:			host->unlock_code = unlock_codes[j];
drivers/mmc/host/wbsd.c:1323:					host->chip_id = id;
drivers/mmc/host/wbsd.c:1338:	host->config = 0;
drivers/mmc/host/wbsd.c:1339:	host->unlock_code = 0;
drivers/mmc/host/wbsd.c:1356:	host->base = base;
drivers/mmc/host/wbsd.c:1363:	if (host->base)
drivers/mmc/host/wbsd.c:1364:		release_region(host->base, 8);
drivers/mmc/host/wbsd.c:1366:	host->base = 0;
drivers/mmc/host/wbsd.c:1368:	if (host->config)
drivers/mmc/host/wbsd.c:1369:		release_region(host->config, 2);
drivers/mmc/host/wbsd.c:1371:	host->config = 0;
drivers/mmc/host/wbsd.c:1390:	host->dma_buffer = kmalloc(WBSD_DMA_SIZE,
drivers/mmc/host/wbsd.c:1392:	if (!host->dma_buffer)
drivers/mmc/host/wbsd.c:1398:	host->dma_addr = dma_map_single(mmc_dev(host->mmc), host->dma_buffer,
drivers/mmc/host/wbsd.c:1404:	if ((host->dma_addr & 0xffff) != 0)
drivers/mmc/host/wbsd.c:1409:	else if (host->dma_addr >= 0x1000000)
drivers/mmc/host/wbsd.c:1412:	host->dma = dma;
drivers/mmc/host/wbsd.c:1422:	dma_unmap_single(mmc_dev(host->mmc), host->dma_addr,
drivers/mmc/host/wbsd.c:1424:	host->dma_addr = 0;
drivers/mmc/host/wbsd.c:1426:	kfree(host->dma_buffer);
drivers/mmc/host/wbsd.c:1427:	host->dma_buffer = NULL;
drivers/mmc/host/wbsd.c:1439:	if (host->dma_addr) {
drivers/mmc/host/wbsd.c:1440:		dma_unmap_single(mmc_dev(host->mmc), host->dma_addr,
drivers/mmc/host/wbsd.c:1443:	kfree(host->dma_buffer);
drivers/mmc/host/wbsd.c:1444:	if (host->dma >= 0)
drivers/mmc/host/wbsd.c:1445:		free_dma(host->dma);
drivers/mmc/host/wbsd.c:1447:	host->dma = -1;
drivers/mmc/host/wbsd.c:1448:	host->dma_buffer = NULL;
drivers/mmc/host/wbsd.c:1449:	host->dma_addr = 0;
drivers/mmc/host/wbsd.c:1463:	tasklet_init(&host->card_tasklet, wbsd_tasklet_card,
drivers/mmc/host/wbsd.c:1465:	tasklet_init(&host->fifo_tasklet, wbsd_tasklet_fifo,
drivers/mmc/host/wbsd.c:1467:	tasklet_init(&host->crc_tasklet, wbsd_tasklet_crc,
drivers/mmc/host/wbsd.c:1469:	tasklet_init(&host->timeout_tasklet, wbsd_tasklet_timeout,
drivers/mmc/host/wbsd.c:1471:	tasklet_init(&host->finish_tasklet, wbsd_tasklet_finish,
drivers/mmc/host/wbsd.c:1481:	host->irq = irq;
drivers/mmc/host/wbsd.c:1488:	if (!host->irq)
drivers/mmc/host/wbsd.c:1491:	free_irq(host->irq, host);
drivers/mmc/host/wbsd.c:1493:	host->irq = 0;
drivers/mmc/host/wbsd.c:1495:	tasklet_kill(&host->card_tasklet);
drivers/mmc/host/wbsd.c:1496:	tasklet_kill(&host->fifo_tasklet);
drivers/mmc/host/wbsd.c:1497:	tasklet_kill(&host->crc_tasklet);
drivers/mmc/host/wbsd.c:1498:	tasklet_kill(&host->timeout_tasklet);
drivers/mmc/host/wbsd.c:1499:	tasklet_kill(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:1571:	wbsd_write_config(host, WBSD_CONF_PORT_HI, host->base >> 8);
drivers/mmc/host/wbsd.c:1572:	wbsd_write_config(host, WBSD_CONF_PORT_LO, host->base & 0xff);
drivers/mmc/host/wbsd.c:1574:	wbsd_write_config(host, WBSD_CONF_IRQ, host->irq);
drivers/mmc/host/wbsd.c:1576:	if (host->dma >= 0)
drivers/mmc/host/wbsd.c:1577:		wbsd_write_config(host, WBSD_CONF_DRQ, host->dma);
drivers/mmc/host/wbsd.c:1618:	if (base != host->base)
drivers/mmc/host/wbsd.c:1620:	if (irq != host->irq)
drivers/mmc/host/wbsd.c:1622:	if ((dma != host->dma) && (host->dma != -1))
drivers/mmc/host/wbsd.c:1691:		if ((host->config != 0) && !wbsd_chip_validate(host)) {
drivers/mmc/host/wbsd.c:1706:	if (host->config) {
drivers/mmc/host/wbsd.c:1725:	if (host->chip_id != 0)
drivers/mmc/host/wbsd.c:1726:		printk(" id %x", (int)host->chip_id);
drivers/mmc/host/wbsd.c:1727:	printk(" at 0x%x irq %d", (int)host->base, (int)host->irq);
drivers/mmc/host/wbsd.c:1728:	if (host->dma >= 0)
drivers/mmc/host/wbsd.c:1729:		printk(" dma %d", (int)host->dma);
drivers/mmc/host/wbsd.c:1822:	return mmc_suspend_host(host->mmc);
drivers/mmc/host/wbsd.c:1831:	return mmc_resume_host(host->mmc);
drivers/mmc/host/wbsd.c:1911:	if (host->config != 0) {
drivers/mmc/host/mmci.h:188:	host->sg_len = data->sg_len;
drivers/mmc/host/mmci.h:189:	host->sg_ptr = data->sg;
drivers/mmc/host/mmci.h:190:	host->sg_off = 0;
drivers/mmc/host/mmci.h:195:	host->sg_ptr++;
drivers/mmc/host/mmci.h:196:	host->sg_off = 0;
drivers/mmc/host/mmci.h:197:	return --host->sg_len;
drivers/mmc/host/mmci.h:202:	struct scatterlist *sg = host->sg_ptr;
drivers/mmc/host/sdhci-s3c.c:73:	u32 tmp = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
drivers/mmc/host/sdhci-s3c.c:75:	if (get_curclk(tmp) != ourhost->cur_clk) {
drivers/mmc/host/sdhci-s3c.c:76:		dev_dbg(&ourhost->pdev->dev, "restored ctrl2 clock setting\n");
drivers/mmc/host/sdhci-s3c.c:79:		tmp |= ourhost->cur_clk << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;
drivers/mmc/host/sdhci-s3c.c:80:		writel(tmp, host->ioaddr + S3C_SDHCI_CONTROL2);
drivers/mmc/host/sdhci-s3c.c:102:		busclk = ourhost->clk_bus[clk];
drivers/mmc/host/sdhci-s3c.c:123:	struct s3c_sdhci_platdata *pdata = ourhost->pdata;
drivers/mmc/host/sdhci-s3c.c:133:			tmp = readb(host->ioaddr + SDHCI_HOST_CONTROL);
drivers/mmc/host/sdhci-s3c.c:135:				host->ioaddr + SDHCI_HOST_CONTROL);
drivers/mmc/host/sdhci-s3c.c:149:				pdata->cfg_gpio(ourhost->pdev, width);
drivers/mmc/host/sdhci-s3c.c:155:		pdata->cfg_card(ourhost->pdev, host->ioaddr,
drivers/mmc/host/sdhci-s3c.c:156:				ios, host->mmc->card);
drivers/mmc/host/sdhci-s3c.c:173:	struct clk *clksrc = ourhost->clk_bus[src];
drivers/mmc/host/sdhci-s3c.c:186:	dev_dbg(&ourhost->pdev->dev, "clk %d: rate %ld, want %d, got %ld\n",
drivers/mmc/host/sdhci-s3c.c:221:	dev_dbg(&ourhost->pdev->dev,
drivers/mmc/host/sdhci-s3c.c:227:	if (ourhost->cur_clk != best_src) {
drivers/mmc/host/sdhci-s3c.c:228:		struct clk *clk = ourhost->clk_bus[best_src];
drivers/mmc/host/sdhci-s3c.c:231:		writew(0, host->ioaddr + SDHCI_CLOCK_CONTROL);
drivers/mmc/host/sdhci-s3c.c:233:		ourhost->cur_clk = best_src;
drivers/mmc/host/sdhci-s3c.c:234:		host->max_clk = clk_get_rate(clk);
drivers/mmc/host/sdhci-s3c.c:235:		host->timeout_clk = sdhci_s3c_get_timeout_clk(host);
drivers/mmc/host/sdhci-s3c.c:237:		ctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
drivers/mmc/host/sdhci-s3c.c:240:		writel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);
drivers/mmc/host/sdhci-s3c.c:267:		detect = readl(host->ioaddr + SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT;
drivers/mmc/host/sdhci-s3c.c:278:	struct s3c_sdhci_platdata *pdata = ourhost->pdata;
drivers/mmc/host/sdhci-s3c.c:281:		pdata->adjust_cfg_card(pdata, host->ioaddr, rw);
drivers/mmc/host/sdhci-s3c.c:302:	mmc_detect_change(host->mmc, msecs_to_jiffies(60));
drivers/mmc/host/sdhci-s3c.c:317:		sc->host->flags |= SDHCI_DEVICE_ALIVE;
drivers/mmc/host/sdhci-s3c.c:320:		sc->host->flags &= ~SDHCI_DEVICE_ALIVE;
drivers/mmc/host/sdhci-s3c.c:322:	tasklet_schedule(&sc->host->card_tasklet);
drivers/mmc/host/sdhci-s3c.c:407:					mmc_hostname(host->mmc));
drivers/mmc/host/sdhci-s3c.c:414:	host->ioaddr = ioremap_nocache(res->start, resource_size(res));
drivers/mmc/host/sdhci-s3c.c:415:	if (!host->ioaddr) {
drivers/mmc/host/sdhci-s3c.c:428:	host->hw_name = "samsung-hsmmc";
drivers/mmc/host/sdhci-s3c.c:429:	host->ops = &sdhci_s3c_ops;
drivers/mmc/host/sdhci-s3c.c:430:	host->quirks = 0;
drivers/mmc/host/sdhci-s3c.c:431:	host->irq = irq;
drivers/mmc/host/sdhci-s3c.c:434:	host->quirks |= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC;
drivers/mmc/host/sdhci-s3c.c:435:	host->quirks |= SDHCI_QUIRK_BROKEN_CARD_PRESENT_BIT;
drivers/mmc/host/sdhci-s3c.c:436:	host->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
drivers/mmc/host/sdhci-s3c.c:442:	host->quirks |= SDHCI_QUIRK_BROKEN_DMA;
drivers/mmc/host/sdhci-s3c.c:445:	host->quirks |= SDHCI_QUIRK_NO_MULTIBLOCK;
drivers/mmc/host/sdhci-s3c.c:452:	host->quirks |= SDHCI_QUIRK_NO_BUSY_IRQ;
drivers/mmc/host/sdhci-s3c.c:454:	host->quirks |= (SDHCI_QUIRK_32BIT_DMA_ADDR |
drivers/mmc/host/sdhci-s3c.c:457:	host->quirks |= SDHCI_QUIRK_NO_HISPD_BIT;
drivers/mmc/host/sdhci-s3c.c:460:		host->mmc->caps = pdata->host_caps;
drivers/mmc/host/sdhci-s3c.c:462:		host->mmc->caps = 0;
drivers/mmc/host/sdhci-s3c.c:465:	host->mmc->pm_caps = MMC_PM_KEEP_POWER | MMC_PM_IGNORE_PM_NOTIFY;
drivers/mmc/host/sdhci-s3c.c:467:		host->mmc->pm_flags = MMC_PM_KEEP_POWER | MMC_PM_IGNORE_PM_NOTIFY;
drivers/mmc/host/sdhci-s3c.c:474:			host->flags |= SDHCI_DEVICE_ALIVE;
drivers/mmc/host/sdhci-s3c.c:490:				IRQF_SHARED, mmc_hostname(host->mmc), sc);
drivers/mmc/host/sdhci-s3c.c:531:	scratch = readl(host->ioaddr + SDHCI_INT_STATUS);
drivers/mmc/host/sdhci-s3c.c:549:	iounmap(host->ioaddr);
drivers/mmc/host/sdhci-s3c.c:566:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/sdhci-s3c.c:588:		ret = request_irq(pdata->ext_cd, sdhci_irq_cd, IRQF_SHARED, mmc_hostname(host->mmc), sdhci_priv(host));
